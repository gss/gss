;(function(){

/**
 * Require the given path.
 *
 * @param {String} path
 * @return {Object} exports
 * @api public
 */

function require(path, parent, orig) {
  var resolved = require.resolve(path);

  // lookup failed
  if (null == resolved) {
    orig = orig || path;
    parent = parent || 'root';
    var err = new Error('Failed to require "' + orig + '" from "' + parent + '"');
    err.path = orig;
    err.parent = parent;
    err.require = true;
    throw err;
  }

  var module = require.modules[resolved];

  // perform real require()
  // by invoking the module's
  // registered function
  if (!module._resolving && !module.exports) {
    var mod = {};
    mod.exports = {};
    mod.client = mod.component = true;
    module._resolving = true;
    module.call(this, mod.exports, require.relative(resolved), mod);
    delete module._resolving;
    module.exports = mod.exports;
  }

  return module.exports;
}

/**
 * Registered modules.
 */

require.modules = {};

/**
 * Registered aliases.
 */

require.aliases = {};

/**
 * Resolve `path`.
 *
 * Lookup:
 *
 *   - PATH/index.js
 *   - PATH.js
 *   - PATH
 *
 * @param {String} path
 * @return {String} path or null
 * @api private
 */

require.resolve = function(path) {
  if (path.charAt(0) === '/') path = path.slice(1);

  var paths = [
    path,
    path + '.js',
    path + '.json',
    path + '/index.js',
    path + '/index.json'
  ];

  for (var i = 0; i < paths.length; i++) {
    var path = paths[i];
    if (require.modules.hasOwnProperty(path)) return path;
    if (require.aliases.hasOwnProperty(path)) return require.aliases[path];
  }
};

/**
 * Normalize `path` relative to the current path.
 *
 * @param {String} curr
 * @param {String} path
 * @return {String}
 * @api private
 */

require.normalize = function(curr, path) {
  var segs = [];

  if ('.' != path.charAt(0)) return path;

  curr = curr.split('/');
  path = path.split('/');

  for (var i = 0; i < path.length; ++i) {
    if ('..' == path[i]) {
      curr.pop();
    } else if ('.' != path[i] && '' != path[i]) {
      segs.push(path[i]);
    }
  }

  return curr.concat(segs).join('/');
};

/**
 * Register module at `path` with callback `definition`.
 *
 * @param {String} path
 * @param {Function} definition
 * @api private
 */

require.register = function(path, definition) {
  require.modules[path] = definition;
};

/**
 * Alias a module definition.
 *
 * @param {String} from
 * @param {String} to
 * @api private
 */

require.alias = function(from, to) {
  if (!require.modules.hasOwnProperty(from)) {
    throw new Error('Failed to alias "' + from + '", it does not exist');
  }
  require.aliases[to] = from;
};

/**
 * Return a require function relative to the `parent` path.
 *
 * @param {String} parent
 * @return {Function}
 * @api private
 */

require.relative = function(parent) {
  var p = require.normalize(parent, '..');

  /**
   * lastIndexOf helper.
   */

  function lastIndexOf(arr, obj) {
    var i = arr.length;
    while (i--) {
      if (arr[i] === obj) return i;
    }
    return -1;
  }

  /**
   * The relative require() itself.
   */

  function localRequire(path) {
    var resolved = localRequire.resolve(path);
    return require(resolved, parent, path);
  }

  /**
   * Resolve relative to the parent.
   */

  localRequire.resolve = function(path) {
    var c = path.charAt(0);
    if ('/' == c) return path.slice(1);
    if ('.' == c) return require.normalize(p, path);

    // resolve deps by returning
    // the dep in the nearest "deps"
    // directory
    var segs = parent.split('/');
    var i = lastIndexOf(segs, 'deps') + 1;
    if (!i) i = 0;
    path = segs.slice(0, i + 1).join('/') + '/deps/' + path;
    return path;
  };

  /**
   * Check if module is defined at `path`.
   */

  localRequire.exists = function(path) {
    return require.modules.hasOwnProperty(localRequire.resolve(path));
  };

  return localRequire;
};
require.register("the-gss-preparser/lib/gss-preparser.js", function(exports, require, module){
module.exports = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "start": parse_start,
        "statement": parse_statement,
        "gssBlob": parse_gssBlob,
        "ccss": parse_ccss,
        "ccssOp": parse_ccssOp,
        "vfl": parse_vfl,
        "gtl": parse_gtl,
        "cssBlock": parse_cssBlock,
        "cssLine": parse_cssLine,
        "comment": parse_comment,
        "_": parse__,
        "__": parse___,
        "space": parse_space,
        "char": parse_char,
        "anychar": parse_anychar,
        "multitoend": parse_multitoend,
        "anytoend": parse_anytoend,
        "LineTerminator": parse_LineTerminator
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "start";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_start() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = [];
        result1 = parse_LineTerminator();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_LineTerminator();
        }
        if (result0 !== null) {
          result2 = parse_statement();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_statement();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, s) {return s})(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          result0 = parse__();
        }
        return result0;
      }
      
      function parse_statement() {
        var result0;
        
        result0 = parse_gssBlob();
        if (result0 === null) {
          result0 = parse_cssBlock();
          if (result0 === null) {
            result0 = parse_cssLine();
          }
        }
        return result0;
      }
      
      function parse_gssBlob() {
        var result0;
        
        result0 = parse_ccss();
        if (result0 === null) {
          result0 = parse_vfl();
          if (result0 === null) {
            result0 = parse_gtl();
          }
        }
        return result0;
      }
      
      function parse_ccss() {
        var result0, result1, result2, result3, result4, result5, result6, result7, result8;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse__();
        if (result0 !== null) {
          result2 = parse_char();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_char();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse__();
            if (result2 !== null) {
              result3 = parse_ccssOp();
              if (result3 !== null) {
                result4 = parse_anytoend();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, ccss) { return ['ccss', parser.stringify(ccss)]; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse__();
          if (result0 !== null) {
            if (input.charCodeAt(pos) === 64) {
              result1 = "@";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"@\"");
              }
            }
            if (result1 !== null) {
              if (input.substr(pos, 5) === "-gss-") {
                result2 = "-gss-";
                pos += 5;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-gss-\"");
                }
              }
              result2 = result2 !== null ? result2 : "";
              if (result2 !== null) {
                if (input.substr(pos, 4) === "stay") {
                  result3 = "stay";
                  pos += 4;
                } else {
                  result3 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"stay\"");
                  }
                }
                if (result3 !== null) {
                  result4 = parse_anytoend();
                  if (result4 !== null) {
                    result0 = [result0, result1, result2, result3, result4];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, stay) { return ['ccss', parser.stringify(stay)]; })(pos0, result0);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            result0 = parse__();
            if (result0 !== null) {
              if (input.charCodeAt(pos) === 64) {
                result1 = "@";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"@\"");
                }
              }
              if (result1 !== null) {
                if (input.substr(pos, 5) === "-gss-") {
                  result2 = "-gss-";
                  pos += 5;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"-gss-\"");
                  }
                }
                result2 = result2 !== null ? result2 : "";
                if (result2 !== null) {
                  if (input.substr(pos, 5) === "chain") {
                    result3 = "chain";
                    pos += 5;
                  } else {
                    result3 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"chain\"");
                    }
                  }
                  if (result3 !== null) {
                    result4 = parse_anytoend();
                    if (result4 !== null) {
                      result0 = [result0, result1, result2, result3, result4];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, chain) { return ['ccss', parser.stringify(chain)]; })(pos0, result0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              pos1 = pos;
              result0 = parse__();
              if (result0 !== null) {
                if (input.charCodeAt(pos) === 64) {
                  result1 = "@";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"@\"");
                  }
                }
                if (result1 !== null) {
                  if (input.substr(pos, 5) === "-gss-") {
                    result2 = "-gss-";
                    pos += 5;
                  } else {
                    result2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"-gss-\"");
                    }
                  }
                  result2 = result2 !== null ? result2 : "";
                  if (result2 !== null) {
                    if (input.substr(pos, 8) === "for-each") {
                      result3 = "for-each";
                      pos += 8;
                    } else {
                      result3 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"for-each\"");
                      }
                    }
                    if (result3 === null) {
                      if (input.substr(pos, 7) === "for-all") {
                        result3 = "for-all";
                        pos += 7;
                      } else {
                        result3 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"for-all\"");
                        }
                      }
                    }
                    if (result3 !== null) {
                      if (/^[^`]/.test(input.charAt(pos))) {
                        result5 = input.charAt(pos);
                        pos++;
                      } else {
                        result5 = null;
                        if (reportFailures === 0) {
                          matchFailed("[^`]");
                        }
                      }
                      if (result5 !== null) {
                        result4 = [];
                        while (result5 !== null) {
                          result4.push(result5);
                          if (/^[^`]/.test(input.charAt(pos))) {
                            result5 = input.charAt(pos);
                            pos++;
                          } else {
                            result5 = null;
                            if (reportFailures === 0) {
                              matchFailed("[^`]");
                            }
                          }
                        }
                      } else {
                        result4 = null;
                      }
                      if (result4 !== null) {
                        if (input.substr(pos, 3) === "```") {
                          result5 = "```";
                          pos += 3;
                        } else {
                          result5 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"```\"");
                          }
                        }
                        if (result5 !== null) {
                          if (/^[^`]/.test(input.charAt(pos))) {
                            result7 = input.charAt(pos);
                            pos++;
                          } else {
                            result7 = null;
                            if (reportFailures === 0) {
                              matchFailed("[^`]");
                            }
                          }
                          if (result7 !== null) {
                            result6 = [];
                            while (result7 !== null) {
                              result6.push(result7);
                              if (/^[^`]/.test(input.charAt(pos))) {
                                result7 = input.charAt(pos);
                                pos++;
                              } else {
                                result7 = null;
                                if (reportFailures === 0) {
                                  matchFailed("[^`]");
                                }
                              }
                            }
                          } else {
                            result6 = null;
                          }
                          if (result6 !== null) {
                            if (input.substr(pos, 3) === "```") {
                              result7 = "```";
                              pos += 3;
                            } else {
                              result7 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"```\"");
                              }
                            }
                            if (result7 !== null) {
                              result8 = parse_anytoend();
                              if (result8 !== null) {
                                result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8];
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 !== null) {
                result0 = (function(offset, forlooper) { return ['ccss', parser.stringify(forlooper)]; })(pos0, result0);
              }
              if (result0 === null) {
                pos = pos0;
              }
            }
          }
        }
        return result0;
      }
      
      function parse_ccssOp() {
        var result0;
        
        if (input.substr(pos, 2) === ">=") {
          result0 = ">=";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\">=\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 2) === "==") {
            result0 = "==";
            pos += 2;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"==\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 2) === "<=") {
              result0 = "<=";
              pos += 2;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"<=\"");
              }
            }
          }
        }
        return result0;
      }
      
      function parse_vfl() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse__();
        if (result0 !== null) {
          if (input.substr(pos, 6) === "@-gss-") {
            result1 = "@-gss-";
            pos += 6;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"@-gss-\"");
            }
          }
          if (result1 === null) {
            if (input.charCodeAt(pos) === 64) {
              result1 = "@";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"@\"");
              }
            }
          }
          if (result1 !== null) {
            if (input.substr(pos, 10) === "horizontal") {
              result2 = "horizontal";
              pos += 10;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"horizontal\"");
              }
            }
            if (result2 === null) {
              if (input.substr(pos, 8) === "vertical") {
                result2 = "vertical";
                pos += 8;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"vertical\"");
                }
              }
              if (result2 === null) {
                if (input.charCodeAt(pos) === 104) {
                  result2 = "h";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"h\"");
                  }
                }
                if (result2 === null) {
                  if (input.charCodeAt(pos) === 118) {
                    result2 = "v";
                    pos++;
                  } else {
                    result2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"v\"");
                    }
                  }
                }
              }
            }
            if (result2 !== null) {
              result3 = parse_anytoend();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, vfl) { return ['vfl', parser.stringify(vfl)]; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_gtl() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse__();
        if (result0 !== null) {
          if (input.substr(pos, 6) === "@-gss-") {
            result1 = "@-gss-";
            pos += 6;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"@-gss-\"");
            }
          }
          if (result1 !== null) {
            if (input.substr(pos, 6) === "layout") {
              result2 = "layout";
              pos += 6;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"layout\"");
              }
            }
            if (result2 === null) {
              if (input.substr(pos, 8) === "template") {
                result2 = "template";
                pos += 8;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"template\"");
                }
              }
            }
            if (result2 !== null) {
              result3 = parse_multitoend();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, gtl) { return ['gtl', parser.stringify(gtl)]; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_cssBlock() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result1 = parse_anychar();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_anychar();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = parse_multitoend();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, block) { return ['css', parser.stringify(block)]; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_cssLine() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result1 = parse_anychar();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_anychar();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = parse_anytoend();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, line) { return ['css', parser.stringify(line)]; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_comment() {
        var result0, result1, result2, result3, result4, result5, result6, result7, result8;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse__();
        if (result0 !== null) {
          if (input.substr(pos, 2) === "/*") {
            result1 = "/*";
            pos += 2;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"/*\"");
            }
          }
          if (result1 !== null) {
            result2 = [];
            if (/^[^*]/.test(input.charAt(pos))) {
              result3 = input.charAt(pos);
              pos++;
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("[^*]");
              }
            }
            while (result3 !== null) {
              result2.push(result3);
              if (/^[^*]/.test(input.charAt(pos))) {
                result3 = input.charAt(pos);
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("[^*]");
                }
              }
            }
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 42) {
                result4 = "*";
                pos++;
              } else {
                result4 = null;
                if (reportFailures === 0) {
                  matchFailed("\"*\"");
                }
              }
              if (result4 !== null) {
                result3 = [];
                while (result4 !== null) {
                  result3.push(result4);
                  if (input.charCodeAt(pos) === 42) {
                    result4 = "*";
                    pos++;
                  } else {
                    result4 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"*\"");
                    }
                  }
                }
              } else {
                result3 = null;
              }
              if (result3 !== null) {
                result4 = [];
                pos2 = pos;
                if (/^[^\/*]/.test(input.charAt(pos))) {
                  result5 = input.charAt(pos);
                  pos++;
                } else {
                  result5 = null;
                  if (reportFailures === 0) {
                    matchFailed("[^\\/*]");
                  }
                }
                if (result5 !== null) {
                  result6 = [];
                  if (/^[^*]/.test(input.charAt(pos))) {
                    result7 = input.charAt(pos);
                    pos++;
                  } else {
                    result7 = null;
                    if (reportFailures === 0) {
                      matchFailed("[^*]");
                    }
                  }
                  while (result7 !== null) {
                    result6.push(result7);
                    if (/^[^*]/.test(input.charAt(pos))) {
                      result7 = input.charAt(pos);
                      pos++;
                    } else {
                      result7 = null;
                      if (reportFailures === 0) {
                        matchFailed("[^*]");
                      }
                    }
                  }
                  if (result6 !== null) {
                    if (input.charCodeAt(pos) === 42) {
                      result8 = "*";
                      pos++;
                    } else {
                      result8 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"*\"");
                      }
                    }
                    if (result8 !== null) {
                      result7 = [];
                      while (result8 !== null) {
                        result7.push(result8);
                        if (input.charCodeAt(pos) === 42) {
                          result8 = "*";
                          pos++;
                        } else {
                          result8 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"*\"");
                          }
                        }
                      }
                    } else {
                      result7 = null;
                    }
                    if (result7 !== null) {
                      result5 = [result5, result6, result7];
                    } else {
                      result5 = null;
                      pos = pos2;
                    }
                  } else {
                    result5 = null;
                    pos = pos2;
                  }
                } else {
                  result5 = null;
                  pos = pos2;
                }
                while (result5 !== null) {
                  result4.push(result5);
                  pos2 = pos;
                  if (/^[^\/*]/.test(input.charAt(pos))) {
                    result5 = input.charAt(pos);
                    pos++;
                  } else {
                    result5 = null;
                    if (reportFailures === 0) {
                      matchFailed("[^\\/*]");
                    }
                  }
                  if (result5 !== null) {
                    result6 = [];
                    if (/^[^*]/.test(input.charAt(pos))) {
                      result7 = input.charAt(pos);
                      pos++;
                    } else {
                      result7 = null;
                      if (reportFailures === 0) {
                        matchFailed("[^*]");
                      }
                    }
                    while (result7 !== null) {
                      result6.push(result7);
                      if (/^[^*]/.test(input.charAt(pos))) {
                        result7 = input.charAt(pos);
                        pos++;
                      } else {
                        result7 = null;
                        if (reportFailures === 0) {
                          matchFailed("[^*]");
                        }
                      }
                    }
                    if (result6 !== null) {
                      if (input.charCodeAt(pos) === 42) {
                        result8 = "*";
                        pos++;
                      } else {
                        result8 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"*\"");
                        }
                      }
                      if (result8 !== null) {
                        result7 = [];
                        while (result8 !== null) {
                          result7.push(result8);
                          if (input.charCodeAt(pos) === 42) {
                            result8 = "*";
                            pos++;
                          } else {
                            result8 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"*\"");
                            }
                          }
                        }
                      } else {
                        result7 = null;
                      }
                      if (result7 !== null) {
                        result5 = [result5, result6, result7];
                      } else {
                        result5 = null;
                        pos = pos2;
                      }
                    } else {
                      result5 = null;
                      pos = pos2;
                    }
                  } else {
                    result5 = null;
                    pos = pos2;
                  }
                }
                if (result4 !== null) {
                  if (input.charCodeAt(pos) === 47) {
                    result5 = "/";
                    pos++;
                  } else {
                    result5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"/\"");
                    }
                  }
                  if (result5 !== null) {
                    result6 = parse__();
                    if (result6 !== null) {
                      result7 = [];
                      result8 = parse_LineTerminator();
                      while (result8 !== null) {
                        result7.push(result8);
                        result8 = parse_LineTerminator();
                      }
                      if (result7 !== null) {
                        result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ""})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse__() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_space();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_space();
        }
        return result0;
      }
      
      function parse___() {
        var result0, result1;
        
        result1 = parse_space();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_space();
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_space() {
        var result0;
        
        if (input.charCodeAt(pos) === 32) {
          result0 = " ";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\" \"");
          }
        }
        if (result0 === null) {
          if (/^[\t]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[\\t]");
            }
          }
          if (result0 === null) {
            if (/^[\xA0]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[\\xA0]");
              }
            }
          }
        }
        return result0;
      }
      
      function parse_char() {
        var result0;
        
        if (/^[a-zA-Z0-9_#.[\]\-]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9_#.[\\]\\-]");
          }
        }
        return result0;
      }
      
      function parse_anychar() {
        var result0;
        
        if (/^[a-zA-Z0-9 .,#:{}@+?!^=()_\-$*\/\\]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9 .,#:{}@+?!^=()_\\-$*\\/\\\\]");
          }
        }
        return result0;
      }
      
      function parse_multitoend() {
        var result0, result1, result2, result3, result4;
        var pos0;
        
        pos0 = pos;
        result0 = [];
        if (/^[^}]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[^}]");
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          if (/^[^}]/.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("[^}]");
            }
          }
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 125) {
            result1 = "}";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"}\"");
            }
          }
          if (result1 !== null) {
            result2 = parse__();
            if (result2 !== null) {
              result3 = [];
              result4 = parse_LineTerminator();
              while (result4 !== null) {
                result3.push(result4);
                result4 = parse_LineTerminator();
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_anytoend() {
        var result0, result1, result2, result3, result4;
        var pos0;
        
        pos0 = pos;
        result0 = [];
        if (/^[^;]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[^;]");
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          if (/^[^;]/.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("[^;]");
            }
          }
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 59) {
            result1 = ";";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\";\"");
            }
          }
          if (result1 !== null) {
            result2 = parse__();
            if (result2 !== null) {
              result3 = [];
              result4 = parse_LineTerminator();
              while (result4 !== null) {
                result3.push(result4);
                result4 = parse_LineTerminator();
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_LineTerminator() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (/^[\n\r\u2028\u2029]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\n\\r\\u2028\\u2029]");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 2) === "\r\n") {
            result0 = "\r\n";
            pos += 2;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\r\\n\"");
            }
          }
        }
        if (result0 !== null) {
          result1 = parse__();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        if (result0 === null) {
          result0 = parse_comment();
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
        var parser, flatten; 
      
        parser = this;
      
        String.prototype.trim = String.prototype.trim || function trim() { return this.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); };
      
        flatten = parser.flatten = function (array, isShallow) {
          var index = -1,
            length = array ? array.length : 0,
            result = [];
      
          while (++index < length) {
            var value = array[index];
      
            if (value instanceof Array) {
              Array.prototype.push.apply(result, isShallow ? value : flatten(value));
            }
            else {
              result.push(value);
            }
          }
          return result;
        }
        parser.results = []
        parser.stringify = function (array) {
          return flatten(array).join("").trim()
        }
      
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();
});
require.register("the-gss-ccss-compiler/lib/ccss-compiler.js", function(exports, require, module){
module.exports = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "start": parse_start,
        "Statement": parse_Statement,
        "Chain": parse_Chain,
        "Chainer": parse_Chainer,
        "HeadExp": parse_HeadExp,
        "TailExp": parse_TailExp,
        "ChainMath": parse_ChainMath,
        "ChainEq": parse_ChainEq,
        "ForEach": parse_ForEach,
        "JavaScript": parse_JavaScript,
        "ForLooperType": parse_ForLooperType,
        "Stay": parse_Stay,
        "StayVars": parse_StayVars,
        "StayStart": parse_StayStart,
        "LinearExpression": parse_LinearExpression,
        "StrengthAndWeight": parse_StrengthAndWeight,
        "Weight": parse_Weight,
        "Strength": parse_Strength,
        "EqOperator": parse_EqOperator,
        "AdditiveExpression": parse_AdditiveExpression,
        "AdditiveOperator": parse_AdditiveOperator,
        "MultiplicativeExpression": parse_MultiplicativeExpression,
        "MultiplicativeOperator": parse_MultiplicativeOperator,
        "UnaryExpression": parse_UnaryExpression,
        "UnaryOperator": parse_UnaryOperator,
        "PrimaryExpression": parse_PrimaryExpression,
        "Measure": parse_Measure,
        "Var": parse_Var,
        "VarNames": parse_VarNames,
        "Selector": parse_Selector,
        "QuerySelectorChars": parse_QuerySelectorChars,
        "ReservedPseudos": parse_ReservedPseudos,
        "NameChars": parse_NameChars,
        "NameCharsWithSpace": parse_NameCharsWithSpace,
        "Literal": parse_Literal,
        "Integer": parse_Integer,
        "Real": parse_Real,
        "SignedInteger": parse_SignedInteger,
        "SourceCharacter": parse_SourceCharacter,
        "WhiteSpace": parse_WhiteSpace,
        "LineTerminator": parse_LineTerminator,
        "LineTerminatorSequence": parse_LineTerminatorSequence,
        "EOS": parse_EOS,
        "EOF": parse_EOF,
        "Comment": parse_Comment,
        "MultiLineComment": parse_MultiLineComment,
        "MultiLineCommentNoLineTerminator": parse_MultiLineCommentNoLineTerminator,
        "SingleLineComment": parse_SingleLineComment,
        "_": parse__,
        "__": parse___
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "start";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_start() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse___();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_Statement();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_Statement();
          }
          if (result1 !== null) {
            result2 = parse___();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, statements) { return (parser.getResults()); })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Statement() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_LinearExpression();
        if (result0 !== null) {
          result1 = parse_EOS();
          if (result1 !== null) {
            result2 = parse___();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, exp) { return exp; })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_Stay();
          if (result0 !== null) {
            result1 = parse_EOS();
            if (result1 !== null) {
              result2 = parse___();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, stay) { return stay; })(pos0, result0[0]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            result0 = parse_Chain();
            if (result0 !== null) {
              result1 = parse_EOS();
              if (result1 !== null) {
                result2 = parse___();
                if (result2 !== null) {
                  result0 = [result0, result1, result2];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, chain) { return chain; })(pos0, result0[0]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              pos1 = pos;
              result0 = parse_ForEach();
              if (result0 !== null) {
                result1 = parse_EOS();
                if (result1 !== null) {
                  result2 = parse___();
                  if (result2 !== null) {
                    result0 = [result0, result1, result2];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 !== null) {
                result0 = (function(offset, js) { return js; })(pos0, result0[0]);
              }
              if (result0 === null) {
                pos = pos0;
              }
            }
          }
        }
        return result0;
      }
      
      function parse_Chain() {
        var result0, result1, result2, result3, result4, result5, result6, result7;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 64) {
          result0 = "@";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"@\"");
          }
        }
        if (result0 !== null) {
          if (input.substr(pos, 5) === "-gss-") {
            result1 = "-gss-";
            pos += 5;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"-gss-\"");
            }
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            if (input.substr(pos, 5) === "chain") {
              result2 = "chain";
              pos += 5;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"chain\"");
              }
            }
            if (result2 !== null) {
              result3 = parse___();
              if (result3 !== null) {
                result4 = parse_Selector();
                if (result4 !== null) {
                  result5 = parse___();
                  if (result5 !== null) {
                    result7 = parse_Chainer();
                    if (result7 !== null) {
                      result6 = [];
                      while (result7 !== null) {
                        result6.push(result7);
                        result7 = parse_Chainer();
                      }
                    } else {
                      result6 = null;
                    }
                    if (result6 !== null) {
                      result7 = parse___();
                      if (result7 !== null) {
                        result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, $, chainers) { //sw:StrengthAndWeight?
            parser.add$($.selector);
            var ast = ['chain',$.ast];
            chainers.forEach(function(chainer){
                //if (sw && !chainer.__has_sw ) {
                //  chainer = chainer.concat(sw);
                //}
                ast = ast.concat(chainer);        
              });    
        
            p.addC(ast);
          })(pos0, result0[4], result0[6]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Chainer() {
        var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12, result13, result14, result15;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (/^[a-zA-Z\-_0-9]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z\\-_0-9]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[a-zA-Z\-_0-9]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[a-zA-Z\\-_0-9]");
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 40) {
            result1 = "(";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"(\"");
            }
          }
          if (result1 !== null) {
            result2 = parse__();
            if (result2 !== null) {
              result3 = parse_HeadExp();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result4 = parse__();
                if (result4 !== null) {
                  result5 = parse_ChainEq();
                  if (result5 !== null) {
                    result6 = parse__();
                    if (result6 !== null) {
                      result7 = parse_AdditiveExpression();
                      result7 = result7 !== null ? result7 : "";
                      if (result7 !== null) {
                        result8 = parse__();
                        if (result8 !== null) {
                          result9 = parse_ChainEq();
                          result9 = result9 !== null ? result9 : "";
                          if (result9 !== null) {
                            result10 = parse__();
                            if (result10 !== null) {
                              result11 = parse_StrengthAndWeight();
                              result11 = result11 !== null ? result11 : "";
                              if (result11 !== null) {
                                result12 = parse__();
                                if (result12 !== null) {
                                  if (input.charCodeAt(pos) === 41) {
                                    result13 = ")";
                                    pos++;
                                  } else {
                                    result13 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\")\"");
                                    }
                                  }
                                  if (result13 !== null) {
                                    result14 = [];
                                    if (/^[a-zA-Z\-_0-9]/.test(input.charAt(pos))) {
                                      result15 = input.charAt(pos);
                                      pos++;
                                    } else {
                                      result15 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("[a-zA-Z\\-_0-9]");
                                      }
                                    }
                                    while (result15 !== null) {
                                      result14.push(result15);
                                      if (/^[a-zA-Z\-_0-9]/.test(input.charAt(pos))) {
                                        result15 = input.charAt(pos);
                                        pos++;
                                      } else {
                                        result15 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("[a-zA-Z\\-_0-9]");
                                        }
                                      }
                                    }
                                    if (result14 !== null) {
                                      result15 = parse___();
                                      if (result15 !== null) {
                                        result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12, result13, result14, result15];
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, head, headExp, headEq, bridgeVal, tailEq, sw, tail) {
            var asts = []
            head = p.toString(head);
            tail = p.toString(tail);    
            var getAST = function (op, e1, e2) {
              var ast = [op, e1, e2];
              if (sw) {
                ast = ast.concat(sw);
                //ast.__has_sw = true;
              }
              return ast      
            }
            
            if (tail.length === 0) {tail = head;}
            if (headExp) {
              headExp.splice(1,1,head);
              head = headExp;
            }
            /*
            if (tailExp) {
              tailExp.splice(2,1,tail);
              tail = tailExp;
            }
            */
            if (bridgeVal) {
              asts.push( getAST(headEq,head,bridgeVal) );
              if (tailEq) {
                asts.push( getAST(tailEq,bridgeVal,tail) );
              }
              else {
                p.error("Invalid Chain Statement",line,column);
              }      
            } else {
              asts.push( getAST(headEq,head,tail) );
            }
            return asts;
          })(pos0, result0[0], result0[3], result0[5], result0[7], result0[9], result0[11], result0[14]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_HeadExp() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_ChainMath();
        if (result0 !== null) {
          result1 = parse_AdditiveExpression();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, math, val) {
            return [math, "_REPLACE_ME_", val]
          })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_TailExp() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_AdditiveExpression();
        if (result0 !== null) {
          result1 = parse_ChainMath();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, val, math) {
            return [math, val, "_REPLACE_ME_"]
          })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ChainMath() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 43) {
          result0 = "+";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"+\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "plus-chain"})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.charCodeAt(pos) === 45) {
            result0 = "-";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) {return "minus-chain"})(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            if (input.charCodeAt(pos) === 42) {
              result0 = "*";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"*\"");
              }
            }
            if (result0 !== null) {
              result0 = (function(offset) {return "multiply-chain"})(pos0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              if (input.charCodeAt(pos) === 47) {
                result0 = "/";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"/\"");
                }
              }
              if (result0 !== null) {
                result0 = (function(offset) {return "divide-chain"})(pos0);
              }
              if (result0 === null) {
                pos = pos0;
              }
            }
          }
        }
        return result0;
      }
      
      function parse_ChainEq() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_EqOperator();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result0 = (function(offset, chainEq) {
            if (!chainEq) {chainEq = "eq";}
            chainEq += "-chain";
            return chainEq;
          })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ForEach() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_ForLooperType();
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result2 = parse_Selector();
            if (result2 !== null) {
              result3 = parse___();
              if (result3 !== null) {
                result4 = parse_JavaScript();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, type, $, js) {
            parser.add$($.selector);
            parser.addC([type,$.ast,js]);
            })(pos0, result0[0], result0[2], result0[4]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_JavaScript() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 3) === "```") {
          result0 = "```";
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"```\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          if (/^[^`]/.test(input.charAt(pos))) {
            result2 = input.charAt(pos);
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[^`]");
            }
          }
          while (result2 !== null) {
            result1.push(result2);
            if (/^[^`]/.test(input.charAt(pos))) {
              result2 = input.charAt(pos);
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("[^`]");
              }
            }
          }
          if (result1 !== null) {
            if (input.substr(pos, 3) === "```") {
              result2 = "```";
              pos += 3;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"```\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, js) {return ['js',js.join("").trim()]})(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ForLooperType() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 14) === "@-gss-for-each") {
          result0 = "@-gss-for-each";
          pos += 14;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"@-gss-for-each\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 9) === "@for-each") {
            result0 = "@for-each";
            pos += 9;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"@for-each\"");
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "for-each"})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.substr(pos, 13) === "@-gss-for-all") {
            result0 = "@-gss-for-all";
            pos += 13;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"@-gss-for-all\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 8) === "@for-all") {
              result0 = "@for-all";
              pos += 8;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"@for-all\"");
              }
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) {return "for-all"})(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_Stay() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_StayStart();
        if (result0 !== null) {
          result2 = parse_StayVars();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_StayVars();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, vars) {
              var stay = ["stay"].concat(vars)
              parser.addC(stay)
              return stay;
            })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_StayVars() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse___();
        if (result0 !== null) {
          result1 = parse_Var();
          if (result1 !== null) {
            result2 = parse___();
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 44) {
                result3 = ",";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\",\"");
                }
              }
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, v) {return v})(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_StayStart() {
        var result0;
        
        if (input.substr(pos, 10) === "@-gss-stay") {
          result0 = "@-gss-stay";
          pos += 10;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"@-gss-stay\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 5) === "@stay") {
            result0 = "@stay";
            pos += 5;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"@stay\"");
            }
          }
        }
        return result0;
      }
      
      function parse_LinearExpression() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_AdditiveExpression();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse___();
          if (result2 !== null) {
            result3 = parse_EqOperator();
            if (result3 !== null) {
              result4 = parse___();
              if (result4 !== null) {
                result5 = parse_AdditiveExpression();
                if (result5 !== null) {
                  result2 = [result2, result3, result4, result5];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse___();
            if (result2 !== null) {
              result3 = parse_EqOperator();
              if (result3 !== null) {
                result4 = parse___();
                if (result4 !== null) {
                  result5 = parse_AdditiveExpression();
                  if (result5 !== null) {
                    result2 = [result2, result3, result4, result5];
                  } else {
                    result2 = null;
                    pos = pos2;
                  }
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result2 = parse___();
            if (result2 !== null) {
              result3 = parse_StrengthAndWeight();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, e1, tail, s) {
              var eq, e2;
              if (s.length === 0) {s = [];}
              for (var i = 0; i < tail.length; i++) {
                eq = tail[i][1];
                e2 = tail[i][3];
                parser.addC([
                  eq,
                  e1,
                  e2
                ].concat(s));
                e1 = e2;
              }
              return "LineaerExpression";
            })(pos0, result0[0], result0[1], result0[3]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_StrengthAndWeight() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 33) {
          result0 = "!";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"!\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_Strength();
          if (result1 !== null) {
            result2 = parse_Weight();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, s, w) {
              if (w.length === 0) {return [s];}
              return [s,w];
            })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 33) {
            result0 = "!";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"!\"");
            }
          }
          if (result0 !== null) {
            if (input.length > pos) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("any character");
              }
            }
            result1 = result1 !== null ? result1 : "";
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset) {return parser.error("Invalid Strength or Weight",line,column)})(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_Weight() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (/^[0-9]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[0-9]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, w) {return Number(w.join(""))})(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Strength() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 7) === "require") {
          result0 = "require";
          pos += 7;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"require\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 7) === "REQUIRE") {
            result0 = "REQUIRE";
            pos += 7;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"REQUIRE\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 7) === "Require") {
              result0 = "Require";
              pos += 7;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"Require\"");
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "require"})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.substr(pos, 6) === "strong") {
            result0 = "strong";
            pos += 6;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"strong\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 6) === "STRONG") {
              result0 = "STRONG";
              pos += 6;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"STRONG\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 6) === "Strong") {
                result0 = "Strong";
                pos += 6;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"Strong\"");
                }
              }
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) {return "strong"})(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            if (input.substr(pos, 6) === "medium") {
              result0 = "medium";
              pos += 6;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"medium\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 6) === "MEDIUM") {
                result0 = "MEDIUM";
                pos += 6;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"MEDIUM\"");
                }
              }
              if (result0 === null) {
                if (input.substr(pos, 6) === "Medium") {
                  result0 = "Medium";
                  pos += 6;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"Medium\"");
                  }
                }
              }
            }
            if (result0 !== null) {
              result0 = (function(offset) {return "medium"})(pos0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              if (input.substr(pos, 4) === "weak") {
                result0 = "weak";
                pos += 4;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"weak\"");
                }
              }
              if (result0 === null) {
                if (input.substr(pos, 4) === "WEAK") {
                  result0 = "WEAK";
                  pos += 4;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"WEAK\"");
                  }
                }
                if (result0 === null) {
                  if (input.substr(pos, 4) === "Weak") {
                    result0 = "Weak";
                    pos += 4;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"Weak\"");
                    }
                  }
                }
              }
              if (result0 !== null) {
                result0 = (function(offset) {return "weak"})(pos0);
              }
              if (result0 === null) {
                pos = pos0;
              }
              if (result0 === null) {
                pos0 = pos;
                if (input.substr(pos, 8) === "required") {
                  result0 = "required";
                  pos += 8;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"required\"");
                  }
                }
                if (result0 === null) {
                  if (input.substr(pos, 8) === "REQUIRED") {
                    result0 = "REQUIRED";
                    pos += 8;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"REQUIRED\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.substr(pos, 8) === "Required") {
                      result0 = "Required";
                      pos += 8;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"Required\"");
                      }
                    }
                  }
                }
                if (result0 !== null) {
                  result0 = (function(offset) {return "require"})(pos0);
                }
                if (result0 === null) {
                  pos = pos0;
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_EqOperator() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "==") {
          result0 = "==";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"==\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "eq" })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.substr(pos, 2) === "<=") {
            result0 = "<=";
            pos += 2;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"<=\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 2) === "=<") {
              result0 = "=<";
              pos += 2;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"=<\"");
              }
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) { return "lte" })(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            if (input.substr(pos, 2) === ">=") {
              result0 = ">=";
              pos += 2;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\">=\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 2) === "=>") {
                result0 = "=>";
                pos += 2;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"=>\"");
                }
              }
            }
            if (result0 !== null) {
              result0 = (function(offset) { return "gte" })(pos0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              if (input.charCodeAt(pos) === 60) {
                result0 = "<";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"<\"");
                }
              }
              if (result0 !== null) {
                result0 = (function(offset) { return "lt"  })(pos0);
              }
              if (result0 === null) {
                pos = pos0;
              }
              if (result0 === null) {
                pos0 = pos;
                if (input.charCodeAt(pos) === 62) {
                  result0 = ">";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\">\"");
                  }
                }
                if (result0 !== null) {
                  result0 = (function(offset) { return "gt"  })(pos0);
                }
                if (result0 === null) {
                  pos = pos0;
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_AdditiveExpression() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_MultiplicativeExpression();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse___();
          if (result2 !== null) {
            result3 = parse_AdditiveOperator();
            if (result3 !== null) {
              result4 = parse___();
              if (result4 !== null) {
                result5 = parse_MultiplicativeExpression();
                if (result5 !== null) {
                  result2 = [result2, result3, result4, result5];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse___();
            if (result2 !== null) {
              result3 = parse_AdditiveOperator();
              if (result3 !== null) {
                result4 = parse___();
                if (result4 !== null) {
                  result5 = parse_MultiplicativeExpression();
                  if (result5 !== null) {
                    result2 = [result2, result3, result4, result5];
                  } else {
                    result2 = null;
                    pos = pos2;
                  }
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, head, tail) {
              var result = head;
              for (var i = 0; i < tail.length; i++) {
                result = [
                  tail[i][1],
                  result,
                  tail[i][3]
                ];
              }
              return result;
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_AdditiveOperator() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 43) {
          result0 = "+";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"+\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "plus" })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.charCodeAt(pos) === 45) {
            result0 = "-";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) { return "minus" })(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_MultiplicativeExpression() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_UnaryExpression();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse___();
          if (result2 !== null) {
            result3 = parse_MultiplicativeOperator();
            if (result3 !== null) {
              result4 = parse___();
              if (result4 !== null) {
                result5 = parse_UnaryExpression();
                if (result5 !== null) {
                  result2 = [result2, result3, result4, result5];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse___();
            if (result2 !== null) {
              result3 = parse_MultiplicativeOperator();
              if (result3 !== null) {
                result4 = parse___();
                if (result4 !== null) {
                  result5 = parse_UnaryExpression();
                  if (result5 !== null) {
                    result2 = [result2, result3, result4, result5];
                  } else {
                    result2 = null;
                    pos = pos2;
                  }
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, head, tail) {
              var result = head;
              for (var i = 0; i < tail.length; i++) {
                result = [
                  tail[i][1],
                  result,
                  tail[i][3]
                ];
              }
              return result;
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_MultiplicativeOperator() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 42) {
          result0 = "*";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"*\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "multiply"})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.charCodeAt(pos) === 47) {
            result0 = "/";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"/\"");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) {return "divide"})(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_UnaryExpression() {
        var result0, result1, result2;
        var pos0, pos1;
        
        result0 = parse_PrimaryExpression();
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_UnaryOperator();
          if (result0 !== null) {
            result1 = parse___();
            if (result1 !== null) {
              result2 = parse_UnaryExpression();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, operator, expression) {
                return {
                  type:       "UnaryExpression",
                  operator:   operator,
                  expression: expression
                };
              })(pos0, result0[0], result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_UnaryOperator() {
        var result0;
        
        if (input.charCodeAt(pos) === 43) {
          result0 = "+";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"+\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 45) {
            result0 = "-";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 33) {
              result0 = "!";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"!\"");
              }
            }
          }
        }
        return result0;
      }
      
      function parse_PrimaryExpression() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        result0 = parse_Measure();
        if (result0 === null) {
          result0 = parse_Var();
          if (result0 === null) {
            result0 = parse_Literal();
            if (result0 === null) {
              pos0 = pos;
              pos1 = pos;
              if (input.charCodeAt(pos) === 40) {
                result0 = "(";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"(\"");
                }
              }
              if (result0 !== null) {
                result1 = parse___();
                if (result1 !== null) {
                  result2 = parse_LinearExpression();
                  if (result2 !== null) {
                    result3 = parse___();
                    if (result3 !== null) {
                      if (input.charCodeAt(pos) === 41) {
                        result4 = ")";
                        pos++;
                      } else {
                        result4 = null;
                        if (reportFailures === 0) {
                          matchFailed("\")\"");
                        }
                      }
                      if (result4 !== null) {
                        result0 = [result0, result1, result2, result3, result4];
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 !== null) {
                result0 = (function(offset, expression) { return expression; })(pos0, result0[2]);
              }
              if (result0 === null) {
                pos = pos0;
              }
            }
          }
        }
        return result0;
      }
      
      function parse_Measure() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 8) === "measure(") {
          result0 = "measure(";
          pos += 8;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"measure(\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result2 = parse_Var();
            if (result2 !== null) {
              result3 = parse___();
              if (result3 !== null) {
                if (input.charCodeAt(pos) === 41) {
                  result4 = ")";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\")\"");
                  }
                }
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, v) { return p.processMeasure(["measure",v]);})(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("measure");
        }
        return result0;
      }
      
      function parse_Var() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_Selector();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 91) {
            result1 = "[";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"[\"");
            }
          }
          if (result1 !== null) {
            result3 = parse_NameChars();
            if (result3 !== null) {
              result2 = [];
              while (result3 !== null) {
                result2.push(result3);
                result3 = parse_NameChars();
              }
            } else {
              result2 = null;
            }
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 93) {
                result3 = "]";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"]\"");
                }
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, $, v) {       
              var result, id, _id1, _id2;
              v = v.join("");      
              // if bound to dom query
              if ($.length !== 0) {
                parser.add$($.selector);
                // normalize var names when query bound
                if (v === 'left') {
                  v = 'x';
                } else if (v === 'top') {
                  v = 'y';
                } else if (v === 'cx') {
                  v = 'center-x';
                } else if (v === 'cy') {
                  v = 'center-y';
                }
                // normalize window var names
                if ($.selector === '::window') {
                  if (v === 'right') {
                    v = 'width'
                  } else if (v === 'bottom') {
                    v = 'height'
                  }
                }
                id = "["+v+"]";
                id = $.selector + id;
                // extract variable expresssions
                switch (v) {            
                  case 'right':
                    _id1 = $.selector + "[" + "x" + "]";
                    _id2 = $.selector + "[" + "width" + "]";
                    parser.addVar(['var', _id1, "x", $.ast], _id1);
                    parser.addVar(['var', _id2, "width", $.ast], _id2);
                    parser.addVar(['varexp',id,['plus',['get',_id1],['get',_id2]], $.ast], id);
                    break;
                  case 'bottom':
                    _id1 = $.selector + "[" + "y" + "]";
                    _id2 = $.selector + "[" + "height" + "]";
                    parser.addVar(['var', _id1, "y", $.ast], _id1);
                    parser.addVar(['var', _id2, "height", $.ast], _id2);
                    parser.addVar(['varexp',id,['plus',['get',_id1],['get',_id2]], $.ast], id);
                    break;
                  case 'center-x':          
                  case 'centerX':
                    _id1 = $.selector + "[" + "x" + "]";
                    _id2 = $.selector + "[" + "width" + "]";
                    parser.addVar(['var', _id1, "x", $.ast], _id1);
                    parser.addVar(['var', _id2, "width", $.ast], _id2);
                    parser.addVar(['varexp',id,['plus',['get',_id1],['divide',['get',_id2],2]], $.ast], id);                       break;
                  case 'center-y':
                  case 'centerY':
                    _id1 = $.selector + "[" + "y" + "]";
                    _id2 = $.selector + "[" + "height" + "]";
                    parser.addVar(['var', _id1, "y", $.ast], _id1);
                    parser.addVar(['var', _id2, "height", $.ast], _id2);
                    parser.addVar(['varexp',id,['plus',['get',_id1],['divide',['get',_id2],2]], $.ast], id);                       break;
                  default:
                    parser.addVar(['var',id,v,$.ast],id);
                }
                // add constraints for window x & y to be zero
                /*if ($.selector === '::window') {
                  if (v === 'x' || v === 'center-x') {
                    parser.addC([
                      'eq',
                      ['get', '::window[x]'],
                      ['number', 0],
                      'required'
                    ]);
                  } else if (v === 'y' || v === 'center-y') {
                    parser.addC([
                      'eq',
                      ['get', '::window[y]'],
                      ['number', 0],
                      'required'
                    ]);
                  }
                }*/
              }
              else {
                id = "["+v+"]";
                parser.addVar(['var',id],id);
                // ['_dimensionize',['get','width'],['get','height']]
              }
              if ($.selector) {
                return ['get',id,$.selector];
              } else {
                return ['get',id];
              }
              
            })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("variable");
        }
        return result0;
      }
      
      function parse_VarNames() {
        var result0;
        
        result0 = "";
        return result0;
      }
      
      function parse_Selector() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 35) {
          result0 = "#";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"#\"");
          }
        }
        if (result0 !== null) {
          result2 = parse_NameChars();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_NameChars();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, $) { $=p.toString($); return {selector:"#"+$,ast:["$id",$]} })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 46) {
            result0 = ".";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result0 !== null) {
            result2 = parse_NameChars();
            if (result2 !== null) {
              result1 = [];
              while (result2 !== null) {
                result1.push(result2);
                result2 = parse_NameChars();
              }
            } else {
              result1 = null;
            }
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, $) { $=p.toString($); return {selector:"."+$,ast:["$class",$]} })(pos0, result0[1]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            if (input.charCodeAt(pos) === 36) {
              result0 = "$";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"$\"");
              }
            }
            result0 = result0 !== null ? result0 : "";
            if (result0 !== null) {
              if (input.charCodeAt(pos) === 40) {
                result1 = "(";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"(\"");
                }
              }
              if (result1 !== null) {
                result3 = parse_QuerySelectorChars();
                if (result3 !== null) {
                  result2 = [];
                  while (result3 !== null) {
                    result2.push(result3);
                    result3 = parse_QuerySelectorChars();
                  }
                } else {
                  result2 = null;
                }
                if (result2 !== null) {
                  if (input.charCodeAt(pos) === 41) {
                    result3 = ")";
                    pos++;
                  } else {
                    result3 = null;
                    if (reportFailures === 0) {
                      matchFailed("\")\"");
                    }
                  }
                  if (result3 !== null) {
                    result0 = [result0, result1, result2, result3];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, $) { $=p.toString($); return {selector:$,ast:["$all",$]} })(pos0, result0[2]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              result1 = parse_NameChars();
              if (result1 !== null) {
                result0 = [];
                while (result1 !== null) {
                  result0.push(result1);
                  result1 = parse_NameChars();
                }
              } else {
                result0 = null;
              }
              if (result0 !== null) {
                result0 = (function(offset, $) { $=p.toString($); return {selector:$,ast:["$tag",$]} })(pos0, result0);
              }
              if (result0 === null) {
                pos = pos0;
              }
              if (result0 === null) {
                pos0 = pos;
                pos1 = pos;
                if (input.substr(pos, 2) === "::") {
                  result0 = "::";
                  pos += 2;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"::\"");
                  }
                }
                if (result0 !== null) {
                  result1 = parse_ReservedPseudos();
                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
                if (result0 !== null) {
                  result0 = (function(offset, $) {return {selector:"::"+$,ast:["$reserved", $]}})(pos0, result0[1]);
                }
                if (result0 === null) {
                  pos = pos0;
                }
              }
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("selector");
        }
        return result0;
      }
      
      function parse_QuerySelectorChars() {
        var result0;
        
        if (/^[a-zA-Z0-9#.\-_$=:+>'" \][]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9#.\\-_$=:+>'\" \\][]");
          }
        }
        return result0;
      }
      
      function parse_ReservedPseudos() {
        var result0;
        var pos0;
        
        if (input.substr(pos, 4) === "this") {
          result0 = "this";
          pos += 4;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"this\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 8) === "document") {
            result0 = "document";
            pos += 8;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"document\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 4) === "host") {
              result0 = "host";
              pos += 4;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"host\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 5) === "scope") {
                result0 = "scope";
                pos += 5;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"scope\"");
                }
              }
            }
          }
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.substr(pos, 6) === "window") {
            result0 = "window";
            pos += 6;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"window\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 8) === "viewport") {
              result0 = "viewport";
              pos += 8;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"viewport\"");
              }
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) {return "window"})(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_NameChars() {
        var result0;
        
        if (/^[a-zA-Z0-9#.\-_$]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9#.\\-_$]");
          }
        }
        return result0;
      }
      
      function parse_NameCharsWithSpace() {
        var result0;
        
        result0 = parse_NameChars();
        if (result0 === null) {
          if (input.charCodeAt(pos) === 32) {
            result0 = " ";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\" \"");
            }
          }
        }
        return result0;
      }
      
      function parse_Literal() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_Real();
        if (result0 === null) {
          result0 = parse_Integer();
        }
        if (result0 !== null) {
          result0 = (function(offset, val) {
            return [ "number",
              val
            ]
          })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Integer() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (/^[0-9]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[0-9]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, digits) {
            return parseInt(digits.join(""));
          })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Real() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_Integer();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 46) {
            result1 = ".";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_Integer();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, digits) {
            return parseFloat(digits.join(""));
          })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SignedInteger() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (/^[\-+]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\-+]");
          }
        }
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          if (/^[0-9]/.test(input.charAt(pos))) {
            result2 = input.charAt(pos);
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[0-9]");
            }
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              if (/^[0-9]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SourceCharacter() {
        var result0;
        
        if (input.length > pos) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("any character");
          }
        }
        return result0;
      }
      
      function parse_WhiteSpace() {
        var result0;
        
        reportFailures++;
        if (/^[\t\x0B\f \xA0\uFEFF]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\t\\x0B\\f \\xA0\\uFEFF]");
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("whitespace");
        }
        return result0;
      }
      
      function parse_LineTerminator() {
        var result0;
        
        if (/^[\n\r\u2028\u2029]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\n\\r\\u2028\\u2029]");
          }
        }
        return result0;
      }
      
      function parse_LineTerminatorSequence() {
        var result0;
        
        reportFailures++;
        if (input.charCodeAt(pos) === 10) {
          result0 = "\n";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\n\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 2) === "\r\n") {
            result0 = "\r\n";
            pos += 2;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\r\\n\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 13) {
              result0 = "\r";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\r\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 8232) {
                result0 = "\u2028";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\u2028\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 8233) {
                  result0 = "\u2029";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\u2029\"");
                  }
                }
              }
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("end of line");
        }
        return result0;
      }
      
      function parse_EOS() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = parse___();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 59) {
            result1 = ";";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\";\"");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          result0 = parse__();
          if (result0 !== null) {
            result1 = parse_LineTerminatorSequence();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            result0 = parse___();
            if (result0 !== null) {
              result1 = parse_EOF();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          }
        }
        return result0;
      }
      
      function parse_EOF() {
        var result0;
        var pos0;
        
        pos0 = pos;
        reportFailures++;
        if (input.length > pos) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("any character");
          }
        }
        reportFailures--;
        if (result0 === null) {
          result0 = "";
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Comment() {
        var result0;
        
        reportFailures++;
        result0 = parse_MultiLineComment();
        if (result0 === null) {
          result0 = parse_SingleLineComment();
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("comment");
        }
        return result0;
      }
      
      function parse_MultiLineComment() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "/*") {
          result0 = "/*";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/*\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          pos2 = pos;
          reportFailures++;
          if (input.substr(pos, 2) === "*/") {
            result2 = "*/";
            pos += 2;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\"*/\"");
            }
          }
          reportFailures--;
          if (result2 === null) {
            result2 = "";
          } else {
            result2 = null;
            pos = pos2;
          }
          if (result2 !== null) {
            result3 = parse_SourceCharacter();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            reportFailures--;
            if (result2 === null) {
              result2 = "";
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              result3 = parse_SourceCharacter();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_MultiLineCommentNoLineTerminator() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "/*") {
          result0 = "/*";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/*\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          pos2 = pos;
          reportFailures++;
          if (input.substr(pos, 2) === "*/") {
            result2 = "*/";
            pos += 2;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\"*/\"");
            }
          }
          if (result2 === null) {
            result2 = parse_LineTerminator();
          }
          reportFailures--;
          if (result2 === null) {
            result2 = "";
          } else {
            result2 = null;
            pos = pos2;
          }
          if (result2 !== null) {
            result3 = parse_SourceCharacter();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            if (result2 === null) {
              result2 = parse_LineTerminator();
            }
            reportFailures--;
            if (result2 === null) {
              result2 = "";
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              result3 = parse_SourceCharacter();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SingleLineComment() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "//") {
          result0 = "//";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"//\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          pos2 = pos;
          reportFailures++;
          result2 = parse_LineTerminator();
          reportFailures--;
          if (result2 === null) {
            result2 = "";
          } else {
            result2 = null;
            pos = pos2;
          }
          if (result2 !== null) {
            result3 = parse_SourceCharacter();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            result2 = parse_LineTerminator();
            reportFailures--;
            if (result2 === null) {
              result2 = "";
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              result3 = parse_SourceCharacter();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result2 = parse_LineTerminator();
            if (result2 === null) {
              result2 = parse_EOF();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse__() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_WhiteSpace();
        if (result1 === null) {
          result1 = parse_MultiLineCommentNoLineTerminator();
          if (result1 === null) {
            result1 = parse_SingleLineComment();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_WhiteSpace();
          if (result1 === null) {
            result1 = parse_MultiLineCommentNoLineTerminator();
            if (result1 === null) {
              result1 = parse_SingleLineComment();
            }
          }
        }
        return result0;
      }
      
      function parse___() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_WhiteSpace();
        if (result1 === null) {
          result1 = parse_LineTerminatorSequence();
          if (result1 === null) {
            result1 = parse_Comment();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_WhiteSpace();
          if (result1 === null) {
            result1 = parse_LineTerminatorSequence();
            if (result1 === null) {
              result1 = parse_Comment();
            }
          }
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
        var p, parser, flatten, _varsCache, _measuresCache; 
      
        p = parser = this;
      
        p.commands = [];  
      
        p.cs = [];
        p.addC = function (c) {
          p.commands.push(c);
        };
        
        p.$s = [];
        p.add$ = function ($) {
          if (p.$s.indexOf($) === -1) {p.$s.push($);}
          return $;
        }
      
        _varsCache = [];
        p.vars = [];
        p.addVar = function (ast,id) {
          if (_varsCache.indexOf(id) === -1) {
            _varsCache.push(id);
            p.commands.push(ast);
          }
          return ast;
        }
        
        _measuresCache = [];
        p.measures = [];
        p.processMeasure = function (ast) {
          var _id;
          _id = ast.toString(); // assuming stringified ast arrays CAN be used for cache lookup
          if (_measuresCache.indexOf(_id) === -1) {
            _measuresCache.push(_id);
            p.measures.push(ast);
          }
          return ast;
        }
      
        p.getResults = function () {
          return {
            "selectors": p.$s,
            "commands": p.commands
            //"measures": p.measures,
            //"vars": p.vars,
            //"constraints": p.cs      
          }
        }
        
        p.toString = function (x) {
          if (typeof x === "string") {return x}
          if (x instanceof Array) {return x.join("")}
          return ""
        }
      
        p.error = function (m,l,c) {
          if (!!l && !!c) {m = m+ " {line:" + l + ", col:" + c + "}"} 
          console.error(m);
          return m;
        }
      
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();
});
require.register("the-gss-vfl-compiler/lib/vfl-compiler.js", function(exports, require, module){
module.exports = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "start": parse_start,
        "debug": parse_debug,
        "Statement": parse_Statement,
        "VFLStatement": parse_VFLStatement,
        "VFLPluralStatement": parse_VFLPluralStatement,
        "Dimension": parse_Dimension,
        "Options": parse_Options,
        "Option": parse_Option,
        "OpionValueChars": parse_OpionValueChars,
        "Chain": parse_Chain,
        "ChainPredicate": parse_ChainPredicate,
        "ChainPredicateItems": parse_ChainPredicateItems,
        "ChainPredicateItem": parse_ChainPredicateItem,
        "ChainPredVal": parse_ChainPredVal,
        "View": parse_View,
        "Predicate": parse_Predicate,
        "PredExpression": parse_PredExpression,
        "PredEq": parse_PredEq,
        "PredOp": parse_PredOp,
        "PredView": parse_PredView,
        "PredLiteral": parse_PredLiteral,
        "PredVariable": parse_PredVariable,
        "PredViewVariable": parse_PredViewVariable,
        "PredSeperator": parse_PredSeperator,
        "Connection": parse_Connection,
        "GapChars": parse_GapChars,
        "StrengthAndWeight": parse_StrengthAndWeight,
        "Strength": parse_Strength,
        "NameChars": parse_NameChars,
        "NameCharsWithSpace": parse_NameCharsWithSpace,
        "Literal": parse_Literal,
        "Number": parse_Number,
        "Integer": parse_Integer,
        "Real": parse_Real,
        "SignedInteger": parse_SignedInteger,
        "SourceCharacter": parse_SourceCharacter,
        "WhiteSpace": parse_WhiteSpace,
        "LineTerminator": parse_LineTerminator,
        "LineTerminatorSequence": parse_LineTerminatorSequence,
        "EOS": parse_EOS,
        "EOF": parse_EOF,
        "Comment": parse_Comment,
        "MultiLineComment": parse_MultiLineComment,
        "MultiLineCommentNoLineTerminator": parse_MultiLineCommentNoLineTerminator,
        "SingleLineComment": parse_SingleLineComment,
        "_": parse__,
        "__": parse___
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "start";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_start() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse___();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_Statement();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_Statement();
          }
          if (result1 !== null) {
            result2 = parse___();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return parser.getResults(); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_debug() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse___();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_Statement();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_Statement();
          }
          if (result1 !== null) {
            result2 = parse___();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, vfl) { return parser.getResults().concat(vfl); })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Statement() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_VFLStatement();
        if (result0 !== null) {
          result1 = parse_EOS();
          if (result1 !== null) {
            result2 = parse___();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, exp) { return exp; })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_VFLStatement() {
        var result0, result1, result2, result3, result4, result5, result6, result7;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_Dimension();
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result2 = parse_View();
            if (result2 !== null) {
              result3 = [];
              pos2 = pos;
              result4 = parse___();
              if (result4 !== null) {
                result5 = parse_Connection();
                result5 = result5 !== null ? result5 : "";
                if (result5 !== null) {
                  result6 = parse___();
                  if (result6 !== null) {
                    result7 = parse_View();
                    if (result7 !== null) {
                      result4 = [result4, result5, result6, result7];
                    } else {
                      result4 = null;
                      pos = pos2;
                    }
                  } else {
                    result4 = null;
                    pos = pos2;
                  }
                } else {
                  result4 = null;
                  pos = pos2;
                }
              } else {
                result4 = null;
                pos = pos2;
              }
              while (result4 !== null) {
                result3.push(result4);
                pos2 = pos;
                result4 = parse___();
                if (result4 !== null) {
                  result5 = parse_Connection();
                  result5 = result5 !== null ? result5 : "";
                  if (result5 !== null) {
                    result6 = parse___();
                    if (result6 !== null) {
                      result7 = parse_View();
                      if (result7 !== null) {
                        result4 = [result4, result5, result6, result7];
                      } else {
                        result4 = null;
                        pos = pos2;
                      }
                    } else {
                      result4 = null;
                      pos = pos2;
                    }
                  } else {
                    result4 = null;
                    pos = pos2;
                  }
                } else {
                  result4 = null;
                  pos = pos2;
                }
              }
              if (result3 !== null) {
                result4 = parse___();
                if (result4 !== null) {
                  result5 = parse_Options();
                  result5 = result5 !== null ? result5 : "";
                  if (result5 !== null) {
                    result6 = parse___();
                    if (result6 !== null) {
                      result7 = parse_StrengthAndWeight();
                      result7 = result7 !== null ? result7 : "";
                      if (result7 !== null) {
                        result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, d, head, tail, o, s) {
              var connection, view2, result, ccss, headView, chainedViews;      
              result = head;      
              headView = head.view;
              chainedViews = [];      
              if (headView !== "|") {chainedViews.push(headView);}
              parser.addPreds(headView,head.preds,d);      
              for (var i = 0; i < tail.length; i++) {        
                connection = tail[i][1];
                view2 = tail[i][3].view;
                if (view2 !== "|") {chainedViews.push(view2);}
                parser.addPreds(view2,tail[i][3].preds,d);
                result = [
                  //"c",
                  connection,
                  result,
                  view2
                ];
                ccss = parser.getLeftVar(headView, d, o) + " " + parser.getConnectionString(connection, d, o) + " " + parser.getRightVar(view2, d, o) + " " + s;
                parser.addC(
                  ccss.trim()
                );
                headView = view2;
              }
              parser.addChains(chainedViews,o);
              return {'vfl':d, o:o};
            })(pos0, result0[0], result0[2], result0[3], result0[5], result0[7]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          result0 = parse_VFLPluralStatement();
        }
        return result0;
      }
      
      function parse_VFLPluralStatement() {
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_Dimension();
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result3 = parse_NameChars();
            if (result3 !== null) {
              result2 = [];
              while (result3 !== null) {
                result2.push(result3);
                result3 = parse_NameChars();
              }
            } else {
              result2 = null;
            }
            if (result2 !== null) {
              result3 = parse___();
              if (result3 !== null) {
                result4 = parse_Options();
                result4 = result4 !== null ? result4 : "";
                if (result4 !== null) {
                  result5 = parse___();
                  if (result5 !== null) {
                    result6 = parse_StrengthAndWeight();
                    result6 = result6 !== null ? result6 : "";
                    if (result6 !== null) {
                      result0 = [result0, result1, result2, result3, result4, result5, result6];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, d, selector, o, s) {
           var ccss = "@chain ";
           selector = selector.join("").trim();   
           ccss += selector + " ";
           ccss += p.leftVarNames[d] + "(";
           if (!o) {o = {};}
           if (o.gap) {
             ccss += "+" + o.gap;
           }
           ccss += ")" + p.rightVarNames[d];
           if (o.chains) {
             o.chains.forEach( function (chain) {
                ccss += " " + chain[0] + "("; 
                if (chain[1].raw) {
                  ccss += chain[1].raw;
                }
                ccss += ")";
               });
           }
           if (s) {
             ccss += " " + s;
           }
           parser.addC(ccss);
           return {vfl:d,o:o}
         })(pos0, result0[0], result0[2], result0[4], result0[6]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Dimension() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 11) === "@horizontal") {
          result0 = "@horizontal";
          pos += 11;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"@horizontal\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 16) === "@-gss-horizontal") {
            result0 = "@-gss-horizontal";
            pos += 16;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"@-gss-horizontal\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 7) === "@-gss-h") {
              result0 = "@-gss-h";
              pos += 7;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"@-gss-h\"");
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {return 0;})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.substr(pos, 9) === "@vertical") {
            result0 = "@vertical";
            pos += 9;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"@vertical\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 14) === "@-gss-vertical") {
              result0 = "@-gss-vertical";
              pos += 14;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"@-gss-vertical\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 7) === "@-gss-v") {
                result0 = "@-gss-v";
                pos += 7;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"@-gss-v\"");
                }
              }
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) {return 1;})(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_Options() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_Option();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_Option();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, os) {
            var obj = {};
            obj.chains = [];
            for (var i = 0; i < os.length; i++) {          
              // proccess chains
              if (!!os[i].chain) {
                obj.chains.push(os[i].chain);
              }
              // or just add option
              else {
                obj[os[i].key] = os[i].value;
              }            
            }
            return obj;
          })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Option() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse___();
        if (result0 !== null) {
          result1 = parse_Chain();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, chain) { return chain; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse___();
          if (result0 !== null) {
            result2 = parse_NameChars();
            if (result2 !== null) {
              result1 = [];
              while (result2 !== null) {
                result1.push(result2);
                result2 = parse_NameChars();
              }
            } else {
              result1 = null;
            }
            if (result1 !== null) {
              if (input.charCodeAt(pos) === 40) {
                result2 = "(";
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"(\"");
                }
              }
              if (result2 !== null) {
                result4 = parse_OpionValueChars();
                if (result4 !== null) {
                  result3 = [];
                  while (result4 !== null) {
                    result3.push(result4);
                    result4 = parse_OpionValueChars();
                  }
                } else {
                  result3 = null;
                }
                if (result3 !== null) {
                  if (input.charCodeAt(pos) === 41) {
                    result4 = ")";
                    pos++;
                  } else {
                    result4 = null;
                    if (reportFailures === 0) {
                      matchFailed("\")\"");
                    }
                  }
                  if (result4 !== null) {
                    result0 = [result0, result1, result2, result3, result4];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, key, value) {return {key:key.join(''), value:value.join('')};})(pos0, result0[1], result0[3]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_OpionValueChars() {
        var result0;
        
        if (/^[^>=<!)]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[^>=<!)]");
          }
        }
        return result0;
      }
      
      function parse_Chain() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 6) === "chain-") {
          result0 = "chain-";
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"chain-\"");
          }
        }
        if (result0 !== null) {
          result2 = parse_NameChars();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_NameChars();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_ChainPredicate();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, prop, preds) { return {'chain':[prop.join(""),preds]};})(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("Chain");
        }
        return result0;
      }
      
      function parse_ChainPredicate() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 40) {
          result0 = "(";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"(\"");
          }
        }
        if (result0 !== null) {
          result2 = parse_ChainPredicateItems();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_ChainPredicateItems();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 41) {
              result2 = ")";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\")\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, items) {
            items.raw = "";
            items.forEach( function (item){
              items.raw += item.raw;
            });
            return items;
          })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.substr(pos, 2) === "()") {
            result0 = "()";
            pos += 2;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"()\"");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) {return {raw:""};})(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_ChainPredicateItems() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_ChainPredicateItem();
        if (result0 !== null) {
          result1 = parse__();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 44) {
              result2 = ",";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\",\"");
              }
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, item) {
            item.raw = item.headEq + item.value + item.tailEq + item.s;
            return item;
          })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ChainPredicateItem() {
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_PredEq();
        if (result0 !== null) {
          result1 = parse__();
          if (result1 !== null) {
            result2 = parse_ChainPredVal();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse__();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result4 = parse_PredEq();
                result4 = result4 !== null ? result4 : "";
                if (result4 !== null) {
                  result5 = parse__();
                  result5 = result5 !== null ? result5 : "";
                  if (result5 !== null) {
                    result6 = parse_StrengthAndWeight();
                    result6 = result6 !== null ? result6 : "";
                    if (result6 !== null) {
                      result0 = [result0, result1, result2, result3, result4, result5, result6];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, headEq, value, tailEq, s) {
              return {headEq:p.join(headEq),value:p.join(value),tailEq:p.join(tailEq),s:s};})(pos0, result0[0], result0[2], result0[4], result0[6]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_PredEq();
          result0 = result0 !== null ? result0 : "";
          if (result0 !== null) {
            result1 = parse__();
            result1 = result1 !== null ? result1 : "";
            if (result1 !== null) {
              result2 = parse_ChainPredVal();
              if (result2 !== null) {
                result3 = parse__();
                result3 = result3 !== null ? result3 : "";
                if (result3 !== null) {
                  result4 = parse_PredEq();
                  result4 = result4 !== null ? result4 : "";
                  if (result4 !== null) {
                    result5 = parse__();
                    result5 = result5 !== null ? result5 : "";
                    if (result5 !== null) {
                      result6 = parse_StrengthAndWeight();
                      result6 = result6 !== null ? result6 : "";
                      if (result6 !== null) {
                        result0 = [result0, result1, result2, result3, result4, result5, result6];
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, headEq, value, tailEq, s) {
                return {headEq:p.join(headEq),value:p.join(value),tailEq:p.join(tailEq),s:s};})(pos0, result0[0], result0[2], result0[4], result0[6]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            result0 = parse_PredEq();
            result0 = result0 !== null ? result0 : "";
            if (result0 !== null) {
              result1 = parse__();
              result1 = result1 !== null ? result1 : "";
              if (result1 !== null) {
                result2 = parse_ChainPredVal();
                result2 = result2 !== null ? result2 : "";
                if (result2 !== null) {
                  result3 = parse__();
                  result3 = result3 !== null ? result3 : "";
                  if (result3 !== null) {
                    result4 = parse_PredEq();
                    result4 = result4 !== null ? result4 : "";
                    if (result4 !== null) {
                      result5 = parse__();
                      result5 = result5 !== null ? result5 : "";
                      if (result5 !== null) {
                        result6 = parse_StrengthAndWeight();
                        if (result6 !== null) {
                          result0 = [result0, result1, result2, result3, result4, result5, result6];
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, headEq, value, tailEq, s) {
                  return {headEq:p.join(headEq),value:p.join(value),tailEq:p.join(tailEq),s:s};})(pos0, result0[0], result0[2], result0[4], result0[6]);
            }
            if (result0 === null) {
              pos = pos0;
            }
          }
        }
        return result0;
      }
      
      function parse_ChainPredVal() {
        var result0, result1;
        
        if (/^[^>=<!) ]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[^>=<!) ]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[^>=<!) ]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[^>=<!) ]");
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_View() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 !== null) {
          result2 = parse_NameChars();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_NameChars();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_Predicate();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 93) {
                result3 = "]";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"]\"");
                }
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, name, p) {return {view:name.join(""),preds:p};})(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.charCodeAt(pos) === 124) {
            result0 = "|";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"|\"");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) {return {view:"|"};})(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_Predicate() {
        var result0, result1, result2, result3, result4, result5, result6, result7;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 40) {
          result0 = "(";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"(\"");
          }
        }
        if (result0 !== null) {
          pos2 = pos;
          result2 = parse_PredEq();
          if (result2 !== null) {
            result3 = parse_PredExpression();
            if (result3 !== null) {
              result4 = parse_StrengthAndWeight();
              result4 = result4 !== null ? result4 : "";
              if (result4 !== null) {
                result5 = parse__();
                result5 = result5 !== null ? result5 : "";
                if (result5 !== null) {
                  result6 = parse_PredSeperator();
                  if (result6 !== null) {
                    result7 = parse__();
                    result7 = result7 !== null ? result7 : "";
                    if (result7 !== null) {
                      result2 = [result2, result3, result4, result5, result6, result7];
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  } else {
                    result2 = null;
                    pos = pos2;
                  }
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              pos2 = pos;
              result2 = parse_PredEq();
              if (result2 !== null) {
                result3 = parse_PredExpression();
                if (result3 !== null) {
                  result4 = parse_StrengthAndWeight();
                  result4 = result4 !== null ? result4 : "";
                  if (result4 !== null) {
                    result5 = parse__();
                    result5 = result5 !== null ? result5 : "";
                    if (result5 !== null) {
                      result6 = parse_PredSeperator();
                      if (result6 !== null) {
                        result7 = parse__();
                        result7 = result7 !== null ? result7 : "";
                        if (result7 !== null) {
                          result2 = [result2, result3, result4, result5, result6, result7];
                        } else {
                          result2 = null;
                          pos = pos2;
                        }
                      } else {
                        result2 = null;
                        pos = pos2;
                      }
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  } else {
                    result2 = null;
                    pos = pos2;
                  }
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 41) {
              result2 = ")";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\")\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, preds) {return preds;})(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_PredExpression() {
        var result0, result1;
        
        result1 = parse_PredOp();
        if (result1 === null) {
          result1 = parse_PredLiteral();
          if (result1 === null) {
            result1 = parse_PredVariable();
            if (result1 === null) {
              result1 = parse_PredViewVariable();
              if (result1 === null) {
                result1 = parse_PredView();
              }
            }
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_PredOp();
            if (result1 === null) {
              result1 = parse_PredLiteral();
              if (result1 === null) {
                result1 = parse_PredVariable();
                if (result1 === null) {
                  result1 = parse_PredViewVariable();
                  if (result1 === null) {
                    result1 = parse_PredView();
                  }
                }
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_PredEq() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse__();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          if (input.substr(pos, 2) === "==") {
            result1 = "==";
            pos += 2;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"==\"");
            }
          }
          if (result1 === null) {
            if (input.substr(pos, 2) === "<=") {
              result1 = "<=";
              pos += 2;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"<=\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 60) {
                result1 = "<";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"<\"");
                }
              }
              if (result1 === null) {
                if (input.substr(pos, 2) === ">=") {
                  result1 = ">=";
                  pos += 2;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\">=\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 62) {
                    result1 = ">";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\">\"");
                    }
                  }
                  if (result1 === null) {
                    pos2 = pos;
                    if (input.substr(pos, 2) === "=<") {
                      result1 = "=<";
                      pos += 2;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"=<\"");
                      }
                    }
                    if (result1 !== null) {
                      result1 = (function(offset) {return "<=";})(pos2);
                    }
                    if (result1 === null) {
                      pos = pos2;
                    }
                    if (result1 === null) {
                      pos2 = pos;
                      if (input.substr(pos, 2) === "=>") {
                        result1 = "=>";
                        pos += 2;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"=>\"");
                        }
                      }
                      if (result1 !== null) {
                        result1 = (function(offset) {return ">=";})(pos2);
                      }
                      if (result1 === null) {
                        pos = pos2;
                      }
                    }
                  }
                }
              }
            }
          }
          if (result1 !== null) {
            result2 = parse__();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, eq) {return eq;})(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_PredOp() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (/^[+\-\/*]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[+\\-\\/*]");
          }
        }
        if (result0 !== null) {
          result1 = parse__();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, op) {return op;})(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_PredView() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result1 = parse_NameChars();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_NameChars();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = parse__();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, name) {return ["view",name.join("")];})(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_PredLiteral() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result1 = parse_Number();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_Number();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = parse__();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, n) {return n.join("");})(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_PredVariable() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 !== null) {
          result2 = parse_NameChars();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_NameChars();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 93) {
              result2 = "]";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"]\"");
              }
            }
            if (result2 !== null) {
              result3 = parse__();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, name) {return "[" + name.join("") + "]";})(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_PredViewVariable() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result1 = parse_NameChars();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_NameChars();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 91) {
            result1 = "[";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"[\"");
            }
          }
          if (result1 !== null) {
            result3 = parse_NameChars();
            if (result3 !== null) {
              result2 = [];
              while (result3 !== null) {
                result2.push(result3);
                result3 = parse_NameChars();
              }
            } else {
              result2 = null;
            }
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 93) {
                result3 = "]";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"]\"");
                }
              }
              if (result3 !== null) {
                result4 = parse__();
                result4 = result4 !== null ? result4 : "";
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, view, prop) {return view.join("") + "[" + prop.join("") + "]";})(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_PredSeperator() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 44) {
          result0 = ",";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\",\"");
          }
        }
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result0 = (function(offset) {return "";})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Connection() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 45) {
          result0 = "-";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"-\"");
          }
        }
        if (result0 !== null) {
          result2 = parse_GapChars();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_GapChars();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 45) {
              result2 = "-";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"-\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, gap) {return {op:"==",gap:gap.join("")};})(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.charCodeAt(pos) === 45) {
            result0 = "-";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) {return {op:"==",gap:"__STANDARD__"};})(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            if (input.charCodeAt(pos) === 126) {
              result0 = "~";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"~\"");
              }
            }
            if (result0 !== null) {
              result2 = parse_GapChars();
              if (result2 !== null) {
                result1 = [];
                while (result2 !== null) {
                  result1.push(result2);
                  result2 = parse_GapChars();
                }
              } else {
                result1 = null;
              }
              if (result1 !== null) {
                if (input.charCodeAt(pos) === 126) {
                  result2 = "~";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"~\"");
                  }
                }
                if (result2 !== null) {
                  result0 = [result0, result1, result2];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, gap) {return {op:"<=",gap:gap.join("")};})(pos0, result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              pos1 = pos;
              if (input.charCodeAt(pos) === 126) {
                result0 = "~";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"~\"");
                }
              }
              if (result0 !== null) {
                if (input.charCodeAt(pos) === 45) {
                  result1 = "-";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"-\"");
                  }
                }
                if (result1 !== null) {
                  if (input.charCodeAt(pos) === 126) {
                    result2 = "~";
                    pos++;
                  } else {
                    result2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"~\"");
                    }
                  }
                  if (result2 !== null) {
                    result0 = [result0, result1, result2];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 !== null) {
                result0 = (function(offset) {return {op:"<=",gap:"__STANDARD__"};})(pos0);
              }
              if (result0 === null) {
                pos = pos0;
              }
              if (result0 === null) {
                pos0 = pos;
                if (input.charCodeAt(pos) === 126) {
                  result0 = "~";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"~\"");
                  }
                }
                if (result0 !== null) {
                  result0 = (function(offset) {return {op:"<="};})(pos0);
                }
                if (result0 === null) {
                  pos = pos0;
                }
                if (result0 === null) {
                  pos0 = pos;
                  result0 = "";
                  if (result0 !== null) {
                    result0 = (function(offset) {return {op:"=="};})(pos0);
                  }
                  if (result0 === null) {
                    pos = pos0;
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_GapChars() {
        var result0;
        
        if (/^[a-zA-Z0-9#._$]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9#._$]");
          }
        }
        return result0;
      }
      
      function parse_StrengthAndWeight() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 33) {
          result0 = "!";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"!\"");
          }
        }
        if (result0 !== null) {
          if (/^[a-zA-Z]/.test(input.charAt(pos))) {
            result2 = input.charAt(pos);
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[a-zA-Z]");
            }
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              if (/^[a-zA-Z]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[a-zA-Z]");
                }
              }
            }
          } else {
            result1 = null;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            if (/^[0-9]/.test(input.charAt(pos))) {
              result3 = input.charAt(pos);
              pos++;
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
            if (result3 !== null) {
              result2 = [];
              while (result3 !== null) {
                result2.push(result3);
                if (/^[0-9]/.test(input.charAt(pos))) {
                  result3 = input.charAt(pos);
                  pos++;
                } else {
                  result3 = null;
                  if (reportFailures === 0) {
                    matchFailed("[0-9]");
                  }
                }
              }
            } else {
              result2 = null;
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, s, w) {  return "!" + p.join(s) + p.join(w);})(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 33) {
            result0 = "!";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"!\"");
            }
          }
          if (result0 !== null) {
            if (input.length > pos) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("any character");
              }
            }
            result1 = result1 !== null ? result1 : "";
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset) {return parser.error("Invalid Strength or Weight",line,column);})(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_Strength() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 7) === "require") {
          result0 = "require";
          pos += 7;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"require\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 7) === "REQUIRE") {
            result0 = "REQUIRE";
            pos += 7;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"REQUIRE\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 7) === "Require") {
              result0 = "Require";
              pos += 7;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"Require\"");
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "require";})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.substr(pos, 6) === "strong") {
            result0 = "strong";
            pos += 6;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"strong\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 6) === "STRONG") {
              result0 = "STRONG";
              pos += 6;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"STRONG\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 6) === "Strong") {
                result0 = "Strong";
                pos += 6;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"Strong\"");
                }
              }
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) {return "strong";})(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            if (input.substr(pos, 6) === "medium") {
              result0 = "medium";
              pos += 6;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"medium\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 6) === "MEDIUM") {
                result0 = "MEDIUM";
                pos += 6;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"MEDIUM\"");
                }
              }
              if (result0 === null) {
                if (input.substr(pos, 6) === "Medium") {
                  result0 = "Medium";
                  pos += 6;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"Medium\"");
                  }
                }
              }
            }
            if (result0 !== null) {
              result0 = (function(offset) {return "medium";})(pos0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              if (input.substr(pos, 4) === "weak") {
                result0 = "weak";
                pos += 4;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"weak\"");
                }
              }
              if (result0 === null) {
                if (input.substr(pos, 4) === "WEAK") {
                  result0 = "WEAK";
                  pos += 4;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"WEAK\"");
                  }
                }
                if (result0 === null) {
                  if (input.substr(pos, 4) === "Weak") {
                    result0 = "Weak";
                    pos += 4;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"Weak\"");
                    }
                  }
                }
              }
              if (result0 !== null) {
                result0 = (function(offset) {return "weak";})(pos0);
              }
              if (result0 === null) {
                pos = pos0;
              }
              if (result0 === null) {
                pos0 = pos;
                if (input.substr(pos, 8) === "required") {
                  result0 = "required";
                  pos += 8;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"required\"");
                  }
                }
                if (result0 === null) {
                  if (input.substr(pos, 8) === "REQUIRED") {
                    result0 = "REQUIRED";
                    pos += 8;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"REQUIRED\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.substr(pos, 8) === "Required") {
                      result0 = "Required";
                      pos += 8;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"Required\"");
                      }
                    }
                  }
                }
                if (result0 !== null) {
                  result0 = (function(offset) {return "require";})(pos0);
                }
                if (result0 === null) {
                  pos = pos0;
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_NameChars() {
        var result0;
        
        if (/^[a-zA-Z0-9#.\-_$:]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9#.\\-_$:]");
          }
        }
        return result0;
      }
      
      function parse_NameCharsWithSpace() {
        var result0;
        
        result0 = parse_NameChars();
        if (result0 === null) {
          if (input.charCodeAt(pos) === 32) {
            result0 = " ";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\" \"");
            }
          }
        }
        return result0;
      }
      
      function parse_Literal() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_Number();
        if (result0 !== null) {
          result0 = (function(offset, val) {
            return [ "number",
              val
            ];
          })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Number() {
        var result0;
        
        result0 = parse_Real();
        if (result0 === null) {
          result0 = parse_Integer();
        }
        return result0;
      }
      
      function parse_Integer() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (/^[0-9]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[0-9]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, digits) {
            return parseInt(digits.join(""), 10);
          })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Real() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_Integer();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 46) {
            result1 = ".";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_Integer();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, digits) {
            return parseFloat(digits.join(""));
          })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SignedInteger() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (/^[\-+]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\-+]");
          }
        }
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          if (/^[0-9]/.test(input.charAt(pos))) {
            result2 = input.charAt(pos);
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[0-9]");
            }
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              if (/^[0-9]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SourceCharacter() {
        var result0;
        
        if (input.length > pos) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("any character");
          }
        }
        return result0;
      }
      
      function parse_WhiteSpace() {
        var result0;
        
        reportFailures++;
        if (/^[\t\x0B\f \xA0\uFEFF]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\t\\x0B\\f \\xA0\\uFEFF]");
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("whitespace");
        }
        return result0;
      }
      
      function parse_LineTerminator() {
        var result0;
        
        if (/^[\n\r\u2028\u2029]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\n\\r\\u2028\\u2029]");
          }
        }
        return result0;
      }
      
      function parse_LineTerminatorSequence() {
        var result0;
        
        reportFailures++;
        if (input.charCodeAt(pos) === 10) {
          result0 = "\n";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\n\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 2) === "\r\n") {
            result0 = "\r\n";
            pos += 2;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\r\\n\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 13) {
              result0 = "\r";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\r\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 8232) {
                result0 = "\u2028";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\u2028\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 8233) {
                  result0 = "\u2029";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\u2029\"");
                  }
                }
              }
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("end of line");
        }
        return result0;
      }
      
      function parse_EOS() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = parse___();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 59) {
            result1 = ";";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\";\"");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          result0 = parse__();
          if (result0 !== null) {
            result1 = parse_LineTerminatorSequence();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            result0 = parse___();
            if (result0 !== null) {
              result1 = parse_EOF();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          }
        }
        return result0;
      }
      
      function parse_EOF() {
        var result0;
        var pos0;
        
        pos0 = pos;
        reportFailures++;
        if (input.length > pos) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("any character");
          }
        }
        reportFailures--;
        if (result0 === null) {
          result0 = "";
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Comment() {
        var result0;
        
        reportFailures++;
        result0 = parse_MultiLineComment();
        if (result0 === null) {
          result0 = parse_SingleLineComment();
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("comment");
        }
        return result0;
      }
      
      function parse_MultiLineComment() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "/*") {
          result0 = "/*";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/*\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          pos2 = pos;
          reportFailures++;
          if (input.substr(pos, 2) === "*/") {
            result2 = "*/";
            pos += 2;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\"*/\"");
            }
          }
          reportFailures--;
          if (result2 === null) {
            result2 = "";
          } else {
            result2 = null;
            pos = pos2;
          }
          if (result2 !== null) {
            result3 = parse_SourceCharacter();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            reportFailures--;
            if (result2 === null) {
              result2 = "";
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              result3 = parse_SourceCharacter();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_MultiLineCommentNoLineTerminator() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "/*") {
          result0 = "/*";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/*\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          pos2 = pos;
          reportFailures++;
          if (input.substr(pos, 2) === "*/") {
            result2 = "*/";
            pos += 2;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\"*/\"");
            }
          }
          if (result2 === null) {
            result2 = parse_LineTerminator();
          }
          reportFailures--;
          if (result2 === null) {
            result2 = "";
          } else {
            result2 = null;
            pos = pos2;
          }
          if (result2 !== null) {
            result3 = parse_SourceCharacter();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            if (result2 === null) {
              result2 = parse_LineTerminator();
            }
            reportFailures--;
            if (result2 === null) {
              result2 = "";
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              result3 = parse_SourceCharacter();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SingleLineComment() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "//") {
          result0 = "//";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"//\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          pos2 = pos;
          reportFailures++;
          result2 = parse_LineTerminator();
          reportFailures--;
          if (result2 === null) {
            result2 = "";
          } else {
            result2 = null;
            pos = pos2;
          }
          if (result2 !== null) {
            result3 = parse_SourceCharacter();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            result2 = parse_LineTerminator();
            reportFailures--;
            if (result2 === null) {
              result2 = "";
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              result3 = parse_SourceCharacter();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result2 = parse_LineTerminator();
            if (result2 === null) {
              result2 = parse_EOF();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse__() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_WhiteSpace();
        if (result1 === null) {
          result1 = parse_MultiLineCommentNoLineTerminator();
          if (result1 === null) {
            result1 = parse_SingleLineComment();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_WhiteSpace();
          if (result1 === null) {
            result1 = parse_MultiLineCommentNoLineTerminator();
            if (result1 === null) {
              result1 = parse_SingleLineComment();
            }
          }
        }
        return result0;
      }
      
      function parse___() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_WhiteSpace();
        if (result1 === null) {
          result1 = parse_LineTerminatorSequence();
          if (result1 === null) {
            result1 = parse_Comment();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_WhiteSpace();
          if (result1 === null) {
            result1 = parse_LineTerminatorSequence();
            if (result1 === null) {
              result1 = parse_Comment();
            }
          }
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
        var p, parser, cs, leftVarNames, superLeftVarNames, rightVarNames, superRightVarNames, standardGapNames, getSuperViewName, getGapString, sizeVarNames; 
      
        p = parser = this;
      
        sizeVarNames = p.sizeVarNames = ["width", "height"];
        leftVarNames = p.leftVarNames = ["right", "bottom"];
        superLeftVarNames = p.superLeftVarNames = ["left", "top"];
        rightVarNames = p.rightVarNames = ["left", "top"];
        superRightVarNames = p.superRightVarNames = ["right", "bottom"];
      
        cs = parser.cs = [];
      
        parser.addC = function (c) {
          cs.push(c);
        };
      
        parser.addPreds = function (view,preds,d) {
          var pred, ccss, eq, exps, exp;
          if (preds) {      
            for (var i = 0; i < preds.length; i++) {
              pred = preds[i];
              eq = pred[0];
              ccss = view + "[" + sizeVarNames[d] + "] " + eq + " ";
              exps = pred[1];
              for (var j = 0; j < exps.length; j++) {       
                exp = exps[j];
                if (exp[0] === "view") {
                  exp = exp[1] + "[" + sizeVarNames[d] + "]";
                }
                ccss += exp + " ";
              }
              ccss += pred[2]; // strength & weight
              cs.push(ccss.trim());
            }
          }
        };
      
        parser.defaultChainObject = {
          headEq: "==",
          value: "",
          tailEq: "",
          s: ""
        };
      
        parser.chainTailEqMap = {
          "<=": ">=",
          ">=": "<=",
          "==": "==",
          "<" : ">",
          ">" : "<" 
        };
      
        parser.addChains = function (views,o) {
          var chains, chain, prop, preds, connector, ccss, view, pred;
          chains = o.chains;
          if (chains) {            
            for (var i = 0; i < chains.length; i++) {
              chain = chains[i];
              prop = chain[0];
              preds = chain[1];
              if (preds === "") {
                preds = [parser.defaultChainObject];
              } // load default chain predicate
              for (var j = 0; j < preds.length; j++) {
                pred = preds[j];
                ccss = "";
                for (var k = 0; k < views.length - 1; k++) {
                  view = views[k];  
                  if (pred.headEq === "") {
                    pred.headEq = parser.defaultChainObject.headEq;
                  }
                  ccss += " " + view + "[" + prop + "] " + pred.headEq;
                  if (pred.value !== "") {
                    ccss += " " + pred.value;
                    if (views.length > 1) {
                      if (pred.tailEq === "") {
                        pred.tailEq = parser.chainTailEqMap[pred.headEq];
                      }
                      ccss += " " + pred.tailEq;
                    }
                    else {
                      ccss += " " + pred.s;
                      cs.push(ccss.trim());
                    }
                  }
                }
                if (views.length > 1) {
                   ccss += " " + views[views.length-1] + "[" + prop + "]" + " " + pred.s;
                   cs.push(ccss.trim());
                }
              }
            }
          } 
        };
      
        getSuperViewName = function (o) {
          if (o.in === undefined) {
            return "::this";
          }
          return o.in;
        };
      
        parser.getLeftVar = function (view, dimension, o) {
          var varName;
          if (view === "|") {
            view = getSuperViewName(o);
            varName = superLeftVarNames[dimension];
          }
          else {
            varName = leftVarNames[dimension];
          }
          return view + "[" + varName + "]";
        };
        
        parser.getRightVar = function (view, dimension, o) {
          var varName;
          
          if (view === "|") {
            view = getSuperViewName(o);
            varName = superRightVarNames[dimension];
          }
          else {
            varName = rightVarNames[dimension];
            
          }
          return view + "[" + varName + "]";
        };
        
        standardGapNames = ["[hgap]", "[vgap]"];
        
        getGapString = function (g,d,o) {
          if (g === undefined) {return "";}
          if (g === "__STANDARD__") {
            // use gap if given with `gap()`
            if (o.gap) {
              g = o.gap;
            // else use standard var
            } else {
              g = standardGapNames[d];
            }
          }
          return "+ " + g;
        };
      
        parser.getConnectionString = function (c, d, o) {
          
          return (getGapString(c.gap,d,o) + " " + c.op).trim();
        };
      
        parser.getResults = function () {
          return [
            ["ccss"].concat(this.cs)
          ];
        };
      
        parser.error = function (m,l,c) {
          if (!!l && !!c) {
            m = m + " {line:" + l + ", col:" + c + "}";
          }
          console.error(m);
          return m;
        };
      
        parser.join = function (a) {
          if (a.join){return a.join("");}
          return a;
        };
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();
});
require.register("the-gss-vfl-compiler/lib/compiler.js", function(exports, require, module){
var ccss = require('ccss-compiler');
var vfl = require('./vfl-compiler');

exports.parse = function (rules) {
  var results = {
    selectors: [],
    commands: []
  };
  var parsed = vfl.parse(rules);
  parsed.forEach(function (rule) {
    if (rule.shift() !== 'ccss') {
      throw new Error('CCSS rules expected');
    }
    var ccssRule = ccss.parse(rule.join(";\n"));
    results.selectors = results.selectors.concat(ccssRule.selectors);
    results.commands = results.commands.concat(ccssRule.commands);
    //results.constraints = results.constraints.concat(ccssRule.constraints);
  });
  return results;
};

});
require.register("the-gss-compiler/lib/gss-compiler.js", function(exports, require, module){
var preparser = require('gss-preparser');
var ccss = require('ccss-compiler');
var vfl = require('vfl-compiler');

var runCompiler = function (chunk) {
  switch (chunk[0]) {
    case 'ccss':
      return ccss.parse(chunk[1]);
    case 'vfl':
      return vfl.parse(chunk[1]);
    case 'gtl':
      return gtl.parse(chunk[1]);
  }
};

exports.compile = function (gss) {
  var chunks = preparser.parse(gss);
  var results = {
    css: ''
  };
  chunks.forEach(function (chunk) {
    if (chunk[0] === 'css') {
      results.css += chunk[1];
      return;
    }
    var rules = runCompiler(chunk);
    for (var part in rules) {
      if (!results[part]) {
        results[part] = [];
      }
      results[part] = results[part].concat(rules[part]);
    }
  });
  return results;
};

});
require.register("d4tocchini-customevent-polyfill/CustomEvent.js", function(exports, require, module){
var CustomEvent;

CustomEvent = function(event, params) {
  var evt;
  params = params || {
    bubbles: false,
    cancelable: false,
    detail: undefined
  };
  evt = document.createEvent("CustomEvent");
  evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
  return evt;
};

CustomEvent.prototype = window.Event.prototype;

window.CustomEvent = CustomEvent;

});
require.register("slightlyoff-cassowary.js/index.js", function(exports, require, module){
module.exports = require("./src/c.js");
require("./src/HashTable.js");
require("./src/HashSet.js");
require("./src/Error.js");
require("./src/SymbolicWeight.js");
require("./src/Strength.js");
require("./src/Variable.js");
require("./src/Point.js");
require("./src/Expression.js");
require("./src/Constraint.js");
require("./src/Constraint.js");
require("./src/EditInfo.js");
require("./src/Tableau.js");
require("./src/SimplexSolver.js");
require("./src/Timer.js");
require("./src/parser/parser.js");
require("./src/parser/api.js");

});
require.register("slightlyoff-cassowary.js/src/c.js", function(exports, require, module){
// Copyright (C) 1998-2000 Greg J. Badros
// Use of this source code is governed by
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Parts Copyright (C) 2011-2012, Alex Russell (slightlyoff@chromium.org)

(function(scope){
"use strict";

// For Safari 5.x. Go-go-gadget ridiculously long release cycle!
try {
  (function(){}).bind(scope);
} catch (e) {
  Object.defineProperty(Function.prototype, "bind", {
    value: function(scope) {
      var f = this;
      return function() { return f.apply(scope, arguments); }
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}

var inBrowser = (typeof scope["HTMLElement"] != "undefined");

var getTagName = function(proto) {
  var tn = null;
  while (proto && proto != Object.prototype) {
      if (proto.tagName) {
        tn = proto.tagName;
        break;
      }
    proto = proto.prototype;
  }
  return tn || "div";
};
var epsilon = 1e-8;

var  _t_map = {};
var walkForMethod = function(ctor, name) {
  if (!ctor || !name) return;

  // Check the class-side first, the look at the prototype, then walk up
  if (typeof ctor[name] == "function") {
    return ctor[name];
  }
  var p = ctor.prototype;
  if (p && typeof p[name] == "function") {
    return p[name];
  }
  if (p === Object.prototype ||
      p === Function.prototype) {
    return;
  }

  if (typeof ctor.__super__ == "function") {
    return walkForMethod(ctor.__super__, name);
  }
};

// Global
var c = scope.c = function() {
  if(c._api) {
    return c._api.apply(this, arguments);
  }
};

//
// Configuration
//
c.debug = false;
c.trace = false;
c.verbose = false;
c.traceAdded = false;
c.GC = false;

//
// Constants
//
c.GEQ = 1;
c.LEQ = 2;


//
// Utility methods
//
c.inherit = function(props) {
  var ctor = null;
  var parent = null;

  if (props["extends"]) {
    parent = props["extends"];
    delete props["extends"];
  }

  if (props["initialize"]) {
    ctor = props["initialize"];
    delete props["initialize"];
  }

  var realCtor = ctor || function() { };

  Object.defineProperty(realCtor, "__super__", {
    value: (parent) ? parent : Object,
    enumerable: false,
    configurable: true,
    writable: false,
  });

  if (props["_t"]) {
    _t_map[props["_t"]] = realCtor;
  }

  // FIXME(slightlyoff): would like to have class-side inheritance!
  // It's easy enough to do when we have __proto__, but we don't in IE 9/10.
  //   = (

  /*
  // NOTE: would happily do this except it's 2x slower. Boo!
  props.__proto__ = parent ? parent.prototype : Object.prototype;
  realCtor.prototype = props;
  */

  var rp = realCtor.prototype = Object.create(
    ((parent) ? parent.prototype : Object.prototype)
  );

  c.extend(rp, props);

  // If we're in a browser, we want to support "subclassing" HTML elements.
  // This needs some magic and we rely on a wrapped constructor hack to make
  // it happen.
  if (inBrowser) {
    if (parent && parent.prototype instanceof scope.HTMLElement) {
      var intermediateCtor = realCtor;
      var tn = getTagName(rp);
      var upgrade = function(el) {
        el.__proto__ = rp;
        intermediateCtor.apply(el, arguments);
        if (rp["created"]) { el.created(); }
        if (rp["decorate"]) { el.decorate(); }
        return el;
      };
      this.extend(rp, { upgrade: upgrade, });

      realCtor = function() {
        // We hack the constructor to always return an element with it's
        // prototype wired to ours. Boo.
        return upgrade(
          scope.document.createElement(tn)
        );
      }
      realCtor.prototype = rp;
      this.extend(realCtor, { ctor: intermediateCtor, }); // HACK!!!
    }
  }

  return realCtor;
};

c.own = function(obj, cb, context) {
  Object.getOwnPropertyNames(obj).forEach(cb, context||scope);
  return obj;
};

c.extend = function(obj, props) {
  c.own(props, function(x) {
    var pd = Object.getOwnPropertyDescriptor(props, x);
    try {
      if ( (typeof pd["get"] == "function") ||
           (typeof pd["set"] == "function") ) {
        Object.defineProperty(obj, x, pd);
      } else if (typeof pd["value"] == "function" ||x.charAt(0) === "_") {
        pd.writable = true;
        pd.configurable = true;
        pd.enumerable = false;
        Object.defineProperty(obj, x, pd);
      } else {
          obj[x] = props[x];
      }
    } catch(e) {
      // console.warn("c.extend assignment failed on property", x);
    }
  });
  return obj;
};

// FIXME: legacy API to be removed
c.traceprint = function(s /*String*/) { if (c.verbose) { console.log(s); } };
c.fnenterprint = function(s /*String*/) { console.log("* " + s); };
c.fnexitprint = function(s /*String*/) { console.log("- " + s); };

c.assert = function(f /*boolean*/, description /*String*/) {
  if (!f) {
    throw new c.InternalError("Assertion failed: " + description);
  }
};

c.plus = function(e1, e2) {
  if (!(e1 instanceof c.Expression)) {
    e1 = new c.Expression(e1);
  }
  if (!(e2 instanceof c.Expression)) {
    e2 = new c.Expression(e2);
  }
  return e1.plus(e2);
};

c.minus = function(e1, e2) {
  if (!(e1 instanceof c.Expression)) {
    e1 = new c.Expression(e1);
  }
  if (!(e2 instanceof c.Expression)) {
    e2 = new c.Expression(e2);
  }

  return e1.minus(e2);
};

c.times = function(e1, e2) {
  if (typeof e1 == "number" || e1 instanceof c.Variable) {
    e1 = new c.Expression(e1);
  }
  if (typeof e2 == "number" || e2 instanceof c.Variable) {
    e2 = new c.Expression(e2);
  }

  return e1.times(e2);
};

c.divide = function(e1 /*c.Expression*/, e2 /*c.Expression*/) {
  if (typeof e1 == "number" || e1 instanceof c.Variable) {
    e1 = new c.Expression(e1);
  }
  if (typeof e2 == "number" || e2 instanceof c.Variable) {
    e2 = new c.Expression(e2);
  }

  return e1.divide(e2);
};

c.approx = function(a /*double*/, b /*double*/) {
  if (a === b) { return true; }
  var av, bv;
  av = (a instanceof c.Variable) ? a.value : a;
  bv = (b instanceof c.Variable) ? b.value : b;
  if (av == 0) {
    return (Math.abs(bv) < epsilon);
  }
  if (bv == 0) {
    return (Math.abs(av) < epsilon);
  }
  return (Math.abs(av - bv) < Math.abs(av) * epsilon);
};

var count = 0;
c._inc = function() { return count++; };

c.parseJSON = function(str) {
  return JSON.parse(str, function(k, v) {
    if (typeof v != "object" || typeof v["_t"] != "string") {
      return v;
    }
    var type = v["_t"];
    var ctor = _t_map[type];
    if (type && ctor) {
      var fromJSON = walkForMethod(ctor, "fromJSON");
      if (fromJSON) {
        return fromJSON(v, ctor);
      }
    }
    return v;
  });
};

// For Node...not that I'm bitter. No no, not at all. Not me. Never...
if (typeof require == "function" &&
    typeof module != "undefined" &&
    typeof load == "undefined") {
  scope.exports = c;
}
// ...well, hardly ever.

})(this);

});
require.register("slightlyoff-cassowary.js/src/HashTable.js", function(exports, require, module){
/**
 * Copyright 2012 Alex Russell <slightlyoff@google.com>.
 *
 * Use of this source code is governed by http://www.apache.org/licenses/LICENSE-2.0
 *
 * This is an API compatible re-implementation of the subset of jshashtable
 * which Cassowary actually uses.
 *
 * Features removed:
 *
 *     - multiple values per key
 *     - error tollerent hashing of any variety
 *     - overly careful (or lazy) size counting, etc.
 *     - Crockford's "class" pattern. We use the system from c.js.
 *     - any attempt at back-compat with broken runtimes.
 *
 * APIs removed, mostly for lack of use in Cassowary:
 *
 *     - support for custom hashing and equality functions as keys to ctor
 *     - isEmpty() -> check for !ht.size()
 *     - putAll()
 *     - entries()
 *     - containsKey()
 *     - containsValue()
 *     - keys()
 *     - values()
 *
 * Additions:
 *
 *     - new "scope" parameter to each() and escapingEach()
 */

(function(c) {
"use strict";

var keyCode = function(key) {
  var kc = (!!key.hashCode) ? key.hashCode : key.toString();
  return kc;
};

var copyOwn = function(src, dest) {
  Object.keys(src).forEach(function(x) {
    dest[x] = src[x];
  });
};

if (false && typeof Map != "undefined") {

  c.HashTable = c.inherit({

    initialize: function() {
      this.size = 0;
      this._store = new Map();
      this._keys = [];
      // this.get = this._store.get.bind(this._store);
    },

    set: function(key, value) {
      this._store.set(key, value);
      if (this._keys.indexOf(key) == -1) {
        this.size++;
        // delete this._keys[this._keys.indexOf(key)];
        this._keys.push(key);
      } /* else {
        delete this._keys[this._keys.indexOf(key)];
        this._keys.push(key);
      }
      */
    },

    get: function(key) {
      return this._store.get(key);
    },

    clear: function() {
      this.size = 0;
      this._store = new Map();
      this._keys = [];
    },

    delete: function(key) {
      if (this._store.delete(key) && this.size > 0) {
        delete this._keys[this._keys.indexOf(key)];
        this.size--;
      }
    },

    each: function(callback, scope) {
      if (!this.size) { return; }
      this._keys.forEach(function(k){
        if (typeof k == "undefined") { return; }
        var v = this._store.get(k);
        if (typeof v != "undefined") {
          callback.call(scope||null, k, v);
        }
      }, this);
    },

    escapingEach: function(callback, scope) {
      if (!this.size) { return; }

      var that = this;
      var kl = this._keys.length;
      var context;
      for (var x = 0; x < kl; x++) {
        if (typeof this._keys[x] != "undefined") {
          (function(k) {
            var v = that._store.get(k);
            if (typeof v != "undefined") {
              context = callback.call(scope||null, k, v);
            }
          })(this._keys[x]);

          if (context) {
            if (context.retval !== undefined) {
              return context;
            }
            if (context.brk) {
              break;
            }
          }
        }
      }
    },

    clone: function() {
      var n = new c.HashTable();
      if (this.size) {
        this.each(function(k, v) {
          n.set(k, v);
        });
      }
      return n;
    }
  });
} else {
  // For escapingEach
  var defaultContext = {};

  c.HashTable = c.inherit({

    initialize: function() {
      this.size = 0;
      this._store = {};
      this._keyStrMap = {};
      this._deleted = 0;
    },

    set: function(key, value) {
      var hash = keyCode(key);

      if (!this._store.hasOwnProperty(hash)) {
        // FIXME(slightlyoff): if size gooes above the V8 property limit,
        // compact or go to a tree.
        this.size++;
      }
      this._store[hash] = value;
      this._keyStrMap[hash] = key;
    },

    get: function(key) {
      if(!this.size) { return null; }

      key = keyCode(key);

      var v = this._store[key];
      if (typeof v != "undefined") {
        return this._store[key];
      }
      return null;
    },

    clear: function() {
      this.size = 0;
      this._store = {};
      this._keyStrMap = {};
    },

    _compact: function() {
      // console.time("HashTable::_compact()");
      var ns = {};
      copyOwn(this._store, ns);
      this._store = ns;
      // console.timeEnd("HashTable::_compact()");
    },

    _compactThreshold: 100,
    _perhapsCompact: function() {
      // If we have more properties than V8's fast property lookup limit, don't
      // bother
      if (this._size > 64) return;
      if (this._deleted > this._compactThreshold) {
        this._compact();
        this._deleted = 0;
      }
    },

    delete: function(key) {
      key = keyCode(key);
      if (!this._store.hasOwnProperty(key)) {
        return;
      }
      this._deleted++;

      // FIXME(slightlyoff):
      //    I hate this because it causes these objects to go megamorphic = (
      //    Sadly, Cassowary is hugely sensitive to iteration order changes, and
      //    "delete" preserves order when Object.keys() is called later.
      delete this._store[key];
      // Note: we don't delete from _keyStrMap because we only get the
      // Object.keys() from _store, so it's the only one we need to keep up-to-
      // date.

      if (this.size > 0) {
        this.size--;
      }
    },

    each: function(callback, scope) {
      if (!this.size) { return; }

      this._perhapsCompact();

      var store = this._store;
      var keyMap = this._keyStrMap;
      Object.keys(this._store).forEach(function(k){
        callback.call(scope||null, keyMap[k], store[k]);
      }, this);
    },

    escapingEach: function(callback, scope) {
      if (!this.size) { return; }

      this._perhapsCompact();

      var that = this;
      var store = this._store;
      var keyMap = this._keyStrMap;
      var context = defaultContext;
      var kl = Object.keys(store);
      for (var x = 0; x < kl.length; x++) {
        (function(v) {
          if (that._store.hasOwnProperty(v)) {
            context = callback.call(scope||null, keyMap[v], store[v]);
          }
        })(kl[x]);

        if (context) {
          if (context.retval !== undefined) {
            return context;
          }
          if (context.brk) {
            break;
          }
        }
      }
    },

    clone: function() {
      var n = new c.HashTable();
      if (this.size) {
        n.size = this.size;
        copyOwn(this._store, n._store);
        copyOwn(this._keyStrMap, n._keyStrMap);
      }
      return n;
    },

    equals: function(other) {
      if (other === this) {
        return true;
      }

      if (!(other instanceof c.HashTable) || other._size !== this._size) {
        return false;
      }

      var codes = Object.keys(this._store);
      for (var i = 0; i < codes.length; i++) {
        var code = codes[i];
        if (this._keyStrMap[code] !== other._keyStrMap[code] ||
            this._store[code] !== other._store[code]) {
          return false;
        }
      }

      return true;
    },

    toString: function(h) {
      var answer = "";
      this.each(function(k, v) { answer += k + " => " + v + "\n"; });
      return answer;
    },
  });
}

})(this["c"]||module.parent.exports||{});

});
require.register("slightlyoff-cassowary.js/src/HashSet.js", function(exports, require, module){
/**
 * Copyright 2011, Alex Russell <slightlyoff@google.com>
 *
 * Use of this source code is governed by http://www.apache.org/licenses/LICENSE-2.0
 *
 * API compatible re-implementation of jshashset.js, including only what
 * Cassowary needs. Built for speed, not comfort.
 */
(function(c) {
"use strict";

c.HashSet = c.inherit({
  _t: "c.HashSet",

  initialize: function() {
    this.storage = [];
    this.size = 0;
  },

  add: function(item) {
    var s = this.storage, io = s.indexOf(item);
    if (s.indexOf(item) == -1) { s.push(item); }
    this.size = this.storage.length;
  },

  values: function() {
    // FIXME(slightlyoff): is it safe to assume we won't be mutated by our caller?
    //                     if not, return this.storage.slice(0);
    return this.storage;
  },

  has: function(item) {
    var s = this.storage;
    return (s.indexOf(item) != -1);
  },

  delete: function(item) {
    var io = this.storage.indexOf(item);
    if (io == -1) { return null; }
    this.storage.splice(io, 1)[0];
    this.size = this.storage.length;
  },

  clear: function() {
    this.storage.length = 0;
  },

  each: function(func, scope) {
    if(this.size)
      this.storage.forEach(func, scope);
  },

  escapingEach: function(func, scope) {
    // FIXME(slightlyoff): actually escape!
    if (this.size)
      this.storage.forEach(func, scope);
  },

  toString: function() {
    var answer = this.size + " {";
    var first = true;
    this.each(function(e) {
      if (!first) {
        answer += ", ";
      } else {
        first = false;
      }
      answer += e;
    });
    answer += "}\n";
    return answer;
  },

  toJSON: function() {
    var d = [];
    this.each(function(e) {
      d.push(e.toJSON());
    });
    return {
      _t: "c.HashSet",
      data: d
    };
  },

  fromJSON: function(o) {
    var r = new c.HashSet();
    if (o.data) {
      r.size = o.data.length;
      r.storage = o.data;
    }
    return r;
  },
});

})(this["c"]||module.parent.exports||{});

});
require.register("slightlyoff-cassowary.js/src/Error.js", function(exports, require, module){
// Copyright (C) 1998-2000 Greg J. Badros
// Use of this source code is governed by http://www.apache.org/licenses/LICENSE-2.0
//
// Parts Copyright (C) 2011-2012, Alex Russell (slightlyoff@chromium.org)

(function(c){
  "use strict";

  c.Error = c.inherit({
    // extends: Error,
    initialize: function(s /*String*/) { if (s) { this._description = s; } },
    _name: "c.Error",
    _description: "An error has occured in Cassowary",
    set description(v)   { this._description = v; },
    get description()    { return "(" + this._name + ") " + this._description; },
    get message()        { return this.description; },
    toString: function() { return this.description; },
  });

  var errorType = function(name, error) {
    return c.inherit({
      extends: c.Error,
      initialize: function() { c.Error.apply(this, arguments); },
      _name: name||"", _description: error||""
    });
  };

  c.ConstraintNotFound =
    errorType("c.ConstraintNotFound",
        "Tried to remove a constraint never added to the tableu");

  c.InternalError =
    errorType("c.InternalError");

  c.NonExpression =
    errorType("c.NonExpression",
        "The resulting expression would be non");

  c.NotEnoughStays =
    errorType("c.NotEnoughStays",
        "There are not enough stays to give specific values to every variable");

  c.RequiredFailure =
    errorType("c.RequiredFailure", "A required constraint cannot be satisfied");

  c.TooDifficult =
    errorType("c.TooDifficult", "The constraints are too difficult to solve");

})(this["c"]||module.parent.exports||{});

});
require.register("slightlyoff-cassowary.js/src/SymbolicWeight.js", function(exports, require, module){
// Copyright (C) 1998-2000 Greg J. Badros
// Use of this source code is governed by http://www.apache.org/licenses/LICENSE-2.0
//
// Parts Copyright (C) 2011-2012, Alex Russell (slightlyoff@chromium.org)

(function(c) {
"use strict";

var multiplier = 1000;

c.SymbolicWeight = c.inherit({
  _t: "c.SymbolicWeight",
  initialize: function(/*w1, w2, w3*/) {
    this.value = 0;
    var factor = 1;
    for (var i = arguments.length - 1; i >= 0; --i) {
      this.value += arguments[i] * factor;
      factor *= multiplier;
    }
  },

  toJSON: function() {
    return {
      _t: this._t,
      value: this.value
    };
  },
});

})(this["c"]||module.parent.exports||{});

});
require.register("slightlyoff-cassowary.js/src/Strength.js", function(exports, require, module){
// Copyright (C) 1998-2000 Greg J. Badros
// Use of this source code is governed by http://www.apache.org/licenses/LICENSE-2.0
//
// Parts Copyright (C) 2011, Alex Russell (slightlyoff@chromium.org)

// FILE: EDU.Washington.grad.gjb.cassowary
// package EDU.Washington.grad.gjb.cassowary;

(function(c) {

c.Strength = c.inherit({
  initialize: function(name /*String*/, symbolicWeight, w2, w3) {
    this.name = name;
    if (symbolicWeight instanceof c.SymbolicWeight) {
      this.symbolicWeight = symbolicWeight;
    } else {
      this.symbolicWeight = new c.SymbolicWeight(symbolicWeight, w2, w3);
    }
  },

  get required() {
    return (this === c.Strength.required);
  },

  toString: function() {
    return this.name + (!this.isRequired ? (":" + this.symbolicWeight) : "");
  },
});

/* public static final */
c.Strength.required = new c.Strength("<Required>", 1000, 1000, 1000);
/* public static final  */
c.Strength.strong = new c.Strength("strong", 1, 0, 0);
/* public static final  */
c.Strength.medium = new c.Strength("medium", 0, 1, 0);
/* public static final  */
c.Strength.weak = new c.Strength("weak", 0, 0, 1);

})(this["c"]||((typeof module != "undefined") ? module.parent.exports.c : {}));

});
require.register("slightlyoff-cassowary.js/src/Variable.js", function(exports, require, module){
// Copyright (C) 1998-2000 Greg J. Badros
// Use of this source code is governed by http://www.apache.org/licenses/LICENSE-2.0
//
// Parts Copyright (C) 2011-2012, Alex Russell (slightlyoff@chromium.org)

(function(c) {
"use strict";

c.AbstractVariable = c.inherit({
  isDummy:      false,
  isExternal:   false,
  isPivotable:  false,
  isRestricted: false,

  _init: function(args, varNamePrefix) {
    // Common mixin initialization.
    this.hashCode = c._inc();
    this.name = (varNamePrefix||"") + this.hashCode;
    if (args) {
      if (typeof args.name != "undefined") {
        this.name = args.name;
      }
      if (typeof args.value != "undefined") {
        this.value = args.value;
      }
      if (typeof args.prefix != "undefined") {
        this._prefix = args.prefix;
      }
    }
  },

  _prefix: "",
  name: "",
  value: 0,

  toJSON: function() {
    var o = {};
    if (this._t) {
      o._t = this._t;
    }
    if (this.name) {
      o.name = this.name;
    }
    if (typeof this.value != "undefined") {
      o.value = this.value;
    }
    if (this._prefix) {
      o._prefix = this._prefix;
    }
    if (this._t) {
      o._t = this._t;
    }
    return o;
  },

  fromJSON: function(o, Ctor) {
    var r = new Ctor();
    c.extend(r, o);
    return r;
  },

  toString: function() {
    return this._prefix + "[" + this.name + ":" + this.value + "]";
  },

});

c.Variable = c.inherit({
  _t: "c.Variable",
  extends: c.AbstractVariable,
  initialize: function(args) {
    this._init(args, "v");
    var vm = c.Variable._map;
    if (vm) { vm[this.name] = this; }
  },
  isExternal:     true,
});

/* static */
// c.Variable._map = [];

c.DummyVariable = c.inherit({
  _t: "c.DummyVariable",
  extends: c.AbstractVariable,
  initialize: function(args) {
    this._init(args, "d");
  },
  isDummy:        true,
  isRestricted:   true,
  value:         "dummy",
});

c.ObjectiveVariable = c.inherit({
  _t: "c.ObjectiveVariable",
  extends: c.AbstractVariable,
  initialize: function(args) {
    this._init(args, "o");
  },
  value:         "obj",
});

c.SlackVariable = c.inherit({
  _t: "c.SlackVariable",
  extends: c.AbstractVariable,
  initialize: function(args) {
    this._init(args, "s");
  },
  isPivotable:    true,
  isRestricted:   true,
  value:         "slack",
});

})(this["c"]||module.parent.exports||{});

});
require.register("slightlyoff-cassowary.js/src/Point.js", function(exports, require, module){
// Copyright (C) 1998-2000 Greg J. Badros
// Use of this source code is governed by http://www.apache.org/licenses/LICENSE-2.0
//
// Parts Copyright (C) 2011, Alex Russell (slightlyoff@chromium.org)

(function(c) {
"use strict";

c.Point = c.inherit({
  initialize: function(x, y, suffix) {
    if (x instanceof c.Variable) {
      this._x = x;
    } else {
      var xArgs = { value: x };
      if (suffix) {
        xArgs.name = "x" + suffix;
      }
      this._x = new c.Variable(xArgs);
    }
    if (y instanceof c.Variable) {
      this._y = y;
    } else {
      var yArgs = { value: y };
      if (suffix) {
        yArgs.name = "y" + suffix;
      }
      this._y = new c.Variable(yArgs);
    }
  },

  get x() { return this._x; },
  set x(x) {
    if (x instanceof c.Variable) {
      this._x = x;
    } else {
      this._x.value = x;
    }
  },

  get y() { return this._y; },
  set y(y) {
    if (y instanceof c.Variable) {
      this._y = y;
    } else {
      this._y.value = y;
    }
  },

  toString: function() {
    return "(" + this.x + ", " + this.y + ")";
  },
});

})(this["c"]||module.parent.exports||{});

});
require.register("slightlyoff-cassowary.js/src/Expression.js", function(exports, require, module){
// Copyright (C) 1998-2000 Greg J. Badros
// Use of this source code is governed by http://www.apache.org/licenses/LICENSE-2.0
//
// Parts Copyright (C) 2011, Alex Russell (slightlyoff@chromium.org)

// FILE: EDU.Washington.grad.gjb.cassowary
// package EDU.Washington.grad.gjb.cassowary;

(function(c) {
"use strict";

c.Expression = c.inherit({
  initialize: function(clv /*c.AbstractVariable*/, value /*double*/, constant /*double*/) {
    if (c.GC) console.log("new c.Expression");
    this.constant = (typeof constant == "number" && !isNaN(constant)) ? constant : 0;
    this.terms = new c.HashTable();

    if (clv instanceof c.AbstractVariable) {
      this.setVariable(clv, typeof value == 'number' ? value : 1);
    } else if (typeof clv == "number") {
      if (!isNaN(clv)) {
        this.constant = clv;
      } else {
        console.trace();
      }
    }
  },

  initializeFromHash: function(constant /*ClDouble*/, terms /*c.Hashtable*/) {
    if (c.verbose) {
      console.log("*******************************");
      console.log("clone c.initializeFromHash");
      console.log("*******************************");
    }

    if (c.GC) console.log("clone c.Expression");
    this.constant = constant;
    this.terms = terms.clone();
    return this;
  },

  multiplyMe: function(x /*double*/) {
    this.constant *= x;
    var t = this.terms;
    t.each(function(clv, coeff) { t.set(clv, coeff * x); });
    return this;
  },

  clone: function() {
    if (c.verbose) {
      console.log("*******************************");
      console.log("clone c.Expression");
      console.log("*******************************");
    }

    var e = new c.Expression();
    e.initializeFromHash(this.constant, this.terms);
    return e;
  },

  times: function(x) {
    if (typeof x == 'number') {
      return (this.clone()).multiplyMe(x);
    } else {
      if (this.isConstant) {
        return x.times(this.constant);
      } else if (x.isConstant) {
        return this.times(x.constant);
      } else {
        throw new c.NonExpression();
      }
    }
  },

  plus: function(expr /*c.Expression*/) {
    if (expr instanceof c.Expression) {
      return this.clone().addExpression(expr, 1);
    } else if (expr instanceof c.Variable) {
      return this.clone().addVariable(expr, 1);
    }
  },

  minus: function(expr /*c.Expression*/) {
    if (expr instanceof c.Expression) {
      return this.clone().addExpression(expr, -1);
    } else if (expr instanceof c.Variable) {
      return this.clone().addVariable(expr, -1);
    }
  },

  divide: function(x) {
    if (typeof x == 'number') {
      if (c.approx(x, 0)) {
        throw new c.NonExpression();
      }
      return this.times(1 / x);
    } else if (x instanceof c.Expression) {
      if (!x.isConstant) {
        throw new c.NonExpression();
      }
      return this.times(1 / x.constant);
    }
  },

  addExpression: function(expr /*c.Expression*/,
                          n /*double*/,
                          subject /*c.AbstractVariable*/,
                          solver /*c.Tableau*/) {

    // console.log("c.Expression::addExpression()", expr, n);
    // console.trace();
    if (expr instanceof c.AbstractVariable) {
      expr = new c.Expression(expr);
      if(c.trace) console.log("addExpression: Had to cast a var to an expression");
    }
    n = n || 1;
    this.constant += (n * expr.constant);
    expr.terms.each(function(clv, coeff) {
      // console.log("clv:", clv, "coeff:", coeff, "subject:", subject);
      this.addVariable(clv, coeff * n, subject, solver);
    }, this);
    return this;
  },

  addVariable: function(v /*c.AbstractVariable*/, cd /*double*/, subject, solver) {
    if (cd == null) {
      cd = 1;
    }

    if (c.trace) console.log("c.Expression::addVariable():", v , cd);
    var coeff = this.terms.get(v);
    if (coeff) {
      var newCoefficient = coeff + cd;
      if (newCoefficient == 0 || c.approx(newCoefficient, 0)) {
        if (solver) {
          solver.noteRemovedVariable(v, subject);
        }
        this.terms.delete(v);
      } else {
        this.setVariable(v, newCoefficient);
      }
    } else {
      if (!c.approx(cd, 0)) {
        this.setVariable(v, cd);
        if (solver) {
          solver.noteAddedVariable(v, subject);
        }
      }
    }
    return this;
  },

  setVariable: function(v /*c.AbstractVariable*/, c /*double*/) {
    // console.log("terms.set(", v, c, ")");
    this.terms.set(v, c);
    return this;
  },

  anyPivotableVariable: function() {
    if (this.isConstant) {
      throw new c.InternalError("anyPivotableVariable called on a constant");
    }

    var rv = this.terms.escapingEach(function(clv, c) {
      if (clv.isPivotable) return { retval: clv };
    });

    if (rv && rv.retval !== undefined) {
      return rv.retval;
    }

    return null;
  },

  substituteOut: function(outvar  /*c.AbstractVariable*/,
                          expr    /*c.Expression*/,
                          subject /*c.AbstractVariable*/,
                          solver  /*ClTableau*/) {

    if (c.trace) {
      c.fnenterprint("CLE:substituteOut: " + outvar + ", " + expr + ", " + subject + ", ...");
      c.traceprint("this = " + this);
    }

    var setVariable = this.setVariable.bind(this);
    var terms = this.terms;
    var multiplier = terms.get(outvar);
    terms.delete(outvar);
    this.constant += (multiplier * expr.constant);
    /*
    console.log("substituteOut:",
                "\n\toutvar:", outvar,
                "\n\texpr:", expr.toString(),
                "\n\tmultiplier:", multiplier,
                "\n\tterms:", terms);
    */
    expr.terms.each(function(clv, coeff) {
      var oldCoefficient = terms.get(clv);
      if (oldCoefficient) {
        var newCoefficient = oldCoefficient + multiplier * coeff;
        if (c.approx(newCoefficient, 0)) {
          solver.noteRemovedVariable(clv, subject);
          terms.delete(clv);
        } else {
          setVariable(clv, newCoefficient);
        }
      } else {
        setVariable(clv, multiplier * coeff);
        if (solver) {
          solver.noteAddedVariable(clv, subject);
        }
      }
    });
    if (c.trace) c.traceprint("Now this is " + this);
  },

  changeSubject: function(old_subject /*c.AbstractVariable*/,
                          new_subject /*c.AbstractVariable*/) {
    this.setVariable(old_subject, this.newSubject(new_subject));
  },

  newSubject: function(subject /*c.AbstractVariable*/) {
    if (c.trace) c.fnenterprint("newSubject:" + subject);

    var reciprocal = 1 / this.terms.get(subject);
    this.terms.delete(subject);
    this.multiplyMe(-reciprocal);
    return reciprocal;
  },

  // Return the coefficient corresponding to variable var, i.e.,
  // the 'ci' corresponding to the 'vi' that var is:
  //     v1*c1 + v2*c2 + .. + vn*cn + c
  coefficientFor: function(clv /*c.AbstractVariable*/) {
    return this.terms.get(clv) || 0;
  },

  get isConstant() {
    return this.terms.size == 0;
  },

  toString: function() {
    var bstr = ''; // answer
    var needsplus = false;
    if (!c.approx(this.constant, 0) || this.isConstant) {
      bstr += this.constant;
      if (this.isConstant) {
        return bstr;
      } else {
        needsplus = true;
      }
    }
    this.terms.each( function(clv, coeff) {
      if (needsplus) {
        bstr += " + ";
      }
      bstr += coeff + "*" + clv;
      needsplus = true;
    });
    return bstr;
  },

  equals: function(other) {
    if (other === this) {
      return true;
    }

    return other instanceof c.Expression &&
           other.constant === this.constant &&
           other.terms.equals(this.terms);
  },

  Plus: function(e1 /*c.Expression*/, e2 /*c.Expression*/) {
    return e1.plus(e2);
  },

  Minus: function(e1 /*c.Expression*/, e2 /*c.Expression*/) {
    return e1.minus(e2);
  },

  Times: function(e1 /*c.Expression*/, e2 /*c.Expression*/) {
    return e1.times(e2);
  },

  Divide: function(e1 /*c.Expression*/, e2 /*c.Expression*/) {
    return e1.divide(e2);
  },
});

})(this["c"]||module.parent.exports||{});

});
require.register("slightlyoff-cassowary.js/src/Constraint.js", function(exports, require, module){
// Copyright (C) 1998-2000 Greg J. Badros
// Use of this source code is governed by http://www.apache.org/licenses/LICENSE-2.0
//
// Parts Copyright (C) 2011-2012, Alex Russell (slightlyoff@chromium.org)

(function(c) {
"use strict";

c.AbstractConstraint = c.inherit({
  initialize: function(strength /*c.Strength*/, weight /*double*/) {
    this.hashCode = c._inc();
    this.strength = strength || c.Strength.required;
    this.weight = weight || 1;
  },

  isEditConstraint: false,
  isInequality:     false,
  isStayConstraint: false,
  get required() { return (this.strength === c.Strength.required); },

  toString: function() {
    // this is abstract -- it intentionally leaves the parens unbalanced for
    // the subclasses to complete (e.g., with ' = 0', etc.
    return this.strength + " {" + this.weight + "} (" + this.expression +")";
  },
});

var ts = c.AbstractConstraint.prototype.toString;

var EditOrStayCtor = function(cv /*c.Variable*/, strength /*c.Strength*/, weight /*double*/) {
  c.AbstractConstraint.call(this, strength || c.Strength.strong, weight);
  this.variable = cv;
  this.expression = new c.Expression(cv, -1, cv.value);
};

c.EditConstraint = c.inherit({
  extends: c.AbstractConstraint,
  initialize: function() { EditOrStayCtor.apply(this, arguments); },
  isEditConstraint: true,
  toString: function() { return "edit:" + ts.call(this); },
});

c.StayConstraint = c.inherit({
  extends: c.AbstractConstraint,
  initialize: function() { EditOrStayCtor.apply(this, arguments); },
  isStayConstraint: true,
  toString: function() { return "stay:" + ts.call(this); },
});

var lc =
c.Constraint = c.inherit({
  extends: c.AbstractConstraint,
  initialize: function(cle /*c.Expression*/,
                       strength /*c.Strength*/,
                       weight /*double*/) {
    c.AbstractConstraint.call(this, strength, weight);
    this.expression = cle;
  },
});

c.Inequality = c.inherit({
  extends: c.Constraint,

  _cloneOrNewCle: function(cle) {
    // FIXME(D4): move somewhere else?
    if (cle.clone)  {
      return cle.clone();
    } else {
      return new c.Expression(cle);
    }
  },

  initialize: function(a1, a2, a3, a4, a5) {
    // FIXME(slightlyoff): what a disgusting mess. Should at least add docs.
    // console.log("c.Inequality.initialize(", a1, a2, a3, a4, a5, ")");

    var a1IsExp = a1 instanceof c.Expression,
        a3IsExp = a3 instanceof c.Expression,
        a1IsVar = a1 instanceof c.AbstractVariable,
        a3IsVar = a3 instanceof c.AbstractVariable,
        a1IsNum = typeof(a1) == 'number',
        a3IsNum = typeof(a3) == 'number';

    // (cle || number), op, cv
    if ((a1IsExp || a1IsNum) && a3IsVar) {
      var cle = a1, op = a2, cv = a3, strength = a4, weight = a5;
      lc.call(this, this._cloneOrNewCle(cle), strength, weight);
      if (op == c.LEQ) {
        this.expression.multiplyMe(-1);
        this.expression.addVariable(cv);
      } else if (op == c.GEQ) {
        this.expression.addVariable(cv, -1);
      } else {
        throw new c.InternalError("Invalid operator in c.Inequality constructor");
      }
    // cv, op, (cle || number)
    } else if (a1IsVar && (a3IsExp || a3IsNum)) {
      var cle = a3, op = a2, cv = a1, strength = a4, weight = a5;
      lc.call(this, this._cloneOrNewCle(cle), strength, weight);
      if (op == c.GEQ) {
        this.expression.multiplyMe(-1);
        this.expression.addVariable(cv);
      } else if (op == c.LEQ) {
        this.expression.addVariable(cv, -1);
      } else {
        throw new c.InternalError("Invalid operator in c.Inequality constructor");
      }
    // cle, op, num
    } else if (a1IsExp && a3IsNum) {
      var cle1 = a1, op = a2, cle2 = a3, strength = a4, weight = a5;
      lc.call(this, this._cloneOrNewCle(cle1), strength, weight);
      if (op == c.LEQ) {
        this.expression.multiplyMe(-1);
        this.expression.addExpression(this._cloneOrNewCle(cle2));
      } else if (op == c.GEQ) {
        this.expression.addExpression(this._cloneOrNewCle(cle2), -1);
      } else {
        throw new c.InternalError("Invalid operator in c.Inequality constructor");
      }
      return this
    // num, op, cle
    } else if (a1IsNum && a3IsExp) {
      var cle1 = a3, op = a2, cle2 = a1, strength = a4, weight = a5;
      lc.call(this, this._cloneOrNewCle(cle1), strength, weight);
      if (op == c.GEQ) {
        this.expression.multiplyMe(-1);
        this.expression.addExpression(this._cloneOrNewCle(cle2));
      } else if (op == c.LEQ) {
        this.expression.addExpression(this._cloneOrNewCle(cle2), -1);
      } else {
        throw new c.InternalError("Invalid operator in c.Inequality constructor");
      }
      return this
    // cle op cle
    } else if (a1IsExp && a3IsExp) {
      var cle1 = a1, op = a2, cle2 = a3, strength = a4, weight = a5;
      lc.call(this, this._cloneOrNewCle(cle2), strength, weight);
      if (op == c.GEQ) {
        this.expression.multiplyMe(-1);
        this.expression.addExpression(this._cloneOrNewCle(cle1));
      } else if (op == c.LEQ) {
        this.expression.addExpression(this._cloneOrNewCle(cle1), -1);
      } else {
        throw new c.InternalError("Invalid operator in c.Inequality constructor");
      }
    // cle
    } else if (a1IsExp) {
      return lc.call(this, a1, a2, a3);
    // >=
    } else if (a2 == c.GEQ) {
      lc.call(this, new c.Expression(a3), a4, a5);
      this.expression.multiplyMe(-1);
      this.expression.addVariable(a1);
    // <=
    } else if (a2 == c.LEQ) {
      lc.call(this, new c.Expression(a3), a4, a5);
      this.expression.addVariable(a1,-1);
    // error
    } else {
      throw new c.InternalError("Invalid operator in c.Inequality constructor");
    }
  },

  isInequality: true,

  toString: function() {
    // return "c.Inequality: " + this.hashCode;
    return lc.prototype.toString.call(this) + " >= 0) id: " + this.hashCode;
  },
});

c.Equation = c.inherit({
  extends: c.Constraint,
  initialize: function(a1, a2, a3, a4) {
    // FIXME(slightlyoff): this is just a huge mess.
    if (a1 instanceof c.Expression && !a2 || a2 instanceof c.Strength) {
      lc.call(this, a1, a2, a3);
    } else if ((a1 instanceof c.AbstractVariable) &&
               (a2 instanceof c.Expression)) {

      var cv = a1, cle = a2, strength = a3, weight = a4;
      lc.call(this, cle.clone(), strength, weight);
      this.expression.addVariable(cv, -1);

    } else if ((a1 instanceof c.AbstractVariable) &&
               (typeof(a2) == 'number')) {

      var cv = a1, val = a2, strength = a3, weight = a4;
      lc.call(this, new c.Expression(val), strength, weight);
      this.expression.addVariable(cv, -1);

    } else if ((a1 instanceof c.Expression) &&
               (a2 instanceof c.AbstractVariable)) {

      var cle = a1, cv = a2, strength = a3, weight = a4;
      lc.call(this, cle.clone(), strength, weight);
      this.expression.addVariable(cv, -1);

    } else if (((a1 instanceof c.Expression) || (a1 instanceof c.AbstractVariable) ||
                (typeof(a1) == 'number')) &&
               ((a2 instanceof c.Expression) || (a2 instanceof c.AbstractVariable) ||
                (typeof(a2) == 'number'))) {

      if (a1 instanceof c.Expression) {
        a1 = a1.clone();
      } else {
        a1 = new c.Expression(a1);
      }

      if (a2 instanceof c.Expression) {
        a2 = a2.clone();
      } else {
        a2 = new c.Expression(a2);
      }

      lc.call(this, a1, a3, a4);
      this.expression.addExpression(a2, -1);

    } else {
      throw "Bad initializer to c.Equation";
    }
    c.assert(this.strength instanceof c.Strength, "_strength not set");
  },

  toString: function() {
    return lc.prototype.toString.call(this) + " = 0)";
  },
});

})(this["c"]||module.parent.exports||{});

});
require.register("slightlyoff-cassowary.js/src/EditInfo.js", function(exports, require, module){
// Copyright (C) 1998-2000 Greg J. Badros
// Use of this source code is governed by http://www.apache.org/licenses/LICENSE-2.0
//
// Parts Copyright (C) 2011, Alex Russell (slightlyoff@chromium.org)

(function(c) {
"use strict";

c.EditInfo = c.inherit({
  initialize: function(cn      /*c.Constraint*/,
                       eplus   /*c.SlackVariable*/,
                       eminus  /*c.SlackVariable*/,
                       prevEditConstant /*double*/,
                       i /*int*/) {
    this.constraint = cn;
    this.editPlus = eplus;
    this.editMinus = eminus;
    this.prevEditConstant = prevEditConstant;
    this.index = i;
  },
  toString: function() {
    return "<cn=" + this.constraint +
           ", ep=" + this.editPlus +
           ", em=" + this.editMinus +
           ", pec=" + this.prevEditConstant +
           ", index=" + this.index + ">";
  }
});

})(this["c"]||module.parent.exports||{});

});
require.register("slightlyoff-cassowary.js/src/Tableau.js", function(exports, require, module){
// Copyright (C) 1998-2000 Greg J. Badros
// Use of this source code is governed by http://www.apache.org/licenses/LICENSE-2.0
//
// Parts Copyright (C) 2011, Alex Russell (slightlyoff@chromium.org)

(function(c) {
"use strict";

c.Tableau = c.inherit({
  initialize: function() {
    // columns is a mapping from variables which occur in expressions to the
    // set of basic variables whose expressions contain them
    // i.e., it's a mapping from variables in expressions (a column) to the
    // set of rows that contain them
    this.columns = new c.HashTable(); // values are sets

    // _rows maps basic variables to the expressions for that row in the tableau
    this.rows = new c.HashTable();    // values are c.Expressions

    // the collection of basic variables that have infeasible rows
    // (used when reoptimizing)
    this._infeasibleRows = new c.HashSet();

    // the set of rows where the basic variable is external this was added to
    // the C++ version to reduce time in setExternalVariables()
    this._externalRows = new c.HashSet();

    // the set of external variables which are parametric this was added to the
    // C++ version to reduce time in setExternalVariables()
    this._externalParametricVars = new c.HashSet();
  },

  // Variable v has been removed from an Expression.  If the Expression is in a
  // tableau the corresponding basic variable is subject (or if subject is nil
  // then it's in the objective function). Update the column cross-indices.
  noteRemovedVariable: function(v /*c.AbstractVariable*/, subject /*c.AbstractVariable*/) {
    c.trace && console.log("c.Tableau::noteRemovedVariable: ", v, subject);
    var column = this.columns.get(v);
    if (subject && column) {
      column.delete(subject);
    }
  },

  noteAddedVariable: function(v /*c.AbstractVariable*/, subject /*c.AbstractVariable*/) {
    // if (c.trace) console.log("c.Tableau::noteAddedVariable:", v, subject);
    if (subject) {
      this.insertColVar(v, subject);
    }
  },

  getInternalInfo: function() {
    var retstr = "Tableau Information:\n";
    retstr += "Rows: " + this.rows.size;
    retstr += " (= " + (this.rows.size - 1) + " constraints)";
    retstr += "\nColumns: " + this.columns.size;
    retstr += "\nInfeasible Rows: " + this._infeasibleRows.size;
    retstr += "\nExternal basic variables: " + this._externalRows.size;
    retstr += "\nExternal parametric variables: ";
    retstr += this._externalParametricVars.size;
    retstr += "\n";
    return retstr;
  },

  toString: function() {
    var bstr = "Tableau:\n";
    this.rows.each(function(clv, expr) {
      bstr += clv;
      bstr += " <==> ";
      bstr += expr;
      bstr += "\n";
    });
    bstr += "\nColumns:\n";
    bstr += this.columns;
    bstr += "\nInfeasible rows: ";
    bstr += this._infeasibleRows;
    bstr += "External basic variables: ";
    bstr += this._externalRows;
    bstr += "External parametric variables: ";
    bstr += this._externalParametricVars;
    return bstr;
  },

  /*
  toJSON: function() {
    // Creates an object representation of the Tableau.
  },
  */

  // Convenience function to insert a variable into
  // the set of rows stored at columns[param_var],
  // creating a new set if needed
  insertColVar: function(param_var /*Variable*/, rowvar /*Variable*/) {
    var rowset = /* Set */ this.columns.get(param_var);
    if (!rowset) {
      rowset = new c.HashSet();
      this.columns.set(param_var, rowset);
    }
    rowset.add(rowvar);
  },

  addRow: function(aVar /*c.AbstractVariable*/, expr /*c.Expression*/) {
    if (c.trace) c.fnenterprint("addRow: " + aVar + ", " + expr);
    this.rows.set(aVar, expr);
    expr.terms.each(function(clv, coeff) {
      this.insertColVar(clv, aVar);
      if (clv.isExternal) {
        this._externalParametricVars.add(clv);
      }
    }, this);
    if (aVar.isExternal) {
      this._externalRows.add(aVar);
    }
    if (c.trace) c.traceprint(this.toString());
  },

  removeColumn: function(aVar /*c.AbstractVariable*/) {
    if (c.trace) c.fnenterprint("removeColumn:" + aVar);
    var rows = /* Set */ this.columns.get(aVar);
    if (rows) {
      this.columns.delete(aVar);
      rows.each(function(clv) {
        var expr = /* c.Expression */this.rows.get(clv);
        expr.terms.delete(aVar);
      }, this);
    } else {
      if (c.trace) console.log("Could not find var", aVar, "in columns");
    }
    if (aVar.isExternal) {
      this._externalRows.delete(aVar);
      this._externalParametricVars.delete(aVar);
    }
  },

  removeRow: function(aVar /*c.AbstractVariable*/) {
    if (c.trace) c.fnenterprint("removeRow:" + aVar);
    var expr = /* c.Expression */this.rows.get(aVar);
    c.assert(expr != null);
    expr.terms.each(function(clv, coeff) {
      var varset = this.columns.get(clv);
      if (varset != null) {
        if (c.trace) console.log("removing from varset:", aVar);
        varset.delete(aVar);
      }
    }, this);
    this._infeasibleRows.delete(aVar);
    if (aVar.isExternal) {
      this._externalRows.delete(aVar);
    }
    this.rows.delete(aVar);
    if (c.trace) c.fnexitprint("returning " + expr);
    return expr;
  },

  substituteOut: function(oldVar /*c.AbstractVariable*/, expr /*c.Expression*/) {
    if (c.trace) c.fnenterprint("substituteOut:" + oldVar + ", " + expr);
    if (c.trace) c.traceprint(this.toString());

    var varset = this.columns.get(oldVar);
    varset.each(function(v) {
      var row = this.rows.get(v);
      row.substituteOut(oldVar, expr, v, this);
      if (v.isRestricted && row.constant < 0) {
        this._infeasibleRows.add(v);
      }
    }, this);

    if (oldVar.isExternal) {
      this._externalRows.add(oldVar);
      this._externalParametricVars.delete(oldVar);
    }

    this.columns.delete(oldVar);
  },

  columnsHasKey: function(subject /*c.AbstractVariable*/) {
    return !!this.columns.get(subject);
  },
});

})(this["c"]||module.parent.exports||{});

});
require.register("slightlyoff-cassowary.js/src/SimplexSolver.js", function(exports, require, module){
// Copyright (C) 1998-2000 Greg J. Badros
// Use of this source code is governed by http://www.apache.org/licenses/LICENSE-2.0
//
// Parts Copyright (C) 2011, Alex Russell (slightlyoff@chromium.org)

(function(c) {
var t = c.Tableau;
var tp = t.prototype;
var epsilon = 1e-8;
var weak = c.Strength.weak;

c.SimplexSolver = c.inherit({
  extends: c.Tableau,
  initialize: function(){

    c.Tableau.call(this);
    this._stayMinusErrorVars = [];
    this._stayPlusErrorVars = [];

    this._errorVars = new c.HashTable(); // cn -> Set of cv

    this._markerVars = new c.HashTable(); // cn -> Set of cv

    // this._resolve_pair = [0, 0];
    this._objective = new c.ObjectiveVariable({ name: "Z" });

    this._editVarMap = new c.HashTable(); // cv -> c.EditInfo
    this._editVarList = [];

    this._slackCounter = 0;
    this._artificialCounter = 0;
    this._dummyCounter = 0;
    this.autoSolve = true;
    this._fNeedsSolving = false;

    this._optimizeCount = 0;

    this.rows.set(this._objective, new c.Expression());
    this._stkCedcns = [0]; // Stack
    if (c.trace)
      c.traceprint("objective expr == " + this.rows.get(this._objective));
  },

  addLowerBound: function(v /*c.AbstractVariable*/, lower /*double*/) {
    var cn = new c.Inequality(v, c.GEQ, new c.Expression(lower));
    return this.addConstraint(cn);
  },

  addUpperBound: function(v /*c.AbstractVariable*/, upper /*double*/) {
    var cn = new c.Inequality(v, c.LEQ, new c.Expression(upper));
    return this.addConstraint(cn);
  },

  addBounds: function(v /*c.AbstractVariable*/, lower /*double*/, upper /*double*/) {
    this.addLowerBound(v, lower);
    this.addUpperBound(v, upper);
    return this;
  },

  add: function(/*c.Constraint, ...*/) {
    for (var x = 0; x < arguments.length; x++) {
      this.addConstraint(arguments[x]);
    }
    return this;
  },

  addConstraint: function(cn /*c.Constraint*/) {
    // console.log("addConstraint: " + cn);
    if (c.trace) c.fnenterprint("addConstraint: " + cn);
    var eplus_eminus = new Array(2);
    var prevEConstant = new Array(1); // so it can be output to
    var expr = this.newExpression(cn, /*output to*/ eplus_eminus, prevEConstant);
    prevEConstant = prevEConstant[0];

    if (!this.tryAddingDirectly(expr)) {
      this.addWithArtificialVariable(expr);
    }


    this._fNeedsSolving = true;
    if (cn.isEditConstraint) {
      var i = this._editVarMap.size;
      var cvEplus = /* c.SlackVariable */eplus_eminus[0];
      var cvEminus = /* c.SlackVariable */eplus_eminus[1];
      if (!cvEplus instanceof c.SlackVariable) {
        console.warn("cvEplus not a slack variable =", cvEplus);
      }
      if (!cvEminus instanceof c.SlackVariable) {
        console.warn("cvEminus not a slack variable =", cvEminus);
      }
      c.debug && console.log("new c.EditInfo(" + cn + ", " + cvEplus + ", " +
                                  cvEminus + ", " + prevEConstant + ", " +
                                  i +")");
      var ei = new c.EditInfo(cn, cvEplus, cvEminus, prevEConstant, i)
      this._editVarMap.set(cn.variable, ei);
      this._editVarList[i] = { v: cn.variable, info: ei };
    }
    if (this.autoSolve) {
      this.optimize(this._objective);
      this._setExternalVariables();
    }
    return this;
  },

  addConstraintNoException: function(cn /*c.Constraint*/) {
    if (c.trace) c.fnenterprint("addConstraintNoException: " + cn);
    // FIXME(slightlyoff): change this to enable chaining
    try {
      this.addConstraint(cn);
      return true;
    } catch (e /*c.RequiredFailure*/){
      return false;
    }
  },

  addEditVar: function(v /*c.Variable*/, strength /*c.Strength*/, weight /*double*/) {
    c.trace && c.fnenterprint("addEditVar: " + v + " @ " + strength + " {" + weight + "}");
    return this.addConstraint(
        new c.EditConstraint(v, strength || c.Strength.strong, weight));
  },

  beginEdit: function() {
    // FIXME(slightlyoff): we shouldn't throw here. Log instead
    c.assert(this._editVarMap.size > 0, "_editVarMap.size > 0");
    this._infeasibleRows.clear();
    this._resetStayConstants();
    this._stkCedcns.push(this._editVarMap.size);
    return this;
  },

  endEdit: function() {
    // FIXME(slightlyoff): we shouldn't throw here. Log instead
    c.assert(this._editVarMap.size > 0, "_editVarMap.size > 0");
    this.resolve();
    this._stkCedcns.pop();
    this.removeEditVarsTo(
      this._stkCedcns[this._stkCedcns.length - 1]
    );
    return this;
  },

  removeAllEditVars: function() {
    return this.removeEditVarsTo(0);
  },

  removeEditVarsTo: function(n /*int*/) {
    try {
      var evll = this._editVarList.length;
      // only remove the variable if it's not in the set of variable
      // from a previous nested outer edit
      // e.g., if I do:
      // Edit x,y
      // Edit w,h,x,y
      // EndEdit
      // The end edit needs to only get rid of the edits on w,h
      // not the ones on x,y
      for(var x = n; x < evll; x++) {
        if (this._editVarList[x]) {
          this.removeConstraint(
            this._editVarMap.get(this._editVarList[x].v).constraint
          );
        }
      }
      this._editVarList.length = n;
      c.assert(this._editVarMap.size == n, "_editVarMap.size == n");
      return this;
    } catch (e /*ConstraintNotFound*/){
      throw new c.InternalError("Constraint not found in removeEditVarsTo");
    }
  },

  // Add weak stays to the x and y parts of each point. These have
  // increasing weights so that the solver will try to satisfy the x
  // and y stays on the same point, rather than the x stay on one and
  // the y stay on another.
  addPointStays: function(points /*[{ x: .., y: ..}, ...]*/) {
    c.trace && console.log("addPointStays", points);
    points.forEach(function(p, idx) {
      this.addStay(p.x, weak, Math.pow(2, idx));
      this.addStay(p.y, weak, Math.pow(2, idx));
    }, this);
    return this;
  },

  addStay: function(v /*c.Variable*/, strength /*c.Strength*/, weight /*double*/) {
    var cn = new c.StayConstraint(v,
                                  strength || weak,
                                  weight   || 1);
    return this.addConstraint(cn);
  },

  // FIXME(slightlyoff): need a removeStay!

  removeConstraint: function(cn /*c.Constraint*/) {
    this.removeConstraintInternal(cn);
    return this;
  },

  removeConstraintInternal: function(cn /*c.Constraint*/) {
    // print("removeConstraintInternal('" + cn + "')");
    if (c.trace) c.fnenterprint("removeConstraintInternal: " + cn);
    if (c.trace) c.traceprint(this.toString());
    this._fNeedsSolving = true;
    this._resetStayConstants();
    var zRow = this.rows.get(this._objective);
    var eVars = /* Set */this._errorVars.get(cn);
    if (c.trace) c.traceprint("eVars == " + eVars);
    if (eVars != null) {
      eVars.each(function(cv) {
        var expr = this.rows.get(cv);
        if (expr == null) {
          zRow.addVariable(cv,
                           -cn.weight * cn.strength.symbolicWeight.value,
                           this._objective,
                           this);
        } else {
          zRow.addExpression(expr,
                             -cn.weight * cn.strength.symbolicWeight.value,
                             this._objective,
                             this);
        }
        if (c.trace) c.traceprint("now eVars == " + eVars);
      }, this);
    }
    var marker = this._markerVars.get(cn);
    this._markerVars.delete(cn);
    if (marker == null) {
      throw new c.InternalError("Constraint not found in removeConstraintInternal");
    }
    if (c.trace) c.traceprint("Looking to remove var " + marker);
    if (this.rows.get(marker) == null) {
      var col = this.columns.get(marker);
      // console.log("col is:", col, "from marker:", marker);
      if (c.trace) c.traceprint("Must pivot -- columns are " + col);
      var exitVar = null;
      var minRatio = 0;
      col.each(function(v) {
        if (v.isRestricted) {
          var expr = this.rows.get(v);
          var coeff = expr.coefficientFor(marker);
          if (c.trace) c.traceprint("Marker " + marker + "'s coefficient in " + expr + " is " + coeff);
          if (coeff < 0) {
            var r = -expr.constant / coeff;
            if (
              exitVar == null ||
              r < minRatio    ||
              (c.approx(r, minRatio) && v.hashCode < exitVar.hashCode)
            ) {
              minRatio = r;
              exitVar = v;
            }
          }
        }
      }, this);
      if (exitVar == null) {
        if (c.trace) c.traceprint("exitVar is still null");
        col.each(function(v) {
          if (v.isRestricted) {
            var expr = this.rows.get(v);
            var coeff = expr.coefficientFor(marker);
            var r = expr.constant / coeff;
            if (exitVar == null || r < minRatio) {
              minRatio = r;
              exitVar = v;
            }
          }
        }, this);
      }
      if (exitVar == null) {
        if (col.size == 0) {
          this.removeColumn(marker);
        } else {
          col.escapingEach(function(v) {
            if (v != this._objective) {
              exitVar = v;
              return {brk:true};
            }
          }, this);
        }
      }
      if (exitVar != null) {
        this.pivot(marker, exitVar);
      }
    }
    if (this.rows.get(marker) != null) {
      var expr = this.removeRow(marker);
    }

    if (eVars != null) {
      eVars.each(function(v) {
        if (v != marker) { this.removeColumn(v); }
      }, this);
    }

    if (cn.isStayConstraint) {
      if (eVars != null) {
        for (var i = 0; i < this._stayPlusErrorVars.length; i++) {
          eVars.delete(this._stayPlusErrorVars[i]);
          eVars.delete(this._stayMinusErrorVars[i]);
        }
      }
    } else if (cn.isEditConstraint) {
      c.assert(eVars != null, "eVars != null");
      var cei = this._editVarMap.get(cn.variable);
      this.removeColumn(cei.editMinus);
      this._editVarMap.delete(cn.variable);
    }

    if (eVars != null) {
      this._errorVars.delete(eVars);
    }

    if (this.autoSolve) {
      this.optimize(this._objective);
      this._setExternalVariables();
    }

    return this;
  },

  reset: function() {
    if (c.trace) c.fnenterprint("reset");
    throw new c.InternalError("reset not implemented");
  },

  resolveArray: function(newEditConstants) {
    if (c.trace) c.fnenterprint("resolveArray" + newEditConstants);
    var l = newEditConstants.length
    this._editVarMap.each(function(v, cei) {
      var i = cei.index;
      if (i < l)
        this.suggestValue(v, newEditConstants[i]);
    }, this);
    this.resolve();
  },

  resolvePair: function(x /*double*/, y /*double*/) {
    this.suggestValue(this._editVarList[0].v, x);
    this.suggestValue(this._editVarList[1].v, y);
    this.resolve();
  },

  resolve: function() {
    if (c.trace) c.fnenterprint("resolve()");
    this.dualOptimize();
    this._setExternalVariables();
    this._infeasibleRows.clear();
    this._resetStayConstants();
  },

  suggestValue: function(v /*c.Variable*/, x /*double*/) {
    c.trace && console.log("suggestValue(" + v + ", " + x + ")");
    var cei = this._editVarMap.get(v);
    if (!cei) {
      throw new c.Error("suggestValue for variable " + v + ", but var is not an edit variable");
    }
    var delta = x - cei.prevEditConstant;
    cei.prevEditConstant = x;
    this.deltaEditConstant(delta, cei.editPlus, cei.editMinus);
    return this;
  },

  solve: function() {
    if (this._fNeedsSolving) {
      this.optimize(this._objective);
      this._setExternalVariables();
    }
    return this;
  },

  setEditedValue: function(v /*c.Variable*/, n /*double*/) {
    if (!(this.columnsHasKey(v) || (this.rows.get(v) != null))) {
      v.value = n;
      return this;
    }

    if (!c.approx(n, v.value)) {
      this.addEditVar(v);
      this.beginEdit();

      try {
        this.suggestValue(v, n);
      } catch (e) {
        throw new c.InternalError("Error in setEditedValue");
      }

      this.endEdit();
    }
    return this;
  },

  addVar: function(v /*c.Variable*/) {
    if (!(this.columnsHasKey(v) || (this.rows.get(v) != null))) {
      try {
        this.addStay(v);
      } catch (e /*c.RequiredFailure*/){
        throw new c.InternalError("Error in addVar -- required failure is impossible");
      }

      if (c.trace) {
        c.traceprint("added initial stay on " + v);
      }
    }
    return this;
  },

  getInternalInfo: function() {
    var retstr = tp.getInternalInfo.call(this);
    retstr += "\nSolver info:\n";
    retstr += "Stay Error Variables: ";
    retstr += this._stayPlusErrorVars.length + this._stayMinusErrorVars.length;
    retstr += " (" + this._stayPlusErrorVars.length + " +, ";
    retstr += this._stayMinusErrorVars.length + " -)\n";
    retstr += "Edit Variables: " + this._editVarMap.size;
    retstr += "\n";
    return retstr;
  },

  getDebugInfo: function() {
    return this.toString() + this.getInternalInfo() + "\n";
  },

  toString: function() {
    var bstr = tp.getInternalInfo.call(this);
    bstr += "\n_stayPlusErrorVars: ";
    bstr += '[' + this._stayPlusErrorVars + ']';
    bstr += "\n_stayMinusErrorVars: ";
    bstr += '[' + this._stayMinusErrorVars + ']';
    bstr += "\n";
    bstr += "_editVarMap:\n" + this._editVarMap;
    bstr += "\n";
    return bstr;
  },

  getConstraintMap: function() {
    return this._markerVars;
  },

  addWithArtificialVariable: function(expr /*c.Expression*/) {
    if (c.trace) c.fnenterprint("addWithArtificialVariable: " + expr);
    var av = new c.SlackVariable({
      value: ++this._artificialCounter,
      prefix: "a"
    });
    var az = new c.ObjectiveVariable({ name: "az" });
    var azRow = /* c.Expression */expr.clone();
    if (c.trace) c.traceprint("before addRows:\n" + this);
    this.addRow(az, azRow);
    this.addRow(av, expr);
    if (c.trace) c.traceprint("after addRows:\n" + this);
    this.optimize(az);
    var azTableauRow = this.rows.get(az);
    if (c.trace) c.traceprint("azTableauRow.constant == " + azTableauRow.constant);
    if (!c.approx(azTableauRow.constant, 0)) {
      this.removeRow(az);
      this.removeColumn(av);
      throw new c.RequiredFailure();
    }
    var e = this.rows.get(av);
    if (e != null) {
      if (e.isConstant) {
        this.removeRow(av);
        this.removeRow(az);
        return;
      }
      var entryVar = e.anyPivotableVariable();
      this.pivot(entryVar, av);
    }
    c.assert(this.rows.get(av) == null, "rowExpression(av) == null");
    this.removeColumn(av);
    this.removeRow(az);
  },

  tryAddingDirectly: function(expr /*c.Expression*/) {
    c.trace && c.fnenterprint("tryAddingDirectly: " + expr);
    var subject = this.chooseSubject(expr);
    if (subject == null) {
      c.trace && c.fnexitprint("returning false");
      return false;
    }
    expr.newSubject(subject);
    if (this.columnsHasKey(subject)) {
      this.substituteOut(subject, expr);
    }
    this.addRow(subject, expr);
    c.trace && c.fnexitprint("returning true");
    return true;
  },

  chooseSubject: function(expr /*c.Expression*/) {
    if (c.trace) c.fnenterprint("chooseSubject: " + expr);
    var subject = null;
    var foundUnrestricted = false;
    var foundNewRestricted = false;
    var terms = expr.terms;
    var rv = terms.escapingEach(function(v, c) {
      if (foundUnrestricted) {
        if (!v.isRestricted) {
          if (!this.columnsHasKey(v)) {
            return {retval: v};
          }
        }
      } else {
        if (v.isRestricted) {
          if (!foundNewRestricted && !v.isDummy && c < 0) {
            var col = this.columns.get(v);
            if (col == null || (col.size == 1 && this.columnsHasKey(this._objective))) {
              subject = v;
              foundNewRestricted = true;
            }
          }
        } else {
          subject = v;
          foundUnrestricted = true;
        }
      }
    }, this);
    if (rv && rv.retval !== undefined) return rv.retval;

    if (subject != null)
      return subject;

    var coeff = 0;

    // subject is nil.
    // Make one last check -- if all of the variables in expr are dummy
    // variables, then we can pick a dummy variable as the subject
    var rv = terms.escapingEach(function(v,c) {
      if (!v.isDummy)  {
        return {retval:null};
      }
      if (!this.columnsHasKey(v)) {
        subject = v;
        coeff = c;
      }
    }, this);
    if (rv && rv.retval !== undefined) return rv.retval;

    if (!c.approx(expr.constant, 0)) {
      throw new c.RequiredFailure();
    }
    if (coeff > 0) {
      expr.multiplyMe(-1);
    }
    return subject;
  },

  deltaEditConstant: function(delta /*double*/,
                              plusErrorVar /*c.AbstractVariable*/,
                              minusErrorVar /*c.AbstractVariable*/) {
    if (c.trace)
      c.fnenterprint("deltaEditConstant :" + delta + ", " + plusErrorVar + ", " + minusErrorVar);

    var exprPlus = this.rows.get(plusErrorVar);
    if (exprPlus != null) {
      exprPlus.constant += delta;
      if (exprPlus.constant < 0) {
        this._infeasibleRows.add(plusErrorVar);
      }
      return;
    }
    var exprMinus = this.rows.get(minusErrorVar);
    if (exprMinus != null) {
      exprMinus.constant += -delta;
      if (exprMinus.constant < 0) {
        this._infeasibleRows.add(minusErrorVar);
      }
      return;
    }
    var columnVars = this.columns.get(minusErrorVar);
    if (!columnVars) {
      console.log("columnVars is null -- tableau is:\n" + this);
    }
    columnVars.each(function(basicVar) {
      var expr = this.rows.get(basicVar);
      var c = expr.coefficientFor(minusErrorVar);
      expr.constant += (c * delta);
      if (basicVar.isRestricted && expr.constant < 0) {
        this._infeasibleRows.add(basicVar);
      }
    }, this);
  },

  // We have set new values for the constants in the edit constraints.
  // Re-Optimize using the dual simplex algorithm.
  dualOptimize: function() {
    if (c.trace) c.fnenterprint("dualOptimize:");
    var zRow = this.rows.get(this._objective);
    // need to handle infeasible rows
    while (this._infeasibleRows.size) {
      var exitVar = this._infeasibleRows.values()[0];
      this._infeasibleRows.delete(exitVar);
      var entryVar = null;
      var expr = this.rows.get(exitVar);
      // exitVar might have become basic after some other pivoting
      // so allow for the case of its not being there any longer
      if (expr) {
        if (expr.constant < 0) {
          var ratio = Number.MAX_VALUE;
          var r;
          var terms = expr.terms;
          terms.each(function(v, cd) {
            if (cd > 0 && v.isPivotable) {
              var zc = zRow.coefficientFor(v);
              r = zc / cd;
              if (r < ratio ||
                  (c.approx(r, ratio) && v.hashCode < entryVar.hashCode)
              ) {
                entryVar = v;
                ratio = r;
              }
            }
          });
          if (ratio == Number.MAX_VALUE) {
            throw new c.InternalError("ratio == nil (MAX_VALUE) in dualOptimize");
          }
          this.pivot(entryVar, exitVar);
        }
      }
    }
  },

  // Make a new linear Expression representing the constraint cn,
  // replacing any basic variables with their defining expressions.
  // Normalize if necessary so that the Constant is non-negative.  If
  // the constraint is non-required give its error variables an
  // appropriate weight in the objective function.
  newExpression: function(cn /*c.Constraint*/, /** outputs to **/
                          eplus_eminus /*Vector*/, prevEConstant /*ClDouble*/) {
    if (c.trace) {
      c.fnenterprint("newExpression: " + cn);
      c.traceprint("cn.isInequality == " + cn.isInequality);
      c.traceprint("cn.required == " + cn.required);
    }

    var cnExpr = cn.expression;
    var expr = new c.Expression(cnExpr.constant);
    var slackVar = new c.SlackVariable();
    var dummyVar = new c.DummyVariable();
    var eminus = new c.SlackVariable();
    var eplus = new c.SlackVariable();
    var cnTerms = cnExpr.terms;
    // console.log(cnTerms.size);

    cnTerms.each(function(v, c) {
      var e = this.rows.get(v);
      if (!e) {
        expr.addVariable(v, c);
      } else {
        expr.addExpression(e, c);
      }
    }, this);

    if (cn.isInequality) {
      // cn is an inequality, so Add a slack variable. The original constraint
      // is expr>=0, so that the resulting equality is expr-slackVar=0. If cn is
      // also non-required Add a negative error variable, giving:
      //
      //    expr - slackVar = -errorVar
      //
      // in other words:
      //
      //    expr - slackVar + errorVar = 0
      //
      // Since both of these variables are newly created we can just Add
      // them to the Expression (they can't be basic).
      c.trace && c.traceprint("Inequality, adding slack");
      ++this._slackCounter;
      slackVar = new c.SlackVariable({
        value: this._slackCounter,
        prefix: "s"
      });
      expr.setVariable(slackVar, -1);

      this._markerVars.set(cn, slackVar);
      if (!cn.required) {
        ++this._slackCounter;
        eminus = new c.SlackVariable({
          value: this._slackCounter,
          prefix: "em"
        });
        expr.setVariable(eminus, 1);
        var zRow = this.rows.get(this._objective);
        zRow.setVariable(eminus, cn.strength.symbolicWeight.value * cn.weight);
        this.insertErrorVar(cn, eminus);
        this.noteAddedVariable(eminus, this._objective);
      }
    } else {
      if (cn.required) {
        c.trace && c.traceprint("Equality, required");
        // Add a dummy variable to the Expression to serve as a marker for this
        // constraint.  The dummy variable is never allowed to enter the basis
        // when pivoting.
        ++this._dummyCounter;
        dummyVar = new c.DummyVariable({
          value: this._dummyCounter,
          prefix: "d"
        });
        eplus_eminus[0] = dummyVar;
        eplus_eminus[1] = dummyVar;
        prevEConstant[0] = cnExpr.constant;
        expr.setVariable(dummyVar, 1);
        this._markerVars.set(cn, dummyVar);
        if (c.trace) c.traceprint("Adding dummyVar == d" + this._dummyCounter);
      } else {

        // cn is a non-required equality. Add a positive and a negative error
        // variable, making the resulting constraint
        //       expr = eplus - eminus
        // in other words:
        //       expr - eplus + eminus = 0
        if (c.trace) c.traceprint("Equality, not required");
        ++this._slackCounter;
        eplus = new c.SlackVariable({
          value: this._slackCounter,
          prefix: "ep"
        });
        eminus = new c.SlackVariable({
          value: this._slackCounter,
          prefix: "em"
        });
        expr.setVariable(eplus, -1);
        expr.setVariable(eminus, 1);
        this._markerVars.set(cn, eplus);
        var zRow = this.rows.get(this._objective);
        if (c.trace) console.log(zRow);
        var swCoeff = cn.strength.symbolicWeight.value * cn.weight;
        if (swCoeff == 0) {
          if (c.trace) c.traceprint("cn == " + cn);
          if (c.trace) c.traceprint("adding " + eplus + " and " + eminus + " with swCoeff == " + swCoeff);
        }
        zRow.setVariable(eplus, swCoeff);
        this.noteAddedVariable(eplus, this._objective);
        zRow.setVariable(eminus, swCoeff);
        this.noteAddedVariable(eminus, this._objective);

        this.insertErrorVar(cn, eminus);
        this.insertErrorVar(cn, eplus);

        if (cn.isStayConstraint) {
          this._stayPlusErrorVars.push(eplus);
          this._stayMinusErrorVars.push(eminus);
        } else if (cn.isEditConstraint) {
          eplus_eminus[0] = eplus;
          eplus_eminus[1] = eminus;
          prevEConstant[0] = cnExpr.constant;
        }
      }
    }
    // the Constant in the Expression should be non-negative. If necessary
    // normalize the Expression by multiplying by -1
    if (expr.constant < 0) expr.multiplyMe(-1);
    if (c.trace) c.fnexitprint("returning " + expr);
    return expr;
  },

  // Minimize the value of the objective.  (The tableau should already be
  // feasible.)
  optimize: function(zVar /*c.ObjectiveVariable*/) {
    if (c.trace) c.fnenterprint("optimize: " + zVar);
    if (c.trace) c.traceprint(this.toString());
    this._optimizeCount++;

    var zRow = this.rows.get(zVar);
    c.assert(zRow != null, "zRow != null");
    var entryVar = null;
    var exitVar = null;
    var objectiveCoeff, terms;

    while (true) {
      objectiveCoeff = 0;
      terms = zRow.terms;

      // Find the most negative coefficient in the objective function (ignoring
      // the non-pivotable dummy variables). If all coefficients are positive
      // we're done
      terms.escapingEach(function(v, c) {
        if (v.isPivotable && c < objectiveCoeff) {
          objectiveCoeff = c;
          entryVar = v;
          // Break on success
          return { brk: 1 };
        }
      }, this);

      if (objectiveCoeff >= -epsilon)
        return;

      c.trace && console.log("entryVar:", entryVar,
                             "objectiveCoeff:", objectiveCoeff);

      // choose which variable to move out of the basis
      // Only consider pivotable basic variables
      // (i.e. restricted, non-dummy variables)
      var minRatio = Number.MAX_VALUE;
      var columnVars = this.columns.get(entryVar);
      var r = 0;

      columnVars.each(function(v) {
        if (c.trace) c.traceprint("Checking " + v);
        if (v.isPivotable) {
          var expr = this.rows.get(v);
          var coeff = expr.coefficientFor(entryVar);
          if (c.trace) c.traceprint("pivotable, coeff = " + coeff);
          // only consider negative coefficients
          if (coeff < 0) {
            r = -expr.constant / coeff;
            // Bland's anti-cycling rule:
            // if multiple variables are about the same,
            // always pick the lowest via some total
            // ordering -- I use their addresses in memory
            //    if (r < minRatio ||
            //              (c.approx(r, minRatio) &&
            //               v.get_pclv() < exitVar.get_pclv()))
            if (r < minRatio ||
                (c.approx(r, minRatio) &&
                 v.hashCode < exitVar.hashCode)
            ) {
              minRatio = r;
              exitVar = v;
            }
          }
        }
      }, this);

      // If minRatio is still nil at this point, it means that the
      // objective function is unbounded, i.e. it can become
      // arbitrarily negative.  This should never happen in this
      // application.
      if (minRatio == Number.MAX_VALUE) {
        throw new c.InternalError("Objective function is unbounded in optimize");
      }

      // console.time("SimplexSolver::optimize pivot()");
      this.pivot(entryVar, exitVar);
      // console.timeEnd("SimplexSolver::optimize pivot()");

      if (c.trace) c.traceprint(this.toString());
    }
  },

  // Do a Pivot.  Move entryVar into the basis (i.e. make it a basic variable),
  // and move exitVar out of the basis (i.e., make it a parametric variable)
  pivot: function(entryVar /*c.AbstractVariable*/, exitVar /*c.AbstractVariable*/) {
    c.trace && console.log("pivot: ", entryVar, exitVar);
    var time = false;

    time && console.time(" SimplexSolver::pivot");

    // the entryVar might be non-pivotable if we're doing a RemoveConstraint --
    // otherwise it should be a pivotable variable -- enforced at call sites,
    // hopefully
    if (entryVar == null) {
      console.warn("pivot: entryVar == null");
    }

    if (exitVar == null) {
      console.warn("pivot: exitVar == null");
    }
    // console.log("SimplexSolver::pivot(", entryVar, exitVar, ")")

    // expr is the Expression for the exit variable (about to leave the basis) --
    // so that the old tableau includes the equation:
    //   exitVar = expr
    time && console.time("  removeRow");
    var expr = this.removeRow(exitVar);
    time && console.timeEnd("  removeRow");

    // Compute an Expression for the entry variable.  Since expr has
    // been deleted from the tableau we can destructively modify it to
    // build this Expression.
    time && console.time("  changeSubject");
    expr.changeSubject(exitVar, entryVar);
    time && console.timeEnd("  changeSubject");

    time && console.time("  substituteOut");
    this.substituteOut(entryVar, expr);
    time && console.timeEnd("  substituteOut");
    /*
    if (entryVar.isExternal) {
      // entry var is no longer a parametric variable since we're moving
      // it into the basis
      console.log("entryVar is external!");
      this._externalParametricVars.delete(entryVar);
    }
    */

    time && console.time("  addRow")
    this.addRow(entryVar, expr);
    time && console.timeEnd("  addRow")

    time && console.timeEnd(" SimplexSolver::pivot");
  },

  // Each of the non-required stays will be represented by an equation
  // of the form
  //     v = c + eplus - eminus
  // where v is the variable with the stay, c is the previous value of
  // v, and eplus and eminus are slack variables that hold the error
  // in satisfying the stay constraint.  We are about to change
  // something, and we want to fix the constants in the equations
  // representing the stays.  If both eplus and eminus are nonbasic
  // they have value 0 in the current solution, meaning the previous
  // stay was exactly satisfied.  In this case nothing needs to be
  // changed.  Otherwise one of them is basic, and the other must
  // occur only in the Expression for that basic error variable.
  // Reset the Constant in this Expression to 0.
  _resetStayConstants: function() {
    c.trace && console.log("_resetStayConstants");
    for (var i = 0; i < this._stayPlusErrorVars.length; i++) {
      var expr = this.rows.get(/* c.AbstractVariable */this._stayPlusErrorVars[i]);
      if (expr == null)
        expr = this.rows.get(/* c.AbstractVariable */this._stayMinusErrorVars[i]);
      if (expr != null)
        expr.constant = 0;
    }
  },

  _setExternalVariables: function() {
    if (c.trace) c.fnenterprint("_setExternalVariables:");
    if (c.trace) c.traceprint(this.toString());
    var changed = {};

    // console.log("this._externalParametricVars:", this._externalParametricVars);
    this._externalParametricVars.each(function(v) {
      if (this.rows.get(v) != null) {
        if (c.trace)
          console.log("Error: variable" + v + " in _externalParametricVars is basic");
      } else {
        v.value = 0;
        changed[v.name] = 0;
      }
    }, this);
    // console.log("this._externalRows:", this._externalRows);
    this._externalRows.each(function(v) {
      var expr = this.rows.get(v);
      if (v.value != expr.constant) {
        // console.log(v.toString(), v.value, expr.constant);
        v.value = expr.constant;
        changed[v.name] = expr.constant;
      }
      // if (c.trace) console.log("v == " + v);
      // if (c.trace) console.log("expr == " + expr);
    }, this);
    this._changed = changed;
    this._fNeedsSolving = false;
    this._informCallbacks();
    this.onsolved();
  },

  onsolved: function() {
    // Lifecycle stub. Here for dirty, dirty monkey patching.
  },

  _informCallbacks: function() {
    if(!this._callbacks) return;

    var changed = this._changed;
    this._callbacks.forEach(function(fn) {
      fn(changed);
    });
  },

  _addCallback: function(fn) {
    (this._callbacks || (this._callbacks = [])).push(fn);
  },

  insertErrorVar: function(cn /*c.Constraint*/, aVar /*c.AbstractVariable*/) {
    if (c.trace) c.fnenterprint("insertErrorVar:" + cn + ", " + aVar);
    var constraintSet = /* Set */this._errorVars.get(aVar);
    if (!constraintSet) {
      constraintSet = new c.HashSet();
      this._errorVars.set(cn, constraintSet);
    }
    constraintSet.add(aVar);
  },
});
})(this["c"]||module.parent.exports||{});

});
require.register("slightlyoff-cassowary.js/src/Timer.js", function(exports, require, module){
// Copyright (C) 1998-2000 Greg J. Badros
// Use of this source code is governed by http://www.apache.org/licenses/LICENSE-2.0
//
// Parts Copyright (C) 2011, Alex Russell (slightlyoff@chromium.org)

(function(c) {
"use strict";

c.Timer = c.inherit({
  initialize: function() {
    this.isRunning = false;
    this._elapsedMs = 0;
  },

  start: function() {
    this.isRunning = true;
    this._startReading = new Date();
    return this;
  },

  stop: function() {
    this.isRunning = false;
    this._elapsedMs += (new Date()) - this._startReading;
    return this;
  },

  reset: function() {
    this.isRunning = false;
    this._elapsedMs = 0;
    return this;
  },

  elapsedTime : function() {
    if (!this.isRunning) {
      return this._elapsedMs / 1000;
    } else {
      return (this._elapsedMs + (new Date() - this._startReading)) / 1000;
    }
  },
});

})(this["c"]||module.parent.exports||{});

});
require.register("slightlyoff-cassowary.js/src/parser/parser.js", function(exports, require, module){
this.c.parser = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "start": parse_start,
        "Statement": parse_Statement,
        "SourceCharacter": parse_SourceCharacter,
        "IdentifierStart": parse_IdentifierStart,
        "WhiteSpace": parse_WhiteSpace,
        "LineTerminator": parse_LineTerminator,
        "LineTerminatorSequence": parse_LineTerminatorSequence,
        "EOS": parse_EOS,
        "EOF": parse_EOF,
        "Comment": parse_Comment,
        "MultiLineComment": parse_MultiLineComment,
        "MultiLineCommentNoLineTerminator": parse_MultiLineCommentNoLineTerminator,
        "SingleLineComment": parse_SingleLineComment,
        "_": parse__,
        "__": parse___,
        "Literal": parse_Literal,
        "Integer": parse_Integer,
        "Real": parse_Real,
        "SignedInteger": parse_SignedInteger,
        "Identifier": parse_Identifier,
        "IdentifierName": parse_IdentifierName,
        "PrimaryExpression": parse_PrimaryExpression,
        "UnaryExpression": parse_UnaryExpression,
        "UnaryOperator": parse_UnaryOperator,
        "MultiplicativeExpression": parse_MultiplicativeExpression,
        "MultiplicativeOperator": parse_MultiplicativeOperator,
        "AdditiveExpression": parse_AdditiveExpression,
        "AdditiveOperator": parse_AdditiveOperator,
        "InequalityExpression": parse_InequalityExpression,
        "InequalityOperator": parse_InequalityOperator,
        "LinearExpression": parse_LinearExpression
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "start";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_start() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse___();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_Statement();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_Statement();
          }
          if (result1 !== null) {
            result2 = parse___();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, statements) { return statements; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Statement() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_LinearExpression();
        if (result0 !== null) {
          result1 = parse_EOS();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, expression) { return expression; })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SourceCharacter() {
        var result0;
        
        if (input.length > pos) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("any character");
          }
        }
        return result0;
      }
      
      function parse_IdentifierStart() {
        var result0;
        
        if (/^[a-zA-Z]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z]");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 36) {
            result0 = "$";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"$\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 95) {
              result0 = "_";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"_\"");
              }
            }
          }
        }
        return result0;
      }
      
      function parse_WhiteSpace() {
        var result0;
        
        reportFailures++;
        if (/^[\t\x0B\f \xA0\uFEFF]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\t\\x0B\\f \\xA0\\uFEFF]");
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("whitespace");
        }
        return result0;
      }
      
      function parse_LineTerminator() {
        var result0;
        
        if (/^[\n\r\u2028\u2029]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\n\\r\\u2028\\u2029]");
          }
        }
        return result0;
      }
      
      function parse_LineTerminatorSequence() {
        var result0;
        
        reportFailures++;
        if (input.charCodeAt(pos) === 10) {
          result0 = "\n";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\n\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 2) === "\r\n") {
            result0 = "\r\n";
            pos += 2;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\r\\n\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 13) {
              result0 = "\r";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\r\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 8232) {
                result0 = "\u2028";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\u2028\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 8233) {
                  result0 = "\u2029";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\u2029\"");
                  }
                }
              }
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("end of line");
        }
        return result0;
      }
      
      function parse_EOS() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = parse___();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 59) {
            result1 = ";";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\";\"");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          result0 = parse__();
          if (result0 !== null) {
            result1 = parse_LineTerminatorSequence();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            result0 = parse___();
            if (result0 !== null) {
              result1 = parse_EOF();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          }
        }
        return result0;
      }
      
      function parse_EOF() {
        var result0;
        var pos0;
        
        pos0 = pos;
        reportFailures++;
        if (input.length > pos) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("any character");
          }
        }
        reportFailures--;
        if (result0 === null) {
          result0 = "";
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Comment() {
        var result0;
        
        reportFailures++;
        result0 = parse_MultiLineComment();
        if (result0 === null) {
          result0 = parse_SingleLineComment();
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("comment");
        }
        return result0;
      }
      
      function parse_MultiLineComment() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "/*") {
          result0 = "/*";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/*\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          pos2 = pos;
          reportFailures++;
          if (input.substr(pos, 2) === "*/") {
            result2 = "*/";
            pos += 2;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\"*/\"");
            }
          }
          reportFailures--;
          if (result2 === null) {
            result2 = "";
          } else {
            result2 = null;
            pos = pos2;
          }
          if (result2 !== null) {
            result3 = parse_SourceCharacter();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            reportFailures--;
            if (result2 === null) {
              result2 = "";
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              result3 = parse_SourceCharacter();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_MultiLineCommentNoLineTerminator() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "/*") {
          result0 = "/*";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/*\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          pos2 = pos;
          reportFailures++;
          if (input.substr(pos, 2) === "*/") {
            result2 = "*/";
            pos += 2;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\"*/\"");
            }
          }
          if (result2 === null) {
            result2 = parse_LineTerminator();
          }
          reportFailures--;
          if (result2 === null) {
            result2 = "";
          } else {
            result2 = null;
            pos = pos2;
          }
          if (result2 !== null) {
            result3 = parse_SourceCharacter();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            if (result2 === null) {
              result2 = parse_LineTerminator();
            }
            reportFailures--;
            if (result2 === null) {
              result2 = "";
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              result3 = parse_SourceCharacter();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SingleLineComment() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "//") {
          result0 = "//";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"//\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          pos2 = pos;
          reportFailures++;
          result2 = parse_LineTerminator();
          reportFailures--;
          if (result2 === null) {
            result2 = "";
          } else {
            result2 = null;
            pos = pos2;
          }
          if (result2 !== null) {
            result3 = parse_SourceCharacter();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            result2 = parse_LineTerminator();
            reportFailures--;
            if (result2 === null) {
              result2 = "";
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              result3 = parse_SourceCharacter();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result2 = parse_LineTerminator();
            if (result2 === null) {
              result2 = parse_EOF();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse__() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_WhiteSpace();
        if (result1 === null) {
          result1 = parse_MultiLineCommentNoLineTerminator();
          if (result1 === null) {
            result1 = parse_SingleLineComment();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_WhiteSpace();
          if (result1 === null) {
            result1 = parse_MultiLineCommentNoLineTerminator();
            if (result1 === null) {
              result1 = parse_SingleLineComment();
            }
          }
        }
        return result0;
      }
      
      function parse___() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_WhiteSpace();
        if (result1 === null) {
          result1 = parse_LineTerminatorSequence();
          if (result1 === null) {
            result1 = parse_Comment();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_WhiteSpace();
          if (result1 === null) {
            result1 = parse_LineTerminatorSequence();
            if (result1 === null) {
              result1 = parse_Comment();
            }
          }
        }
        return result0;
      }
      
      function parse_Literal() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_Real();
        if (result0 === null) {
          result0 = parse_Integer();
        }
        if (result0 !== null) {
          result0 = (function(offset, val) {
            return {
              type: "NumericLiteral",
              value: val
            }
          })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Integer() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (/^[0-9]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[0-9]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, digits) {
            return parseInt(digits.join(""));
          })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Real() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_Integer();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 46) {
            result1 = ".";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_Integer();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, digits) {
            return parseFloat(digits.join(""));
          })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SignedInteger() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (/^[\-+]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\-+]");
          }
        }
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          if (/^[0-9]/.test(input.charAt(pos))) {
            result2 = input.charAt(pos);
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[0-9]");
            }
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              if (/^[0-9]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Identifier() {
        var result0;
        var pos0;
        
        reportFailures++;
        pos0 = pos;
        result0 = parse_IdentifierName();
        if (result0 !== null) {
          result0 = (function(offset, name) { return name; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("identifier");
        }
        return result0;
      }
      
      function parse_IdentifierName() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_IdentifierStart();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_IdentifierStart();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_IdentifierStart();
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, start, parts) {
              return start + parts.join("");
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("identifier");
        }
        return result0;
      }
      
      function parse_PrimaryExpression() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_Identifier();
        if (result0 !== null) {
          result0 = (function(offset, name) { return { type: "Variable", name: name }; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          result0 = parse_Literal();
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            if (input.charCodeAt(pos) === 40) {
              result0 = "(";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"(\"");
              }
            }
            if (result0 !== null) {
              result1 = parse___();
              if (result1 !== null) {
                result2 = parse_LinearExpression();
                if (result2 !== null) {
                  result3 = parse___();
                  if (result3 !== null) {
                    if (input.charCodeAt(pos) === 41) {
                      result4 = ")";
                      pos++;
                    } else {
                      result4 = null;
                      if (reportFailures === 0) {
                        matchFailed("\")\"");
                      }
                    }
                    if (result4 !== null) {
                      result0 = [result0, result1, result2, result3, result4];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, expression) { return expression; })(pos0, result0[2]);
            }
            if (result0 === null) {
              pos = pos0;
            }
          }
        }
        return result0;
      }
      
      function parse_UnaryExpression() {
        var result0, result1, result2;
        var pos0, pos1;
        
        result0 = parse_PrimaryExpression();
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_UnaryOperator();
          if (result0 !== null) {
            result1 = parse___();
            if (result1 !== null) {
              result2 = parse_UnaryExpression();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, operator, expression) {
                return {
                  type:       "UnaryExpression",
                  operator:   operator,
                  expression: expression
                };
              })(pos0, result0[0], result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_UnaryOperator() {
        var result0;
        
        if (input.charCodeAt(pos) === 43) {
          result0 = "+";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"+\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 45) {
            result0 = "-";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 33) {
              result0 = "!";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"!\"");
              }
            }
          }
        }
        return result0;
      }
      
      function parse_MultiplicativeExpression() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_UnaryExpression();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse___();
          if (result2 !== null) {
            result3 = parse_MultiplicativeOperator();
            if (result3 !== null) {
              result4 = parse___();
              if (result4 !== null) {
                result5 = parse_UnaryExpression();
                if (result5 !== null) {
                  result2 = [result2, result3, result4, result5];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse___();
            if (result2 !== null) {
              result3 = parse_MultiplicativeOperator();
              if (result3 !== null) {
                result4 = parse___();
                if (result4 !== null) {
                  result5 = parse_UnaryExpression();
                  if (result5 !== null) {
                    result2 = [result2, result3, result4, result5];
                  } else {
                    result2 = null;
                    pos = pos2;
                  }
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, head, tail) {
              var result = head;
              for (var i = 0; i < tail.length; i++) {
                result = {
                  type:     "MultiplicativeExpression",
                  operator: tail[i][1],
                  left:     result,
                  right:    tail[i][3]
                };
              }
              return result;
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_MultiplicativeOperator() {
        var result0;
        
        if (input.charCodeAt(pos) === 42) {
          result0 = "*";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"*\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 47) {
            result0 = "/";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"/\"");
            }
          }
        }
        return result0;
      }
      
      function parse_AdditiveExpression() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_MultiplicativeExpression();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse___();
          if (result2 !== null) {
            result3 = parse_AdditiveOperator();
            if (result3 !== null) {
              result4 = parse___();
              if (result4 !== null) {
                result5 = parse_MultiplicativeExpression();
                if (result5 !== null) {
                  result2 = [result2, result3, result4, result5];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse___();
            if (result2 !== null) {
              result3 = parse_AdditiveOperator();
              if (result3 !== null) {
                result4 = parse___();
                if (result4 !== null) {
                  result5 = parse_MultiplicativeExpression();
                  if (result5 !== null) {
                    result2 = [result2, result3, result4, result5];
                  } else {
                    result2 = null;
                    pos = pos2;
                  }
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, head, tail) {
              var result = head;
              for (var i = 0; i < tail.length; i++) {
                result = {
                  type:     "AdditiveExpression",
                  operator: tail[i][1],
                  left:     result,
                  right:    tail[i][3]
                };
              }
              return result;
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_AdditiveOperator() {
        var result0;
        
        if (input.charCodeAt(pos) === 43) {
          result0 = "+";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"+\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 45) {
            result0 = "-";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
        }
        return result0;
      }
      
      function parse_InequalityExpression() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_AdditiveExpression();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse___();
          if (result2 !== null) {
            result3 = parse_InequalityOperator();
            if (result3 !== null) {
              result4 = parse___();
              if (result4 !== null) {
                result5 = parse_AdditiveExpression();
                if (result5 !== null) {
                  result2 = [result2, result3, result4, result5];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse___();
            if (result2 !== null) {
              result3 = parse_InequalityOperator();
              if (result3 !== null) {
                result4 = parse___();
                if (result4 !== null) {
                  result5 = parse_AdditiveExpression();
                  if (result5 !== null) {
                    result2 = [result2, result3, result4, result5];
                  } else {
                    result2 = null;
                    pos = pos2;
                  }
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, head, tail) {
              var result = head;
              for (var i = 0; i < tail.length; i++) {
                result = {
                  type:     "Inequality",
                  operator: tail[i][1],
                  left:     result,
                  right:    tail[i][3]
                };
              }
              return result;
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_InequalityOperator() {
        var result0;
        
        if (input.substr(pos, 2) === "<=") {
          result0 = "<=";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"<=\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 2) === ">=") {
            result0 = ">=";
            pos += 2;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\">=\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 60) {
              result0 = "<";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"<\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 62) {
                result0 = ">";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\">\"");
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_LinearExpression() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_InequalityExpression();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse___();
          if (result2 !== null) {
            if (input.substr(pos, 2) === "==") {
              result3 = "==";
              pos += 2;
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("\"==\"");
              }
            }
            if (result3 !== null) {
              result4 = parse___();
              if (result4 !== null) {
                result5 = parse_InequalityExpression();
                if (result5 !== null) {
                  result2 = [result2, result3, result4, result5];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse___();
            if (result2 !== null) {
              if (input.substr(pos, 2) === "==") {
                result3 = "==";
                pos += 2;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"==\"");
                }
              }
              if (result3 !== null) {
                result4 = parse___();
                if (result4 !== null) {
                  result5 = parse_InequalityExpression();
                  if (result5 !== null) {
                    result2 = [result2, result3, result4, result5];
                  } else {
                    result2 = null;
                    pos = pos2;
                  }
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, head, tail) {
              var result = head;
              for (var i = 0; i < tail.length; i++) {
                result = {
                  type:     "Equality",
                  operator: tail[i][1],
                  left:     result,
                  right:    tail[i][3]
                };
              }
              return result;
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();

});
require.register("slightlyoff-cassowary.js/src/parser/api.js", function(exports, require, module){
// Copyright (C) 2013, Alex Russell <slightlyoff@chromium.org>
// Use of this source code is governed by
//    http://www.apache.org/licenses/LICENSE-2.0

(function(c){
"use strict";

var solver = new c.SimplexSolver();
var vars = {};
var exprs = {};

var weak = c.Strength.weak;
var medium = c.Strength.medium;
var strong = c.Strength.strong;
var required = c.Strength.required;

var _c = function(expr) {
  if (exprs[expr]) {
    return exprs[expr];
  }
  switch(expr.type) {
    case "Inequality":
      var op = (expr.operator == "<=") ? c.LEQ : c.GEQ;
      var i = new c.Inequality(_c(expr.left), op, _c(expr.right), weak);
      solver.addConstraint(i);
      return i;
    case "Equality":
      var i = new c.Equation(_c(expr.left), _c(expr.right), weak);
      solver.addConstraint(i);
      return i;
    case "MultiplicativeExpression":
      var i = c.times(_c(expr.left), _c(expr.right));
      solver.addConstraint(i);
      return i;
    case "AdditiveExpression":
      if (expr.operator == "+") {
        return c.plus(_c(expr.left), _c(expr.right));
      } else {
        return c.minus(_c(expr.left), _c(expr.right));
      }
    case "NumericLiteral":
      return new c.Expression(expr.value);
    case "Variable":
      // console.log(expr);
      if(!vars[expr.name]) {
        vars[expr.name] = new c.Variable({ name: expr.name });
      }
      return vars[expr.name];
    case "UnaryExpression":
      console.log("UnaryExpression...WTF?");
      break;
  }
};

var compile = function(expressions) {
  return expressions.map(_c);
};

// Global API entrypoint
c._api = function() {
  var args = Array.prototype.slice.call(arguments);
  if (args.length == 1) {
    if(typeof args[0] == "string") {
      // Parse and execute it
      var r = c.parser.parse(args[0]);
      return compile(r);
    } else if(typeof args[0] == "function") {
      solver._addCallback(args[0]);
    }
  }
};

})(this["c"]||module.parent.exports||{});

});
require.register("the-gss-engine/lib/GSS.js", function(exports, require, module){
var GSS, LOG_PASS, TIME, TIME_END, key, styleQuery, val, _ref, _scopesToLoad;

require("customevent-polyfill");

require("cassowary");

if (window.GSS) {
  throw new Error("Only one GSS object per window");
}

GSS = function(o) {
  var engine;
  if (o === document || o === window) {
    return GSS.engines.root;
  }
  if (o.tagName) {
    engine = GSS.get.engine(o);
    if (engine) {
      return engine;
    }
    return new GSS.Engine({
      scope: o
    });
  } else if (o !== null && typeof o === 'object') {
    if (o.scope) {
      engine = GSS.get.engine(o.scope);
      if (engine) {
        return engine;
      }
    }
    return new GSS.Engine(o);
  } else {
    throw new Error("");
  }
};

GSS.config = {
  resizeDebounce: 32,
  observe: true,
  debug: false,
  warn: false,
  perf: false,
  scoped: true,
  roundBeforeSet: false,
  processBeforeSet: null,
  useOffsetParent: true,
  useWorker: !!window.Worker,
  workerURL: '../browser/gss-engine/worker/gss-solver.js'
};

if (typeof GSS_CONFIG !== "undefined" && GSS_CONFIG !== null) {
  for (key in GSS_CONFIG) {
    val = GSS_CONFIG[key];
    GSS.config[key] = val;
  }
}

GSS.deblog = function() {
  if (GSS.config.debug) {
    return console.log.apply(console, arguments);
  }
};

GSS.warn = function() {
  if (GSS.config.warn) {
    return console.warn.apply(console, arguments);
  }
};

LOG_PASS = function(pass, bg) {
  if (bg == null) {
    bg = "green";
  }
  return GSS.deblog("%c" + pass, "color:white; padding:2px; font-size:14px; background:" + bg + ";");
};

TIME = function() {
  if (GSS.config.perf) {
    return console.time.apply(console, arguments);
  }
};

TIME_END = function() {
  if (GSS.config.perf) {
    return console.timeEnd.apply(console, arguments);
  }
};

window.GSS = GSS;

GSS._ = require("./_.js");

GSS.EventTrigger = require("./EventTrigger.js");

GSS.Getter = require("./dom/Getter.js");

GSS.Commander = require("./Commander.js");

GSS.Query = require("./dom/Query.js");

GSS.Thread = require("./Thread.js");

GSS.Engine = require("./Engine.js");

GSS.View = require("./dom/View.js");

_ref = require("./dom/IdMixin.js");
for (key in _ref) {
  val = _ref[key];
  if (GSS[key]) {
    throw new Error("IdMixin key clash: " + key);
  }
  GSS[key] = val;
}

GSS.EventTrigger.make(GSS);

GSS.get = new GSS.Getter();

GSS.observer = require("./dom/Observer.js");

GSS.boot = function() {
  return GSS({
    scope: GSS.Getter.getRootScope(),
    is_root: true
  });
};

GSS.load = function() {
  GSS.dirtyLoadEngines();
  return GSS.render();
};

GSS.render = function() {
  TIME("RENDER");
  GSS.updateIfNeeded();
  return GSS.layoutIfNeeded();
};

GSS.needsUpdate = false;

GSS.setNeedsUpdate = function(bool) {
  if (bool) {
    if (!GSS.needsUpdate) {
      GSS._.defer(GSS.updateIfNeeded);
    }
    return GSS.needsUpdate = true;
  } else {
    return GSS.needsUpdate = false;
  }
};

GSS.updateIfNeeded = function() {
  if (GSS.needsUpdate) {
    LOG_PASS("Update Pass", "orange");
    TIME("update pass");
    GSS.engines.root.updateIfNeeded();
    GSS.setNeedsUpdate(false);
    return TIME_END("update pass");
  }
};

GSS.needsLayout = false;

GSS.setNeedsLayout = function(bool) {
  if (bool) {
    if (!GSS.needsLayout) {
      GSS._.defer(GSS.layoutIfNeeded);
    }
    return GSS.needsLayout = true;
  } else {
    return GSS.needsLayout = false;
  }
};

GSS.layoutIfNeeded = function() {
  if (GSS.needsLayout) {
    LOG_PASS("Layout Pass", "green");
    TIME("layout pass");
    GSS.engines.root.layoutIfNeeded();
    GSS.setNeedsLayout(false);
    return TIME_END("layout pass");
  }
};

GSS.needsDisplay = false;

GSS.setNeedsDisplay = function(bool) {
  if (bool) {
    if (!GSS.needsDisplay) {
      GSS._.defer(GSS.displayIfNeeded);
    }
    return GSS.needsDisplay = true;
  } else {
    return GSS.needsDisplay = false;
  }
};

GSS.displayIfNeeded = function() {
  if (GSS.needsDisplay) {
    LOG_PASS("Display Pass", "violet");
    TIME("display pass");
    GSS.engines.root.displayIfNeeded();
    GSS.setNeedsDisplay(false);
    TIME_END("display pass");
    return TIME_END("RENDER");
  }
};

_scopesToLoad = null;

styleQuery = GSS.styleQuery = new GSS.Query({
  selector: "style",
  isLive: true,
  isMulti: true,
  createNodeList: function() {
    return document.getElementsByTagName("style");
  }
});

styleQuery.on('afterChange', function() {
  var engine, id, node, scope, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _results;
  _scopesToLoad = [];
  if (this.changedLastUpdate) {
    _ref1 = this.lastAddedIds;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      id = _ref1[_i];
      node = GSS.getById(id);
      if (GSS.get.isStyleNode(node)) {
        scope = GSS.get.scopeForStyleNode(node);
        if (_scopesToLoad.indexOf(scope) === -1 && scope) {
          _scopesToLoad.push(GSS.get.scopeForStyleNode(node));
        }
      }
    }
    _ref2 = this.lastRemovedIds;
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      id = _ref2[_j];
      node = GSS.getById(id);
      if (GSS.get.isStyleNode(node)) {
        scope = GSS.get.scopeForStyleNode(node);
        if (_scopesToLoad.indexOf(scope) === -1 && ((scope != null ? scope.parentNode : void 0) != null)) {
          if (document.contains(scope)) {
            _scopesToLoad.push(scope);
          }
        }
      }
    }
    _results = [];
    for (_k = 0, _len2 = _scopesToLoad.length; _k < _len2; _k++) {
      scope = _scopesToLoad[_k];
      engine = GSS({
        scope: scope
      });
      if (engine) {
        _results.push(engine.load());
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  }
});

GSS.dirtyLoadEngines = function() {
  var engine, i;
  i = 0;
  engine = GSS.engines[i];
  while (!!engine) {
    if (i > 0) {
      if (engine.scope) {
        if (!document.documentElement.contains(engine.scope)) {
          engine.destroyChildren();
          engine.destroy();
        }
      }
    }
    i++;
    engine = GSS.engines[i];
  }
  return styleQuery.update();
};

});
require.register("the-gss-engine/lib/_.js", function(exports, require, module){
var getTime, _,
  __slice = [].slice;

getTime = Date.now || function() {
  return new Date().getTime();
};

_ = {
  defer: function(func) {
    return setTimeout(func, 1);
  },
  debounce: function(func, wait, immediate) {
    var args, context, result, timeout, timestamp;
    timeout = void 0;
    args = void 0;
    context = void 0;
    timestamp = void 0;
    result = void 0;
    return function() {
      var callNow, later;
      context = this;
      args = __slice.call(arguments);
      timestamp = getTime();
      later = function() {
        var last;
        last = getTime() - timestamp;
        if (last < wait) {
          return timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) {
            return result = func.apply(context, args);
          }
        }
      };
      callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) {
        result = func.apply(context, args);
      }
      return result;
    };
  },
  cloneDeep: function(obj) {
    return JSON.parse(JSON.stringify(obj));
  },
  cloneObject: function(obj) {
    var i, target;
    target = {};
    for (i in obj) {
      if (obj.hasOwnProperty(i)) {
        target[i] = obj[i];
      }
    }
    return target;
  },
  filterVarsForDisplay: function(vars) {
    var idx, k, key, keysToKill, obj, val, _i, _len;
    obj = {};
    keysToKill = [];
    for (key in vars) {
      val = vars[key];
      idx = key.indexOf("intrinsic-");
      if (idx !== -1) {
        keysToKill.push(key.replace("intrinsic-", ""));
      } else {
        obj[key] = val;
      }
    }
    for (_i = 0, _len = keysToKill.length; _i < _len; _i++) {
      k = keysToKill[_i];
      delete obj[k];
    }
    return obj;
  },
  varsByViewId: function(vars) {
    var gid, key, prop, val, varsById;
    varsById = {};
    for (key in vars) {
      val = vars[key];
      if (key[0] === "$") {
        gid = key.substring(1, key.indexOf("["));
        if (!varsById[gid]) {
          varsById[gid] = {};
        }
        prop = key.substring(key.indexOf("[") + 1, key.indexOf("]"));
        varsById[gid][prop] = val;
      }
    }
    return varsById;
  }
};

module.exports = _;

});
require.register("the-gss-engine/lib/EventTrigger.js", function(exports, require, module){
var EventTrigger;

EventTrigger = (function() {
  function EventTrigger() {
    this._listenersByType = {};
    this;
  }

  EventTrigger.prototype._getListeners = function(type) {
    var byType;
    if (this._listenersByType[type]) {
      byType = this._listenersByType[type];
    } else {
      byType = this._listenersByType[type] = [];
    }
    return byType;
  };

  EventTrigger.prototype.on = function(type, listener) {
    var listeners;
    listeners = this._getListeners(type);
    if (listeners.indexOf(listener) === -1) {
      listeners.push(listener);
    }
    return this;
  };

  EventTrigger.prototype.once = function(type, listener) {
    var that, wrap;
    wrap = null;
    that = this;
    wrap = function(o) {
      listener.call(that, o);
      return that.off(type, wrap);
    };
    this.on(type, wrap);
    return this;
  };

  EventTrigger.prototype.off = function(type, listener) {
    var i, listeners;
    listeners = this._getListeners(type);
    i = listeners.indexOf(listener);
    if (i !== -1) {
      listeners.splice(i, 1);
    }
    return this;
  };

  EventTrigger.prototype.offAll = function(target) {
    var i, listeners, type, _ref;
    if (typeof target === "string") {
      if (target) {
        this._listenersByType[target] = [];
      }
    } else if (typeof target === "function") {
      _ref = this._listenersByType;
      for (type in _ref) {
        listeners = _ref[type];
        i = listeners.indexOf(target);
        if (i !== -1) {
          listeners.splice(i, 1);
        }
      }
    } else {
      this._listenersByType = {};
    }
    return this;
  };

  EventTrigger.prototype.trigger = function(type, o) {
    var listener, _i, _len, _ref;
    _ref = this._getListeners(type);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      listener = _ref[_i];
      listener.call(this, o);
    }
    return this;
  };

  return EventTrigger;

})();

EventTrigger.make = function(obj) {
  var key, val, _ref;
  if (obj == null) {
    obj = {};
  }
  EventTrigger.prototype.constructor.call(obj);
  _ref = EventTrigger.prototype;
  for (key in _ref) {
    val = _ref[key];
    if (key === "constructor") {
      val.call(obj);
    } else {
      obj[key] = val;
    }
  }
  return obj;
};

module.exports = EventTrigger;

});
require.register("the-gss-engine/lib/dom/Query.js", function(exports, require, module){
var LOG, Query, arrayAddsRemoves,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

arrayAddsRemoves = function(old, neu) {
  var adds, n, o, removes, _i, _j, _len, _len1;
  adds = [];
  removes = [];
  for (_i = 0, _len = neu.length; _i < _len; _i++) {
    n = neu[_i];
    if (old.indexOf(n) === -1) {
      adds.push(n);
    }
  }
  for (_j = 0, _len1 = old.length; _j < _len1; _j++) {
    o = old[_j];
    if (neu.indexOf(o) === -1) {
      removes.push(o);
    }
  }
  return {
    adds: adds,
    removes: removes
  };
};

LOG = function() {
  return GSS.deblog.apply(GSS, ["Query"].concat(__slice.call(arguments)));
};

Query = (function(_super) {
  __extends(Query, _super);

  Query.prototype.isQuery = true;

  function Query(o) {
    if (o == null) {
      o = {};
    }
    Query.__super__.constructor.apply(this, arguments);
    this.selector = o.selector || (function() {
      throw new Error("GssQuery must have a selector");
    })();
    this.createNodeList = o.createNodeList || (function() {
      throw new Error("GssQuery must implement createNodeList()");
    })();
    this.isMulti = o.isMulti || false;
    this.isLive = o.isLive || false;
    this.ids = o.ids || [];
    this.lastAddedIds = [];
    this.lastRemovedIds = [];
    LOG("constructor() @", this);
    this;
  }

  Query.prototype._updated_once = false;

  Query.prototype.changedLastUpdate = false;

  Query.prototype.update = function() {
    var adds, el, id, newIds, oldIds, removes, _i, _len, _ref, _ref1;
    LOG("update() @", this);
    if (this.is_destroyed) {
      throw new Error("Can't update destroyed query: " + selector);
    }
    this.changedLastUpdate = false;
    if (!this.isLive || !this._updated_once) {
      this.nodeList = this.createNodeList();
      this._updated_once = true;
    }
    oldIds = this.ids;
    newIds = [];
    _ref = this.nodeList;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      el = _ref[_i];
      id = GSS.setupId(el);
      if (id) {
        newIds.push(id);
      }
    }
    _ref1 = arrayAddsRemoves(oldIds, newIds), adds = _ref1.adds, removes = _ref1.removes;
    if (adds.length > 0) {
      this.changedLastUpdate = true;
    }
    this.lastAddedIds = adds;
    if (removes.length > 0) {
      this.changedLastUpdate = true;
    }
    this.lastRemovedIds = removes;
    this.ids = newIds;
    if (this.changedLastUpdate) {
      this.trigger('afterChange');
    }
    return this;
  };

  Query.prototype.forEach = function(callback) {
    var el, _i, _len, _ref, _results;
    _ref = this.nodeList;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      el = _ref[_i];
      _results.push(callback.call(this, el));
    }
    return _results;
  };

  Query.prototype.first = function() {
    return this.nodeList[0];
  };

  Query.prototype.last = function() {
    return this.nodeList[this.nodeList.length - 1];
  };

  Query.prototype.next = function(el) {
    return this.nodeList[this.indexOf(el) + 1];
  };

  Query.prototype.prev = function(el) {
    return this.nodeList[this.indexOf(el) - 1];
  };

  Query.prototype.indexOf = function(el) {
    return Array.prototype.indexOf.call(this.nodeList, el);
  };

  Query.prototype.is_destroyed = false;

  Query.prototype.destroy = function() {
    this.offAll();
    this.is_destroyed = true;
    this.ids = null;
    this.lastAddedIds = null;
    this.lastRemovedIds = null;
    this.createNodeList = null;
    this.nodeList = null;
    return this.changedLastUpdate = null;
  };

  return Query;

})(GSS.EventTrigger);

module.exports = Query;

});
require.register("the-gss-engine/lib/dom/View.js", function(exports, require, module){
var View, firstSupportedStylePrefix, transformPrefix,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

firstSupportedStylePrefix = function(prefixedPropertyNames) {
  var name, tempDiv, _i, _len;
  tempDiv = document.createElement("div");
  for (_i = 0, _len = prefixedPropertyNames.length; _i < _len; _i++) {
    name = prefixedPropertyNames[_i];
    if (typeof tempDiv.style[name] !== 'undefined') {
      return name;
    }
  }
  return null;
};

transformPrefix = firstSupportedStylePrefix(["transform", "msTransform", "MozTransform", "WebkitTransform", "OTransform"]);

View = (function() {
  function View() {
    this.recycle = __bind(this.recycle, this);
    this.attach = __bind(this.attach, this);
    this.values = {};
    this;
  }

  View.prototype.attach = function(el, id) {
    this.el = el;
    this.id = id;
    if (!this.el) {
      throw new Error("View needs el");
    }
    if (!this.id) {
      throw new Error("View needs id");
    }
    View.byId[this.id] = this;
    return this.is_positioned = false;
  };

  View.prototype.recycle = function() {
    this.scope = null;
    this.is_positioned = false;
    this.el = null;
    delete View.byId[this.id];
    this.id = null;
    this.offsets = null;
    this.style = null;
    this.values = {};
    return View.recycled.push(this);
  };

  View.prototype.is_positioned = false;

  View.prototype.setupForPositioning = function() {
    if (!this.is_positioned) {
      this.style.position = 'absolute';
      this.style.margin = '0px';
      this.style.top = '0px';
      this.style.left = '0px';
    }
    return this.is_positioned = true;
  };

  View.prototype.updateOffsets = function() {
    return this.offsets = this.getOffsets();
  };

  View.prototype.getOffsets = function() {
    var el, offsets;
    el = this.el;
    if (!GSS.config.useOffsetParent) {
      return {
        x: 0,
        y: 0
      };
    }
    offsets = {
      x: 0,
      y: 0
    };
    if (!el.offsetParent) {
      return offsets;
    }
    el = el.offsetParent;
    while (true) {
      offsets.x += el.offsetLeft;
      offsets.y += el.offsetTop;
      if (!el.offsetParent) {
        break;
      }
      el = el.offsetParent;
    }
    return offsets;
  };

  View.prototype.needsDisplay = false;

  View.prototype.display = function(offsets) {
    var key, o, val, _ref, _results;
    o = this.values;
    if ((o.x != null) || (o.y != null)) {
      this.style[transformPrefix] = "";
      if (o.x) {
        this.style[transformPrefix] += " translateX(" + (o.x - offsets.x) + "px)";
      }
      if (o.y) {
        this.style[transformPrefix] += " translateY(" + (o.y - offsets.y) + "px)";
      }
    }
    if (o.width != null) {
      this.style.width = o.width + "px";
    }
    if (o.height != null) {
      this.style.height = o.height + "px";
    }
    _ref = this.style;
    _results = [];
    for (key in _ref) {
      val = _ref[key];
      _results.push(this.el.style[key] = val);
    }
    return _results;
  };

  View.prototype.displayIfNeeded = function(offsets) {
    if (offsets == null) {
      offsets = {
        x: 0,
        y: 0
      };
    }
    if (this.needsDisplay) {
      this.display(offsets);
      this.setNeedsDisplay(false);
    }
    offsets = {
      x: 0,
      y: 0
    };
    if (this.values.x) {
      offsets.x += this.values.x;
    }
    if (this.values.y) {
      offsets.y += this.values.y;
    }
    return this._displayChildrenIfNeeded(offsets);
  };

  View.prototype.setNeedsDisplay = function(bool) {
    if (bool) {
      return this.needsDisplay = true;
    } else {
      return this.needsDisplay = false;
    }
  };

  View.prototype._displayChildrenIfNeeded = function(offsets) {
    var child, view, _i, _len, _ref, _results;
    _ref = this.el.children;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      view = GSS.get.view(child);
      if (view) {
        _results.push(view.displayIfNeeded(offsets));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  View.prototype.updateValues = function(o) {
    this.values = o;
    this.style = {};
    if ((o.x != null) || (o.y != null)) {
      this.setupForPositioning();
    }
    this.setNeedsDisplay(true);
    return this;
  };

  View.prototype.getParentView = function() {
    var el, gid;
    el = this.el.parentElement;
    while (true) {
      gid = el._gss_id;
      if (gid) {
        return View.byId[gid];
      }
      if (!el.parentElement) {
        break;
      }
      el = el.parentElement;
    }
  };

  return View;

})();

View.byId = {};

View.recycled = [];

View.count = 0;

View["new"] = function(_arg) {
  var el, id, view;
  el = _arg.el, id = _arg.id;
  View.count++;
  if (View.recycled.length > 0) {
    view = View.recycled.pop();
  } else {
    view = new View();
  }
  return view.attach(el, id);
};

module.exports = View;

});
require.register("the-gss-engine/lib/dom/Observer.js", function(exports, require, module){
var LOG, observer, setupObserver,
  __slice = [].slice;

LOG = function() {
  return GSS.deblog.apply(GSS, ["Observer"].concat(__slice.call(arguments)));
};

observer = null;

setupObserver = function() {
  if (!window.MutationObserver) {
    if (window.WebKitMutationObserver) {
      window.MutationObserver = window.WebKitMutationObserver;
    } else {
      window.MutationObserver = window.JsMutationObserver;
    }
  }
  return observer = new MutationObserver(function(mutations) {
    var engine, gid, invalidMeasureIds, m, needsUpdateQueries, nodesToIgnore, scope, scopesToLoad, target, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref;
    LOG("MutationObserver");
    scopesToLoad = [];
    nodesToIgnore = [];
    needsUpdateQueries = [];
    invalidMeasureIds = [];
    for (_i = 0, _len = mutations.length; _i < _len; _i++) {
      m = mutations[_i];
      if (m.type === "characterData") {
        if (GSS.get.isStyleNode(m.target.parentElement)) {
          scope = GSS.get.scopeForStyleNode(m.target.parentElement);
          if (scopesToLoad.indexOf(scope) === -1) {
            scopesToLoad.push(scope);
          }
        }
      }
      if (m.type === "attributes" || m.type === "childList") {
        if (m.type === "attributes" && m.attributename === "data-gss-id") {
          nodesToIgnore.push(m.target);
        } else if (nodesToIgnore.indexOf(m.target) === -1) {
          scope = GSS.get.nearestScope(m.target);
          if (scope) {
            if (needsUpdateQueries.indexOf(scope) === -1) {
              needsUpdateQueries.push(scope);
            }
          }
        }
      }
      gid = null;
      if (m.type === "characterData" || m.type === "attributes" || m.type === "childList") {
        if (m.type === "characterData") {
          target = m.target.parentElement;
          gid = "$" + GSS.getId(m.target.parentElement);
        } else if (nodesToIgnore.indexOf(m.target) === -1) {
          gid = "$" + GSS.getId(m.target);
        }
        if (gid != null) {
          if (invalidMeasureIds.indexOf(gid) === -1) {
            invalidMeasureIds.push(gid);
          }
        }
      }
    }
    for (_j = 0, _len1 = scopesToLoad.length; _j < _len1; _j++) {
      scope = scopesToLoad[_j];
      GSS.get.engine(scope).load();
    }
    for (_k = 0, _len2 = needsUpdateQueries.length; _k < _len2; _k++) {
      scope = needsUpdateQueries[_k];
      if (scopesToLoad.indexOf(scope) === -1) {
        GSS.get.engine(scope).updateQueries();
      }
    }
    if (invalidMeasureIds.length > 0) {
      _ref = GSS.engines;
      for (_l = 0, _len3 = _ref.length; _l < _len3; _l++) {
        engine = _ref[_l];
        engine.commander.handleInvalidMeasures(invalidMeasureIds);
      }
    }
    scopesToLoad = null;
    nodesToIgnore = null;
    needsUpdateQueries = null;
    invalidMeasureIds = null;
    /*
    for m in mutations
      # els removed from scope
      if m.removedNodes.length > 0 # nodelist are weird?
        for node in m.removedNodes
          # destroy engines
          if node._gss_is_scope
            GSS.get.engine(node).destroy()      
        
          ## scopes with removed ASTs
          #if GSS.get.isStyleNode node
          #  scope = GSS.get.scopeForStyleNode node
          #  if scopesToLoad.indexOf(scope) is -1 and scope
          #    scopesToLoad.push scope  
          #
        
    
      ## els removed from scope
      #if m.addedNodes.length > 0 # nodelist are weird?
      #  for node in m.addedNodes        
      #    # scopes with new ASTs        
      #    if GSS.get.isStyleNode node
      #      scope = GSS.get.scopeForStyleNode node
      #      if scopesToLoad.indexOf(scope) is -1
      #        scopesToLoad.push scope
      #
      #for scope in scopesToLoad
      #  GSS(scope).load()
    */

    return GSS.load();
  });
};

GSS.is_observing = false;

GSS.observe = function() {
  if (!GSS.is_observing && GSS.config.observe) {
    observer.observe(document.body, {
      subtree: true,
      childList: true,
      attributes: true,
      characterData: true
    });
    return GSS.is_observing = true;
  }
};

GSS.unobserve = function() {
  observer.disconnect();
  return GSS.is_observing = false;
};

document.addEventListener("DOMContentLoaded", function(e) {
  setupObserver();
  GSS.boot();
  LOG("DOMContentLoaded");
  GSS.load();
  GSS.observe();
  return GSS.trigger("afterLoaded");
});

module.exports = observer;

});
require.register("the-gss-engine/lib/Engine.js", function(exports, require, module){
var Engine, LOG, TIME, TIME_END, engines, _,
  __slice = [].slice,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

if (typeof GSS === "undefined" || GSS === null) {
  throw new Error("GSS object needed for Engine");
}

_ = GSS._;

TIME = function() {
  if (GSS.config.perf) {
    return console.time.apply(console, arguments);
  }
};

TIME_END = function() {
  if (GSS.config.perf) {
    return console.timeEnd.apply(console, arguments);
  }
};

LOG = function() {
  return GSS.deblog.apply(GSS, ["Engine"].concat(__slice.call(arguments)));
};

GSS.engines = engines = [];

engines.byId = {};

engines.root = null;

Engine = (function(_super) {
  __extends(Engine, _super);

  function Engine(o) {
    if (o == null) {
      o = {};
    }
    this.dispatch = __bind(this.dispatch, this);
    this.updateQueries = __bind(this.updateQueries, this);
    this.handleWorkerMessage = __bind(this.handleWorkerMessage, this);
    this.load = __bind(this.load, this);
    this.execute = __bind(this.execute, this);
    Engine.__super__.constructor.apply(this, arguments);
    this.scope = o.scope, this.workerURL = o.workerURL, this.vars = o.vars, this.getter = o.getter, this.is_root = o.is_root, this.useWorker = o.useWorker;
    if (!this.vars) {
      this.vars = {};
    }
    if (!GSS.config.useWorker) {
      this.useWorker = false;
    } else {
      if (this.useWorker == null) {
        this.useWorker = true;
      }
    }
    this.worker = null;
    this.workerCommands = [];
    this.workerMessageHistory = [];
    if (!this.workerURL) {
      this.workerURL = GSS.config.workerURL;
    }
    if (this.scope) {
      if (this.scope.tagName === "HEAD") {
        this.scope = document;
      }
      this.id = GSS.setupScopeId(this.scope);
      if (this.scope === GSS.Getter.getRootScope()) {
        this.queryScope = document;
      } else {
        this.queryScope = this.scope;
      }
    } else {
      this.id = GSS.uid();
      this.queryScope = document;
    }
    if (!this.getter) {
      this.getter = new GSS.Getter(this.scope);
    }
    this.commander = new GSS.Commander(this);
    this.lastWorkerCommands = null;
    this.queryCache = {};
    this.cssDump = null;
    GSS.engines.push(this);
    engines.byId[this.id] = this;
    this._Hierarchy_setup();
    LOG("constructor() @", this);
    this;
  }

  Engine.prototype.getVarsById = function() {
    var vars, varsById;
    vars = this.vars;
    if (GSS.config.processBeforeSet) {
      vars = GSS.config.processBeforeSet(vars);
    }
    return varsById = _.varsByViewId(_.filterVarsForDisplay(vars));
  };

  Engine.prototype.isDescendantOf = function(engine) {
    var parentEngine;
    parentEngine = this.parentEngine;
    while (parentEngine) {
      if (parentEngine === engine) {
        return true;
      }
      parentEngine = parentEngine.parentEngine;
    }
    return false;
  };

  Engine.prototype._Hierarchy_setup = function() {
    var _ref;
    this.childEngines = [];
    this.parentEngine = null;
    if (this.is_root) {
      engines.root = this;
    } else if (this.scope) {
      this.parentEngine = GSS.get.nearestEngine(this.scope, true);
    } else {
      this.parentEngine = engines.root;
    }
    if (!this.parentEngine && !this.is_root) {
      throw new Error("ParentEngine missing, WTF");
    }
    return (_ref = this.parentEngine) != null ? _ref.childEngines.push(this) : void 0;
  };

  Engine.prototype._Hierarchy_destroy = function() {
    this.parentEngine.childEngines.splice(this.parentEngine.childEngines.indexOf(this), 1);
    return this.parentEngine = null;
  };

  Engine.prototype.is_running = false;

  Engine.prototype.run = function(asts) {
    var ast, _i, _len, _results;
    LOG(this.id, ".run(asts)", asts);
    if (asts instanceof Array) {
      _results = [];
      for (_i = 0, _len = asts.length; _i < _len; _i++) {
        ast = asts[_i];
        _results.push(this._run(ast));
      }
      return _results;
    } else {
      return this._run(asts);
    }
  };

  Engine.prototype._run = function(ast) {
    if (ast.commands) {
      this.execute(ast.commands);
    }
    if (ast.css) {
      this.cssToDump = ast.css;
      return this.dumpCSSIfNeeded();
    }
  };

  Engine.prototype.execute = function(commands) {
    return this.commander.execute(commands);
  };

  Engine.prototype.load = function() {
    var AST, ASTs, node, _i, _len, _ref;
    LOG(this.id, ".loadASTs()");
    if (!this.scope) {
      throw new Error("can't load scopeless engine");
    }
    if (this.is_running) {
      this.clean();
    }
    ASTs = [];
    _ref = this.getter.getAllStyleNodes();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      if (this.scope === GSS.get.scopeForStyleNode(node)) {
        AST = this.getter.readAST(node);
        if (AST) {
          ASTs.push(AST);
        }
      }
    }
    this.ASTs = ASTs;
    this.setNeedsUpdate(true);
    return this;
  };

  Engine.prototype.cssToDump = null;

  Engine.prototype.cssDump = null;

  Engine.prototype.setupCSSDumpIfNeeded = function() {
    var dumpNode;
    dumpNode = this.scope || document.body;
    if (!this.cssDump) {
      this.cssDump = document.createElement("style");
      this.cssDump.id = "gss-css-dump-" + this.id;
      return dumpNode.appendChild(this.cssDump);
    }
  };

  Engine.prototype.dumpCSSIfNeeded = function() {
    if (this.cssToDump) {
      this.setupCSSDumpIfNeeded();
      this.cssDump.insertAdjacentHTML("beforeend", this.cssToDump);
      return this.cssToDump = null;
    }
  };

  Engine.prototype._CSSDumper_clean = function() {
    var _ref;
    this.cssToDump = null;
    return (_ref = this.cssDump) != null ? _ref.innerHTML = "" : void 0;
  };

  Engine.prototype._CSSDumper_destroy = function() {
    this.cssToDump = null;
    return this.cssDump = null;
  };

  Engine.prototype.needsUpdate = false;

  Engine.prototype.setNeedsUpdate = function(bool) {
    LOG(this.id, ".setNeedsUpdate( " + bool + " )");
    if (bool) {
      GSS.setNeedsUpdate(true);
      return this.needsUpdate = true;
    } else {
      return this.needsUpdate = false;
    }
  };

  Engine.prototype.updateIfNeeded = function() {
    var child, _i, _len, _ref, _results;
    LOG(this.id, ".updateIfNeeded()");
    if (this.needsUpdate) {
      if (this.ASTs) {
        this.run(this.ASTs);
        this.ASTs = null;
      }
      this.setNeedsUpdate(false);
    }
    _ref = this.childEngines;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      _results.push(child.updateIfNeeded());
    }
    return _results;
  };

  Engine.prototype.needsLayout = false;

  Engine.prototype.setNeedsLayout = function(bool) {
    LOG(this.id, ".setNeedsLayout( " + bool + " )");
    if (bool) {
      if (!this.needsLayout) {
        GSS.setNeedsLayout(true);
        return this.needsLayout = true;
      }
    } else {
      return this.needsLayout = false;
    }
  };

  Engine.prototype._beforeLayoutCalls = null;

  Engine.prototype.layout = function() {
    LOG(this.id, ".layout()");
    this.hoistedTrigger("beforeLayout", this);
    this.is_running = true;
    TIME("" + this.id + " LAYOUT & DISPLAY");
    this.solve();
    return this.setNeedsLayout(false);
  };

  Engine.prototype.layoutIfNeeded = function() {
    LOG(this.id, ".layoutIfNeeded()");
    if (this.needsLayout) {
      this.layout();
    }
    return this.layoutSubTreeIfNeeded();
  };

  Engine.prototype.waitingToLayoutSubtree = false;

  Engine.prototype.layoutSubTreeIfNeeded = function() {
    var child, _i, _len, _ref, _results;
    this.waitingToLayoutSubtree = false;
    _ref = this.childEngines;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      _results.push(child.layoutIfNeeded());
    }
    return _results;
  };

  Engine.prototype.needsDisplay = false;

  Engine.prototype.setNeedsDisplay = function(bool) {
    if (bool) {
      LOG(this.id, ".setNeedsDisplay( " + bool + " )");
      GSS.setNeedsDisplay(true);
      return this.needsDisplay = true;
    } else {
      LOG(this.id, ".setNeedsDisplay( " + bool + " )");
      return this.needsDisplay = false;
    }
  };

  Engine.prototype.displayIfNeeded = function() {
    var child, _i, _len, _ref, _results;
    LOG(this, "displayIfNeeded");
    if (this.needsDisplay) {
      this.display();
      this.setNeedsDisplay(false);
    }
    _ref = this.childEngines;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      _results.push(child.displayIfNeeded());
    }
    return _results;
  };

  Engine.prototype.display = function() {
    var id, needsToDisplayViews, obj, varsById, _ref;
    LOG(this.id, ".display()");
    this.hoistedTrigger("beforeDisplay", this);
    GSS.unobserve();
    varsById = this.getVarsById();
    needsToDisplayViews = false;
    for (id in varsById) {
      obj = varsById[id];
      needsToDisplayViews = true;
      if ((_ref = GSS.View.byId[id]) != null) {
        if (typeof _ref.updateValues === "function") {
          _ref.updateValues(obj);
        }
      }
    }
    if (needsToDisplayViews) {
      if (this.scope) {
        GSS.get.view(this.scope).displayIfNeeded();
      }
    }
    this.validate();
    GSS.observe();
    this.dispatchedTrigger("solved", {
      values: this.vars
    });
    TIME_END("" + this.id + " LAYOUT & DISPLAY");
    return this;
  };

  Engine.prototype.validate = function() {
    return this.commander.validateMeasures();
  };

  Engine.prototype.measureByGssId = function(id, prop) {
    var el, val;
    el = GSS.getById(id);
    val = this.getter.measure(el, prop);
    LOG(this.id, ".measureByGssId()", id, prop, val);
    return val;
  };

  Engine.prototype.solve = function() {
    if (this.useWorker) {
      return this.solveWithWorker();
    } else {
      return this.solveWithoutWorker();
    }
  };

  Engine.prototype.solveWithWorker = function() {
    var workerMessage;
    LOG(this.id, ".solveWithWorker()", this.workerCommands);
    workerMessage = {
      commands: this.workerCommands
    };
    this.workerMessageHistory.push(workerMessage);
    if (!this.worker) {
      this.worker = new Worker(this.workerURL);
      this.worker.addEventListener("message", this.handleWorkerMessage, false);
      this.worker.addEventListener("error", this.handleError, false);
    }
    this.worker.postMessage(workerMessage);
    this.lastWorkerCommands = this.workerCommands;
    return this.workerCommands = [];
  };

  Engine.prototype.solveWithoutWorker = function() {
    var workerMessage,
      _this = this;
    LOG(this.id, ".solveWithoutWorker()", this.workerCommands);
    workerMessage = {
      commands: this.workerCommands
    };
    this.workerMessageHistory.push(workerMessage);
    if (!this.worker) {
      this.worker = new GSS.Thread();
    }
    this.worker.postMessage(_.cloneDeep(workerMessage));
    _.defer(function() {
      if (_this.worker) {
        return _this.handleWorkerMessage({
          data: {
            values: _this.worker.getValues()
          }
        });
      }
    });
    this.lastWorkerCommands = this.workerCommands;
    return this.workerCommands = [];
  };

  Engine.prototype.handleWorkerMessage = function(message) {
    LOG(this.id, ".handleWorkerMessage()", this.workerCommands);
    this.vars = message.data.values;
    return this.display();
  };

  Engine.prototype.handleError = function(event) {
    if (this.onError) {
      return this.onError(event);
    }
    throw new Error("" + event.message + " (" + event.filename + ":" + event.lineno + ")");
  };

  Engine.prototype._Worker_destroy = function() {
    if (this.worker) {
      this.worker.terminate();
      this.worker = null;
    }
    this.workerCommands = null;
    this.workerMessageHistory = null;
    return this.lastWorkerCommands = null;
  };

  Engine.prototype._Worker_clean = function() {
    this.workerCommands = [];
    this.lastWorkerCommands = null;
    if (this.worker) {
      this.worker.terminate();
      return this.worker = null;
    }
  };

  Engine.prototype.registerDomQuery = function(o) {
    var query, selector;
    selector = o.selector;
    if (this.queryCache[selector] != null) {
      return this.queryCache[selector];
    } else {
      query = new GSS.Query(o);
      query.update();
      this.queryCache[selector] = query;
      return query;
    }
  };

  Engine.prototype.updateQueries = function() {
    var el, globalRemoves, query, removedIds, removes, rid, selector, selectorsWithAdds, trigger, _i, _len, _ref;
    selectorsWithAdds = [];
    removes = [];
    globalRemoves = [];
    trigger = false;
    _ref = this.queryCache;
    for (selector in _ref) {
      query = _ref[selector];
      query.update();
      if (query.changedLastUpdate) {
        if (query.lastAddedIds.length > 0) {
          selectorsWithAdds.push(selector);
          trigger = true;
        }
        if (query.lastRemovedIds.length > 0) {
          trigger = true;
          removedIds = query.lastRemovedIds;
          for (_i = 0, _len = removedIds.length; _i < _len; _i++) {
            rid = removedIds[_i];
            if (globalRemoves.indexOf(rid) === -1) {
              el = GSS.getById(rid);
              if (document.documentElement.contains(el)) {
                globalRemoves.push(rid);
                removes.push(selector + "$" + rid);
              } else {
                removes.push("$" + rid);
              }
            }
          }
        }
      }
      GSS._ids_killed(globalRemoves);
      if (trigger) {
        this.commander.handleRemoves(removes);
        this.commander.handleSelectorsWithAdds(selectorsWithAdds);
      }
      return trigger;
    }
  };

  Engine.prototype._Queries_destroy = function() {
    var query, selector, _ref;
    _ref = this.queryCache;
    for (selector in _ref) {
      query = _ref[selector];
      query.destroy();
      this.queryCache[selector] = null;
    }
    return this.queryCache = null;
  };

  Engine.prototype._Queries_clean = function() {
    var query, selector, _ref;
    _ref = this.queryCache;
    for (selector in _ref) {
      query = _ref[selector];
      query.destroy();
      this.queryCache[selector] = null;
    }
    return this.queryCache = {};
  };

  Engine.prototype.hoistedTrigger = function(ev, obj) {
    this.trigger(ev, obj);
    return GSS.trigger("engine:" + ev, obj);
  };

  Engine.prototype.dispatchedTrigger = function(e, o, b, c) {
    this.trigger(e, o);
    return this.dispatch(e, o, b, c);
  };

  Engine.prototype.dispatch = function(eName, oDetail, bubbles, cancelable) {
    var e, o;
    if (oDetail == null) {
      oDetail = {};
    }
    if (bubbles == null) {
      bubbles = true;
    }
    if (cancelable == null) {
      cancelable = true;
    }
    if (!this.scope) {
      return;
    }
    oDetail.engine = this;
    o = {
      detail: oDetail,
      bubbles: bubbles,
      cancelable: cancelable
    };
    e = new CustomEvent(eName, o);
    return this.scope.dispatchEvent(e);
  };

  Engine.prototype.registerCommands = function(commands) {
    var command, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = commands.length; _i < _len; _i++) {
      command = commands[_i];
      _results.push(this.registerCommand(command));
    }
    return _results;
  };

  Engine.prototype.registerCommand = function(command) {
    this.workerCommands.push(command);
    this.setNeedsLayout(true);
    return this;
  };

  Engine.prototype.clean = function() {
    var key, val, _base, _ref;
    LOG(this.id, ".clean()");
    this.offAll();
    _ref = this.vars;
    for (key in _ref) {
      val = _ref[key];
      delete this.vars[key];
    }
    this.setNeedsLayout(false);
    this.setNeedsDisplay(false);
    this.setNeedsLayout(false);
    this.waitingToLayoutSubtree = false;
    this.commander.clean();
    if (typeof (_base = this.getter).clean === "function") {
      _base.clean();
    }
    this._CSSDumper_clean();
    this._Worker_clean();
    this._Queries_clean();
    return this;
  };

  Engine.prototype.is_destroyed = false;

  Engine.prototype.destroyChildren = function() {
    var e, _i, _len, _ref, _results;
    _ref = this.childEngines;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      e = _ref[_i];
      if (!e.is_destroyed) {
        _results.push(e.destroy());
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Engine.prototype.destroy = function() {
    var d, descdendants, i, kill, _base, _i, _len;
    LOG(this.id, ".destroy()");
    this.hoistedTrigger("beforeDestroy", this);
    GSS._ids_killed([this.id]);
    if (this.scope) {
      descdendants = GSS.get.descdendantNodes(this.scope);
      for (_i = 0, _len = descdendants.length; _i < _len; _i++) {
        d = descdendants[_i];
        kill = d._gss_id;
        if (kill) {
          GSS._id_killed(kill);
        }
      }
    }
    i = engines.indexOf(this);
    if (i > -1) {
      engines.splice(i, 1);
    }
    delete engines.byId[this.id];
    this.offAll();
    this.setNeedsLayout(false);
    this.setNeedsDisplay(false);
    this.setNeedsLayout(false);
    this.waitingToLayoutSubtree = false;
    this.commander.destroy();
    if (typeof (_base = this.getter).destroy === "function") {
      _base.destroy();
    }
    this.vars = null;
    this.ast = null;
    this.getter = null;
    this.scope = null;
    this.commander = null;
    this._Hierarchy_destroy();
    this._CSSDumper_destroy();
    this._Worker_destroy();
    this._Queries_destroy();
    this.is_running = null;
    this.is_destroyed = true;
    return this;
  };

  Engine.prototype.elVar = function(el, key, selector, tracker2) {
    var ast, gid, varid;
    gid = GSS.getId(el);
    if (key === 'left') {
      key = 'x';
    } else if (key === 'top') {
      key = 'y';
    }
    varid = "$" + gid + ("[" + key + "]");
    if (key === 'bottom') {
      this.registerCommand(['varexp', varid, this.plus(this.elVar(el, 'y', selector), this.elVar(el, 'height', selector))]);
    } else if (key === 'right') {
      this.registerCommand(['varexp', varid, this.plus(this.elVar(el, 'x', selector), this.elVar(el, 'width', selector))]);
    } else if (key === 'center-y') {
      this.registerCommand(['varexp', varid, this.plus(this.elVar(el, 'y', selector), this.divide(this.elVar(el, 'height', selector), 2))]);
    } else if (key === 'center-x') {
      this.registerCommand(['varexp', varid, this.plus(this.elVar(el, 'x', selector), this.divide(this.elVar(el, 'width', selector), 2))]);
    } else {
      this.registerCommand(['var', varid, "$" + gid]);
    }
    ast = ['get', varid];
    if (selector) {
      ast.push(selector + "$" + gid);
    }
    if (tracker2) {
      ast.push(tracker2);
    }
    return ast;
  };

  Engine.prototype["var"] = function(key) {
    this.registerCommand(['var', key]);
    return ['get', key];
  };

  Engine.prototype.varexp = function(key, exp, tracker) {
    this.registerCommand(['varexp', exp, tracker]);
    return ['get', key];
  };

  Engine.prototype.__e = function(key) {
    if (key instanceof Array) {
      return key;
    }
    if (!!Number(key) || (Number(key) === 0)) {
      return ['number', key];
    }
    return this["var"](key);
  };

  Engine.prototype.eq = function(e1, e2, s, w) {
    e1 = this.__e(e1);
    e2 = this.__e(e2);
    return this.registerCommand(['eq', e1, e2, s, w]);
  };

  Engine.prototype.lte = function(e1, e2, s, w) {
    e1 = this.__e(e1);
    e2 = this.__e(e2);
    return this.registerCommand(['lte', e1, e2, s, w]);
  };

  Engine.prototype.gte = function(e1, e2, s, w) {
    e1 = this.__e(e1);
    e2 = this.__e(e2);
    return this.registerCommand(['gte', e1, e2, s, w]);
  };

  Engine.prototype.suggest = function(v, val, strength) {
    if (strength == null) {
      strength = 'required';
    }
    v = this.__e(v);
    return this.registerCommand(['suggest', v, ['number', val], strength]);
  };

  Engine.prototype.stay = function(v) {
    v = this.__e(v);
    return this.registerCommand(['stay', v]);
  };

  Engine.prototype.remove = function(tracker) {
    return this.registerCommand(['remove', tracker]);
  };

  Engine.prototype['number'] = function(num) {
    return ['number', num];
  };

  Engine.prototype['plus'] = function(e1, e2) {
    e1 = this.__e(e1);
    e2 = this.__e(e2);
    return ['plus', e1, e2];
  };

  Engine.prototype['minus'] = function(e1, e2) {
    e1 = this.__e(e1);
    e2 = this.__e(e2);
    return ['minus', e1, e2];
  };

  Engine.prototype['multiply'] = function(e1, e2) {
    e1 = this.__e(e1);
    e2 = this.__e(e2);
    return ['multiply', e1, e2];
  };

  Engine.prototype['divide'] = function(e1, e2, s, w) {
    e1 = this.__e(e1);
    e2 = this.__e(e2);
    return ['divide', e1, e2];
  };

  return Engine;

})(GSS.EventTrigger);

module.exports = Engine;

});
require.register("the-gss-engine/lib/Commander.js", function(exports, require, module){
/*

Root commands, if bound to a dom query, will spawn commands
to match live results of query.
*/

var Commander, bindRoot, cloneBinds, makeTemplateFromVarId, _templateVarIdCache,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __slice = [].slice;

bindRoot = function(root, query) {
  root._is_bound = true;
  if (root._binds == null) {
    root._binds = [];
    root._boundSelectors = [];
  }
  if (root._binds.indexOf(query) === -1) {
    root._binds.push(query);
    root._boundSelectors.push(query.selector);
    if (query.isMulti) {
      if (root._binds.multi) {
        throw new Error("Multi el queries only allowed once per statement");
      }
      return root._binds.multi = query;
    }
  }
};

cloneBinds = function(from, to) {
  var query, _i, _len, _ref;
  if (from._is_bound = true) {
    _ref = from._binds;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      query = _ref[_i];
      bindRoot(to, query);
    }
  }
  return to;
};

_templateVarIdCache = {
  "::window[width]": "::window[width]",
  "::window[height]": "::window[height]",
  "::window[x]": "::window[x]",
  "::window[y]": "::window[y]",
  "::window[center-x]": "::window[center-x]",
  "::window[center-y]": "::window[center-y]"
};

window._templateVarIdCache = _templateVarIdCache;

makeTemplateFromVarId = function(varId) {
  var templ, y;
  if (_templateVarIdCache[varId]) {
    return _templateVarIdCache[varId];
  }
  templ = varId;
  y = varId.split("[");
  if (y[0].length > 1) {
    y[y.length - 2] += "%%";
    templ = "%%" + y.join("[");
    _templateVarIdCache[varId] = templ;
  }
  return templ;
};

Commander = (function() {
  function Commander(engine) {
    this.engine = engine;
    this['$id'] = __bind(this['$id'], this);
    this['$reserved'] = __bind(this['$reserved'], this);
    this['$tag'] = __bind(this['$tag'], this);
    this['$class'] = __bind(this['$class'], this);
    this['strength'] = __bind(this['strength'], this);
    this['js'] = __bind(this['js'], this);
    this['for-all'] = __bind(this['for-all'], this);
    this['for-each'] = __bind(this['for-each'], this);
    this._e_for_chain = __bind(this._e_for_chain, this);
    this._chainer_math = __bind(this._chainer_math, this);
    this['divide-chain'] = __bind(this['divide-chain'], this);
    this['multiply-chain'] = __bind(this['multiply-chain'], this);
    this['minus-chain'] = __bind(this['minus-chain'], this);
    this['plus-chain'] = __bind(this['plus-chain'], this);
    this._chainer = __bind(this._chainer, this);
    this['gt-chain'] = __bind(this['gt-chain'], this);
    this['lt-chain'] = __bind(this['lt-chain'], this);
    this['gte-chain'] = __bind(this['gte-chain'], this);
    this['lte-chain'] = __bind(this['lte-chain'], this);
    this['eq-chain'] = __bind(this['eq-chain'], this);
    this['chain'] = __bind(this['chain'], this);
    this['stay'] = __bind(this['stay'], this);
    this['gt'] = __bind(this['gt'], this);
    this['lt'] = __bind(this['lt'], this);
    this['gte'] = __bind(this['gte'], this);
    this['lte'] = __bind(this['lte'], this);
    this['eq'] = __bind(this['eq'], this);
    this['suggest'] = __bind(this['suggest'], this);
    this['get'] = __bind(this['get'], this);
    this['varexp'] = __bind(this['varexp'], this);
    this['var'] = __bind(this['var'], this);
    this.spawnMeasurements = __bind(this.spawnMeasurements, this);
    this.spawnForWindowSize = __bind(this.spawnForWindowSize, this);
    this._execute = __bind(this._execute, this);
    this._checkCache = __bind(this._checkCache, this);
    this.lazySpawnForWindowSize = GSS._.debounce(this.spawnForWindowSize, GSS.config.resizeDebounce, false);
    this.cleanVars();
  }

  Commander.prototype.clean = function() {
    this.cleanVars();
    return this.unlisten();
  };

  Commander.prototype.cleanVars = function() {
    this.spawnableRoots = [];
    this.intrinsicRegistersById = {};
    this.boundWindowProps = [];
    return this.bindCache = {};
  };

  Commander.prototype.destroy = function() {
    this.spawnableRoots = null;
    this.intrinsicRegistersById = null;
    this.boundWindowProps = null;
    this.bindCache = null;
    return this.unlisten();
  };

  Commander.prototype._checkCache = function(root, cacheKey) {
    var bind, binds, _i, _len, _results;
    binds = this.bindCache[cacheKey];
    if (binds != null) {
      _results = [];
      for (_i = 0, _len = binds.length; _i < _len; _i++) {
        bind = binds[_i];
        _results.push(bindRoot(root, bind));
      }
      return _results;
    }
  };

  Commander.prototype.execute = function(commands) {
    var command, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = commands.length; _i < _len; _i++) {
      command = commands[_i];
      _results.push(this._execute(command, command));
    }
    return _results;
  };

  Commander.prototype._execute = function(command, root) {
    var func, i, node, sub, _i, _len, _ref;
    node = command;
    func = this[node[0]];
    if (func == null) {
      throw new Error("Engine Commands broke, couldn't find method: " + node[0]);
    }
    _ref = node.slice(1, +node.length + 1 || 9e9);
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      sub = _ref[i];
      if (sub instanceof Array) {
        node.splice(i + 1, 1, this._execute(sub, root));
      }
    }
    return func.call.apply(func, [this.engine, root].concat(__slice.call(node.slice(1, node.length))));
  };

  Commander.prototype.unlisten = function() {
    if (!this._bound_to_window_resize) {
      window.removeEventListener("resize", this.lazySpawnForWindowSize, false);
    }
    return this._bound_to_window_resize = false;
  };

  Commander.prototype._bound_to_window_resize = false;

  Commander.prototype.spawnForWindowWidth = function() {
    var w;
    w = window.innerWidth;
    if (this.engine.vars["::window[width]"] !== w) {
      return this.engine.registerCommand(['suggest', ['get', "::window[width]"], ['number', w], 'required']);
    }
  };

  Commander.prototype.spawnForWindowHeight = function() {
    var h;
    h = window.innerHeight;
    if (this.engine.vars["::window[height]"] !== h) {
      return this.engine.registerCommand(['suggest', ['get', "::window[height]"], ['number', h], 'required']);
    }
  };

  Commander.prototype.spawnForWindowSize = function() {
    if (this._bound_to_window_resize) {
      if (this.boundWindowProps.indexOf('width') !== -1) {
        this.spawnForWindowWidth();
      }
      if (this.boundWindowProps.indexOf('height') !== -1) {
        this.spawnForWindowHeight();
      }
      return this.engine.solve();
    }
  };

  Commander.prototype.bindToWindow = function(prop) {
    if (this.boundWindowProps.indexOf(prop) === -1) {
      this.boundWindowProps.push(prop);
    }
    if (prop === 'width' || prop === 'height') {
      if (prop === 'width') {
        this.spawnForWindowWidth();
      } else {
        this.spawnForWindowHeight();
      }
      if (!this._bound_to_window_resize) {
        window.addEventListener("resize", this.lazySpawnForWindowSize, false);
        return this._bound_to_window_resize = true;
      }
    } else if (prop === 'x') {
      return this.engine.registerCommand(['eq', ['get', '::window[x]'], ['number', 0], 'required']);
    } else if (prop === 'y') {
      return this.engine.registerCommand(['eq', ['get', '::window[y]'], ['number', 0], 'required']);
    }
  };

  Commander.prototype.spawnForScope = function(prop) {
    var key, thisEngine;
    key = "$" + this.engine.id + ("[" + prop + "]");
    thisEngine = this.engine;
    return GSS.on("engine:beforeDisplay", function(engine) {
      var val;
      val = engine.vars[key];
      if (val) {
        if (thisEngine.isDescendantOf(engine)) {
          return thisEngine.registerCommand(['suggest', ['get', key], ['number', val], 'required']);
        }
      }
    });
  };

  Commander.prototype.bindToScope = function(prop) {
    return this.spawnForScope(prop);
    /*
    if prop is 'width' or prop is 'height'
      if prop is 'width' then @spawnForScopeWidth() else @spawnForScopeHeight()
    else if prop is 'x'
      @engine.registerCommand ['eq', ['get', '::scope[x]'], ['number', 0], 'required']      
    else if prop is 'y'
      @engine.registerCommand ['eq', ['get', '::scope[y]'], ['number', 0], 'required']
    #else
    #  throw new Error "Not sure how to bind to window prop: #{prop}"
    */

  };

  Commander.prototype.registerSpawn = function(root, varid, prop, intrinsicQuery, checkInstrinsics) {
    if (!root._is_bound) {
      return this.engine.registerCommand(root);
    } else {
      if (varid) {
        this.bindCache[varid] = root._binds;
      }
      root._template = JSON.stringify(root);
      root._varid = varid;
      root._prop = prop;
      if (checkInstrinsics) {
        root._checkInstrinsics = checkInstrinsics;
        root._intrinsicQuery = intrinsicQuery;
      }
      this.spawnableRoots.push(root);
      return this.spawn(root);
    }
  };

  Commander.prototype.handleRemoves = function(removes) {
    var varid, _i, _len;
    if (removes.length < 1) {
      return this;
    }
    this.engine.registerCommand(['remove'].concat(__slice.call(removes)));
    for (_i = 0, _len = removes.length; _i < _len; _i++) {
      varid = removes[_i];
      delete this.intrinsicRegistersById[varid];
    }
    return this;
  };

  Commander.prototype.handleSelectorsWithAdds = function(selectorsWithAdds) {
    var boundSelector, root, _i, _j, _len, _len1, _ref, _ref1;
    if (selectorsWithAdds.length < 1) {
      return this;
    }
    _ref = this.spawnableRoots;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      root = _ref[_i];
      _ref1 = root._boundSelectors;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        boundSelector = _ref1[_j];
        if (selectorsWithAdds.indexOf(boundSelector) !== -1) {
          this.spawn(root);
          break;
        }
      }
    }
    return this;
  };

  Commander.prototype.validateMeasures = function() {
    var id, ids;
    ids = [];
    for (id in this.intrinsicRegistersById) {
      ids.push(id);
    }
    return this.handleInvalidMeasures(ids);
  };

  Commander.prototype.handleInvalidMeasures = function(invalidMeasures) {
    var id, prop, register, registersByProp, _i, _len;
    if (invalidMeasures.length < 1) {
      return this;
    }
    for (_i = 0, _len = invalidMeasures.length; _i < _len; _i++) {
      id = invalidMeasures[_i];
      registersByProp = this.intrinsicRegistersById[id];
      if (registersByProp) {
        for (prop in registersByProp) {
          register = registersByProp[prop];
          register.call(this);
        }
      }
    }
    return this;
  };

  Commander.prototype.spawnMeasurements = function(root) {
    var prop,
      _this = this;
    if (root._intrinsicQuery == null) {
      return;
    }
    prop = root._prop;
    if (root._checkInstrinsics) {
      if (prop.indexOf("intrinsic-") === 0) {
        root._intrinsicQuery.lastAddedIds.forEach(function(id) {
          var elProp, gid, k, register;
          gid = "$" + id;
          if (!_this.intrinsicRegistersById[gid]) {
            _this.intrinsicRegistersById[gid] = {};
          }
          if (!_this.intrinsicRegistersById[gid][prop]) {
            elProp = prop.split("intrinsic-")[1];
            k = "" + gid + "[" + prop + "]";
            register = function() {
              var val;
              val = this.engine.measureByGssId(id, elProp);
              if (this.engine.vars[k] !== val) {
                return this.engine.registerCommand(['suggest', ['get', k], ['number', val], 'required']);
              }
            };
            _this.intrinsicRegistersById[gid][prop] = register;
            return register.call(_this);
          }
        });
      }
    }
    return this;
  };

  Commander.prototype.spawn = function(root) {
    var command, id, joiner, q, queries, ready, replaces, rootString, splitter, template, _i, _j, _len, _len1, _ref;
    queries = root._binds;
    rootString = root._template;
    replaces = {};
    ready = true;
    for (_i = 0, _len = queries.length; _i < _len; _i++) {
      q = queries[_i];
      if (q.lastAddedIds.length < 0) {
        ready = false;
        break;
      }
      if (q !== queries.multi) {
        replaces[q.selector] = q.lastAddedIds[0];
      }
    }
    if (ready) {
      if (queries.multi) {
        template = rootString.split("%%" + queries.multi.selector + "%%");
        _ref = queries.multi.lastAddedIds;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          id = _ref[_j];
          command = template.join("$" + id);
          for (splitter in replaces) {
            joiner = replaces[splitter];
            command = command.split("%%" + splitter + "%%");
            command = command.join("$" + joiner);
          }
          this.engine.registerCommand(eval(command));
        }
      } else {
        command = rootString;
        for (splitter in replaces) {
          joiner = replaces[splitter];
          command = command.split("%%" + splitter + "%%");
          command = command.join("$" + joiner);
        }
        this.engine.registerCommand(eval(command));
      }
    }
    this.spawnMeasurements(root);
    return this;
  };

  Commander.prototype['var'] = function(self, varId, prop, query) {
    self.splice(2, 10);
    if (self._is_bound) {
      self[1] = makeTemplateFromVarId(varId);
      self.push("%%" + query.selector + "%%");
    }
    this.registerSpawn(self, varId, prop, query, true);
    if (query) {
      if (query === 'window') {
        this.bindToWindow(prop);
        return query = null;
      } else if (query.__is_scope) {
        return this.bindToScope(prop);
      }
    }
  };

  Commander.prototype['varexp'] = function(self, varId, expression, zzz) {
    self.splice(3, 10);
    self[1] = makeTemplateFromVarId(varId);
    return this.registerSpawn(self, varId);
  };

  Commander.prototype['get'] = function(root, varId, tracker) {
    this._checkCache(root, varId);
    if (tracker && (tracker !== "::window")) {
      return ['get', makeTemplateFromVarId(varId), tracker + "%%" + tracker + "%%"];
    } else if (root._is_bound) {
      return ['get', makeTemplateFromVarId(varId)];
    } else {
      return ['get', varId];
    }
  };

  Commander.prototype['number'] = function(root, num) {
    return ['number', num];
  };

  Commander.prototype['plus'] = function(root, e1, e2) {
    return ['plus', e1, e2];
  };

  Commander.prototype['minus'] = function(root, e1, e2) {
    return ['minus', e1, e2];
  };

  Commander.prototype['multiply'] = function(root, e1, e2) {
    return ['multiply', e1, e2];
  };

  Commander.prototype['divide'] = function(root, e1, e2, s, w) {
    return ['divide', e1, e2];
  };

  Commander.prototype['suggest'] = function() {
    var args;
    args = __slice.call(arguments);
    return this.engine.registerCommand(['suggest'].concat(__slice.call(args.slice(1, args.length))));
  };

  Commander.prototype['eq'] = function(self, e1, e2, s, w) {
    return this.registerSpawn(self);
  };

  Commander.prototype['lte'] = function(self, e1, e2, s, w) {
    return this.registerSpawn(self);
  };

  Commander.prototype['gte'] = function(self, e1, e2, s, w) {
    return this.registerSpawn(self);
  };

  Commander.prototype['lt'] = function(self, e1, e2, s, w) {
    return this.registerSpawn(self);
  };

  Commander.prototype['gt'] = function(self, e1, e2, s, w) {
    return this.registerSpawn(self);
  };

  Commander.prototype['stay'] = function(self) {
    return this.registerSpawn(self);
    /*
    if !self._is_bound then return @registerSpawn(self)
    # break up stays to allow multiple plural queries
    args = [arguments...]
    gets = args[1...args.length]    
    for get in gets
      stay = ['stay']
      stay.push get
      cloneBinds self, stay
      @registerSpawn(stay)
    */

  };

  Commander.prototype['chain'] = function(root, query, bridgessssss) {
    var args, bridge, bridges, engine, _i, _len;
    args = __slice.call(arguments);
    bridges = __slice.call(args.slice(2, args.length));
    engine = this.engine;
    for (_i = 0, _len = bridges.length; _i < _len; _i++) {
      bridge = bridges[_i];
      bridge.call(engine, query, engine);
    }
    return query.on('afterChange', function() {
      var _j, _len1, _results;
      _results = [];
      for (_j = 0, _len1 = bridges.length; _j < _len1; _j++) {
        bridge = bridges[_j];
        _results.push(bridge.call(engine, query, engine));
      }
      return _results;
    });
  };

  Commander.prototype['eq-chain'] = function(root, head, tail, s, w) {
    return this._chainer('eq', head, tail, s, w);
  };

  Commander.prototype['lte-chain'] = function(root, head, tail, s, w) {
    return this._chainer('lte', head, tail, s, w);
  };

  Commander.prototype['gte-chain'] = function(root, head, tail) {
    return this._chainer('gte', head, tail, s, w);
  };

  Commander.prototype['lt-chain'] = function(root, head, tail) {
    return this._chainer('lt', head, tail, s, w);
  };

  Commander.prototype['gt-chain'] = function(root, head, tail) {
    return this._chainer('gt', head, tail, s, w);
  };

  Commander.prototype._chainer = function(op, head, tail, s, w) {
    var engine, tracker, _e_for_chain;
    tracker = "eq-chain-" + GSS.uid();
    engine = this.engine;
    _e_for_chain = this._e_for_chain;
    return function(query, e) {
      e.remove(tracker);
      return query.forEach(function(el) {
        var e1, e2, nextEl;
        nextEl = query.next(el);
        if (!nextEl) {
          return;
        }
        e1 = _e_for_chain(el, head, query, tracker, el, nextEl);
        e2 = _e_for_chain(nextEl, tail, query, tracker, el, nextEl);
        return e[op](e1, e2, s, w);
      });
    };
  };

  Commander.prototype['plus-chain'] = function(root, head, tail) {
    return this._chainer_math(head, tail, 'plus');
  };

  Commander.prototype['minus-chain'] = function(root, head, tail) {
    return this._chainer_math(head, tail, 'minus');
  };

  Commander.prototype['multiply-chain'] = function(root, head, tail) {
    return this._chainer_math(head, tail, 'multiply');
  };

  Commander.prototype['divide-chain'] = function(root, head, tail) {
    return this._chainer_math(head, tail, 'divide');
  };

  Commander.prototype._chainer_math = function(head, tail, op) {
    var engine, _e_for_chain;
    engine = this.engine;
    _e_for_chain = this._e_for_chain;
    return function(el, nextEl, query, tracker) {
      var e1, e2;
      e1 = _e_for_chain(el, head, query, tracker);
      e2 = _e_for_chain(nextEl, tail, query, tracker);
      return engine[op](e1, e2);
    };
  };

  Commander.prototype._e_for_chain = function(el, exp, query, tracker, currentEl, nextEl) {
    var e1;
    if (typeof exp === "string") {
      e1 = this.engine.elVar(el, exp, query.selector);
    } else if (typeof exp === "function") {
      e1 = exp.call(this, currentEl, nextEl, query, tracker);
    } else {
      e1 = exp;
    }
    return e1;
  };

  Commander.prototype['for-each'] = function(root, query, callback) {
    var el, _i, _len, _ref;
    _ref = query.nodeList;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      el = _ref[_i];
      callback.call(this.engine, el, query, this.engine);
    }
    return query.on('afterChange', function() {
      var _j, _len1, _ref1, _results;
      _ref1 = query.nodeList;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        el = _ref1[_j];
        _results.push(callback.call(this.engine, el, query));
      }
      return _results;
    });
  };

  Commander.prototype['for-all'] = function(root, query, callback) {
    var _this = this;
    callback.call(this.engine, query, this.engine);
    return query.on('afterChange', function() {
      return callback.call(_this.engine, query, _this.engine);
    });
  };

  Commander.prototype['js'] = function(root, js) {
    eval("var callback =" + js);
    return callback;
  };

  Commander.prototype['strength'] = function(root, s) {
    return ['strength', s];
  };

  Commander.prototype['$class'] = function(root, sel) {
    var query,
      _this = this;
    query = this.engine.registerDomQuery({
      selector: "." + sel,
      isMulti: true,
      isLive: true,
      createNodeList: function() {
        return _this.engine.queryScope.getElementsByClassName(sel);
      }
    });
    bindRoot(root, query);
    return query;
  };

  Commander.prototype['$tag'] = function(root, sel) {
    var query,
      _this = this;
    query = this.engine.registerDomQuery({
      selector: sel,
      isMulti: true,
      isLive: true,
      createNodeList: function() {
        return _this.engine.queryScope.getElementsByTagName(sel);
      }
    });
    bindRoot(root, query);
    return query;
  };

  Commander.prototype['$reserved'] = function(root, sel) {
    var engine, query;
    query = null;
    if (sel === 'window') {
      return 'window';
    } else if (sel === 'this' || sel === 'scope') {
      engine = this.engine;
      query = this.engine.registerDomQuery({
        selector: "::" + sel,
        isMulti: false,
        isLive: true,
        createNodeList: function() {
          return [engine.scope];
        }
      });
      query.__is_scope = true;
      bindRoot(root, query);
      return query;
    } else {
      throw new Error("$reserved selectors not yet handled: " + sel);
    }
    return query;
  };

  Commander.prototype['$id'] = function(root, sel) {
    var query,
      _this = this;
    query = this.engine.registerDomQuery({
      selector: "#" + sel,
      isMulti: false,
      isLive: false,
      createNodeList: function() {
        var el;
        el = document.getElementById(sel);
        return [el];
      }
    });
    bindRoot(root, query);
    return query;
  };

  return Commander;

})();

module.exports = Commander;

});
require.register("the-gss-engine/lib/Thread.js", function(exports, require, module){
var Thread,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __slice = [].slice;

Thread = (function() {
  function Thread() {
    this._remove = __bind(this._remove, this);
    this['remove'] = __bind(this['remove'], this);
    this.stay = __bind(this.stay, this);
    this.suggest = __bind(this.suggest, this);
    this._editvar = __bind(this._editvar, this);
    this.gt = __bind(this.gt, this);
    this.lt = __bind(this.lt, this);
    this.gte = __bind(this.gte, this);
    this.lte = __bind(this.lte, this);
    this.eq = __bind(this.eq, this);
    this._addConstraint = __bind(this._addConstraint, this);
    this._execute = __bind(this._execute, this);
    this.execute = __bind(this.execute, this);
    this;
  }

  Thread.prototype.needsSetup = true;

  Thread.prototype.setupIfNeeded = function() {
    if (!this.needsSetup) {
      return this;
    }
    this.needsSetup = false;
    this.solver = new c.SimplexSolver();
    this.solver.autoSolve = false;
    this.cachedVars = {};
    this.constraintsByTracker = {};
    this.varIdsByTracker = {};
    this.__editVarNames = [];
    return this;
  };

  Thread.prototype.postMessage = function(message) {
    this.execute(message);
    return this;
  };

  Thread.prototype.terminate = function() {
    this.needsSetup = true;
    this.solver = null;
    this.cachedVars = null;
    this.constraintsByTracker = null;
    this.varIdsByTracker = null;
    this.__editVarNames = null;
    return this;
  };

  Thread.prototype.execute = function(message) {
    var command, _i, _len, _ref;
    this.setupIfNeeded();
    _ref = message.commands;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      command = _ref[_i];
      this._execute(command, command);
    }
    return this;
  };

  Thread.prototype._execute = function(command, root) {
    var func, i, node, sub, _i, _len, _ref;
    node = command;
    func = this[node[0]];
    if (func == null) {
      throw new Error("Thread.execute broke, couldn't find method: " + node[0]);
    }
    _ref = node.slice(1, +node.length + 1 || 9e9);
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      sub = _ref[i];
      if (sub instanceof Array) {
        node.splice(i + 1, 1, this._execute(sub, root));
      }
    }
    return func.call.apply(func, [this, root].concat(__slice.call(node.slice(1, node.length))));
  };

  Thread.prototype.getValues = function() {
    var id, o;
    this.solver.solve();
    o = {};
    for (id in this.cachedVars) {
      o[id] = this.cachedVars[id].value;
    }
    return o;
  };

  Thread.prototype.number = function(root, num) {
    return Number(num);
  };

  Thread.prototype._trackVarId = function(id, tracker) {
    if (!this.varIdsByTracker[tracker]) {
      this.varIdsByTracker[tracker] = [];
    }
    if (this.varIdsByTracker[tracker].indexOf(id) === -1) {
      return this.varIdsByTracker[tracker].push(id);
    }
  };

  Thread.prototype["var"] = function(self, id, tracker) {
    var v;
    if (this.cachedVars[id]) {
      return this.cachedVars[id];
    }
    v = new c.Variable({
      name: id
    });
    if (tracker) {
      this._trackVarId(id, tracker);
      v._tracker = tracker;
      v._is_tracked = true;
    }
    this.cachedVars[id] = v;
    return v;
  };

  Thread.prototype.varexp = function(self, id, expression, tracker) {
    var cv;
    cv = this.cachedVars;
    if (cv[id]) {
      return cv[id];
    }
    if (!(expression instanceof c.Expression)) {
      throw new Error("Thread `varexp` requires an instance of c.Expression");
    }
    Object.defineProperty(cv, id, {
      get: function() {
        var clone;
        clone = expression.clone();
        if (tracker) {
          this._trackVarId(id, tracker);
          clone._tracker = tracker;
          clone._is_tracked = true;
        }
        return clone;
      }
    });
    return expression;
  };

  Thread.prototype._trackRootIfNeeded = function(root, tracker) {
    if (tracker) {
      root._is_tracked = true;
      if (!root._trackers) {
        root._trackers = [];
      }
      if (root._trackers.indexOf(tracker) === -1) {
        return root._trackers.push(tracker);
      }
    }
  };

  Thread.prototype.get = function(root, id, tracker, tracker2) {
    var v;
    v = this.cachedVars[id];
    if (v) {
      this._trackRootIfNeeded(root, tracker);
      this._trackRootIfNeeded(root, tracker2);
      this._trackRootIfNeeded(root, v.tracker);
      return v;
    }
    throw new Error("AST method 'get' couldn't find var with id: " + id);
  };

  Thread.prototype.plus = function(root, e1, e2) {
    return c.plus(e1, e2);
  };

  Thread.prototype.minus = function(root, e1, e2) {
    return c.minus(e1, e2);
  };

  Thread.prototype.multiply = function(root, e1, e2) {
    return c.times(e1, e2);
  };

  Thread.prototype.divide = function(root, e1, e2, s, w) {
    return c.divide(e1, e2);
  };

  Thread.prototype._strength = function(s) {
    var strength;
    if (s == null) {
      s = 'required';
    }
    if (typeof s === 'string') {
      if (s === 'require') {
        s = 'required';
      }
      strength = c.Strength[s];
      return strength;
    }
    return s;
    /*   
    if strength.symbolicWeight?
      return strength
    else
      throw new Error("Unrecognized Strength: #{s}")
    */

  };

  Thread.prototype._addConstraint = function(root, constraint) {
    var tracker, _i, _len, _ref;
    this.solver.addConstraint(constraint);
    if (root._is_tracked) {
      _ref = root._trackers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tracker = _ref[_i];
        if (!this.constraintsByTracker[tracker]) {
          this.constraintsByTracker[tracker] = [];
        }
        this.constraintsByTracker[tracker].push(constraint);
      }
    }
    return constraint;
  };

  Thread.prototype.eq = function(self, e1, e2, s, w) {
    return this._addConstraint(self, new c.Equation(e1, e2, this._strength(s), w));
  };

  Thread.prototype.lte = function(self, e1, e2, s, w) {
    return this._addConstraint(self, new c.Inequality(e1, c.LEQ, e2, this._strength(s), w));
  };

  Thread.prototype.gte = function(self, e1, e2, s, w) {
    return this._addConstraint(self, new c.Inequality(e1, c.GEQ, e2, this._strength(s), w));
  };

  Thread.prototype.lt = function(self, e1, e2, s, w) {
    return this._addConstraint(self, new c.Inequality(e1, c.LEQ, e2, this._strength(s), w));
  };

  Thread.prototype.gt = function(self, e1, e2, s, w) {
    return this._addConstraint(self, new c.Inequality(e1, c.GEQ, e2, this._strength(s), w));
  };

  Thread.prototype._editvar = function(varr, s, w) {
    if (this.__editVarNames.indexOf(varr.name) === -1) {
      this.__editVarNames.push(varr.name);
      this.solver.addEditVar(varr, this._strength(s), w);
    }
    return this;
  };

  Thread.prototype.suggest = function(self, varr, val, s, w) {
    if (s == null) {
      s = 'strong';
    }
    if (typeof varr === 'string') {
      varr = this.get(self, varr);
    }
    this._editvar(varr, s, w);
    this.solver.suggestValue(varr, val);
    return this.solver.resolve();
  };

  Thread.prototype.stay = function(self) {
    var args, v, _i, _len, _ref;
    args = __slice.call(arguments);
    _ref = args.slice(1, args.length);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      this.solver.addStay(v);
    }
    return this.solver;
  };

  Thread.prototype['remove'] = function(self) {
    var args, tracker, trackers, _i, _len, _results;
    args = __slice.call(arguments);
    trackers = __slice.call(args.slice(1, args.length));
    _results = [];
    for (_i = 0, _len = trackers.length; _i < _len; _i++) {
      tracker = trackers[_i];
      _results.push(this._remove(tracker));
    }
    return _results;
  };

  Thread.prototype._remove = function(tracker) {
    var constraint, error, id, movealong, _i, _j, _len, _len1, _ref, _ref1;
    delete this.__editVarNames[tracker];
    if (this.constraintsByTracker[tracker]) {
      _ref = this.constraintsByTracker[tracker];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        constraint = _ref[_i];
        try {
          this.solver.removeConstraint(constraint);
        } catch (_error) {
          error = _error;
          movealong = 'please';
        }
      }
      delete this.constraintsByTracker[tracker];
    }
    if (this.varIdsByTracker[tracker]) {
      _ref1 = this.varIdsByTracker[tracker];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        id = _ref1[_j];
        delete this.cachedVars[id];
      }
      return delete this.varIdsByTracker[tracker];
    }
  };

  return Thread;

})();

if (typeof module !== "undefined" && module !== null ? module.exports : void 0) {
  module.exports = Thread;
}

});
require.register("the-gss-engine/lib/dom/Getter.js", function(exports, require, module){
var Getter;

Getter = (function() {
  function Getter(scope) {
    this.scope = scope;
    this.styleNodes = null;
    if (!this.scope) {
      this.scope = document;
    }
  }

  Getter.prototype.clean = function() {};

  Getter.prototype.destroy = function() {
    this.scope = null;
    return this.styleNodes = null;
  };

  Getter.prototype.get = function(selector) {
    var identifier, method;
    method = selector[0];
    identifier = selector[1];
    switch (method) {
      case "$reserved":
        if (identifier === 'this') {
          return this.scope;
        }
        break;
      case "$id":
        if (identifier[0] === '#') {
          identifier = identifier.substr(1);
        }
        return document.getElementById(identifier);
      case "$class":
        if (identifier[0] === '.') {
          identifier = identifier.substr(1);
        }
        return this.scope.getElementsByClassName(identifier);
      case "$tag":
        return this.scope.getElementsByTagName(identifier);
    }
    return this.scope.querySelectorAll(identifier);
  };

  Getter.prototype.measure = function(node, dimension) {
    var scroll;
    switch (dimension) {
      case 'width':
      case 'w':
        return node.getBoundingClientRect().width;
      case 'height':
      case 'h':
        return node.getBoundingClientRect().height;
      case 'left':
      case 'x':
        scroll = window.scrollX || window.scrollLeft || 0;
        return node.getBoundingClientRect().left + scroll;
      case 'top':
      case 'y':
        scroll = window.scrollY || window.scrollTop || 0;
        return node.getBoundingClientRect().top + scroll;
      case 'bottom':
        return this.measure(node, 'top') + this.measure(node, 'height');
      case 'right':
        return this.measure(node, 'left') + this.measure(node, 'width');
      case 'centerX':
        return this.measure(node, 'left') + this.measure(node, 'width') / 2;
      case 'centerY':
        return this.measure(node, 'top') + this.measure(node, 'height') / 2;
    }
  };

  Getter.prototype.offsets = function(element) {
    var offsets;
    offsets = {
      x: 0,
      y: 0
    };
    if (!element.offsetParent) {
      return offsets;
    }
    element = element.offsetParent;
    while (true) {
      offsets.x += element.offsetLeft;
      offsets.y += element.offsetTop;
      if (!element.offsetParent) {
        break;
      }
      element = element.offsetParent;
    }
    return offsets;
  };

  Getter.prototype.view = function(node) {
    return GSS.View.byId[GSS.getId(node)];
  };

  Getter.prototype.getAllStyleNodes = function() {
    if (!this.styleNodes) {
      this.styleNodes = this.scope.getElementsByTagName("style");
    }
    return this.styleNodes;
  };

  Getter.prototype.readAllASTs = function() {
    var AST, ASTs, node, _i, _len, _ref;
    ASTs = [];
    _ref = this.getAllStyleNodes();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      AST = this.readAST(node);
      if (AST) {
        ASTs.push(AST);
      }
    }
    return ASTs;
  };

  Getter.prototype.scopeFor = function(node) {
    if (this.isStyleNode(node)) {
      return this.scopeForStyleNode(node);
    } else {
      return this.nearestScope(node);
    }
  };

  Getter.prototype.isStyleNode = function(node) {
    var mime;
    if ((node != null ? node.tagName : void 0) === "STYLE") {
      mime = typeof node.getAttribute === "function" ? node.getAttribute("type") : void 0;
      if (mime) {
        return mime.indexOf("text/gss") === 0;
      }
    }
    return false;
  };

  Getter.prototype.scopeForStyleNode = function(node) {
    return node.parentElement;
  };

  Getter.prototype.isScope = function(el) {
    return !!(el != null ? el._gss_is_scope : void 0);
  };

  Getter.prototype.nearestScope = function(el, skipSelf) {
    if (skipSelf == null) {
      skipSelf = false;
    }
    if (skipSelf) {
      el = el.parentElement;
    }
    while (el.parentElement) {
      if (this.isScope(el)) {
        return el;
      }
      el = el.parentElement;
    }
    return null;
  };

  Getter.prototype.nearestEngine = function(el, skipSelf) {
    var scope;
    if (skipSelf == null) {
      skipSelf = false;
    }
    scope = this.nearestScope(el, skipSelf);
    if (scope) {
      return this.engine(scope);
    }
    return null;
  };

  Getter.prototype.descdendantNodes = function(el) {
    return el.getElementsByTagName("*");
  };

  Getter.prototype.engine = function(el) {
    return GSS.engines.byId[GSS.getId(el)];
  };

  Getter.prototype.readAST = function(node) {
    var mime, reader;
    mime = node.getAttribute("type");
    reader = this["readAST:" + mime];
    if (reader) {
      return reader.call(this, node);
    }
    return null;
  };

  Getter.prototype['readAST:text/gss-ast'] = function(node) {
    var ast, e, source;
    source = node.textContent.trim();
    if (source.length === 0) {
      return {};
    }
    try {
      ast = JSON.parse(source);
    } catch (_error) {
      e = _error;
      console.error("Parsing compiled gss error", console.dir(e));
    }
    return ast;
  };

  Getter.prototype['readAST:text/gss'] = function(node) {
    throw new Error("did not include GSS's compilers");
  };

  return Getter;

})();

Getter.getRootScope = function() {
  return document.body;
};

module.exports = Getter;

});
require.register("the-gss-engine/lib/dom/IdMixin.js", function(exports, require, module){
var IdMixin;

IdMixin = {
  uid: function() {
    return this._id_counter++;
  },
  _id_counter: 1,
  _byIdCache: {},
  _ids_killed: function(ids) {
    var id, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = ids.length; _i < _len; _i++) {
      id = ids[_i];
      _results.push(this._id_killed(id));
    }
    return _results;
  },
  _id_killed: function(id) {
    var _ref;
    this._byIdCache[id] = null;
    delete this._byIdCache[id];
    return (_ref = GSS.View.byId[id]) != null ? typeof _ref.recycle === "function" ? _ref.recycle() : void 0 : void 0;
  },
  getById: function(id) {
    var el;
    if (this._byIdCache[id]) {
      return this._byIdCache[id];
    }
    el = document.querySelector('[data-gss-id="' + id + '"]');
    if (el) {
      this._byIdCache[id] = el;
    }
    return el;
  },
  setupScopeId: function(el) {
    el._gss_is_scope = true;
    return this.setupId(el);
  },
  setupId: function(el) {
    var gid, _id;
    if (!el) {
      return null;
    }
    gid = this.getId(el);
    if (gid == null) {
      _id = this.uid();
      gid = String(el.id || _id);
      el.setAttribute('data-gss-id', gid);
      el.style['box-sizing'] = 'border-box';
      el._gss_id = gid;
      GSS.View["new"]({
        el: el,
        id: gid
      });
      if (this._byIdCache[gid] != null) {
        GSS.warn("element by id cache replaced gss-id: " + gid);
      }
    }
    this._byIdCache[gid] = el;
    return gid;
  },
  getId: function(el) {
    if (el != null ? el._gss_id : void 0) {
      return el != null ? el._gss_id : void 0;
    }
    return null;
  }
};

module.exports = IdMixin;

});
require.register("gss/lib/gss.js", function(exports, require, module){
var compiler, link, remoteGSS, runRemotes, _i, _len;

compiler = require("gss-compiler");

if (!window.GSS_CONFIG) {
  window.GSS_CONFIG = {};
}

if (!window.GSS_CONFIG.workerURL) {
  window.GSS_CONFIG.workerURL = '../browser/the-gss-engine/worker/gss-solver.js';
}

require("gss-engine");

GSS.compile = function(rules) {
  var ast, e;
  ast = {};
  if (typeof rules === "string") {
    try {
      ast = compiler.compile(rules);
    } catch (_error) {
      e = _error;
      console.warn("compiler error", e);
      ast = {};
    }
  } else if (typeof rules === "object") {
    ast = rules;
  } else {
    throw new Error("Unrecognized GSS rule format. Should be string or AST");
  }
  return ast;
};

GSS.Engine.prototype['compile'] = function(source) {
  return this.run(GSS.compile(source));
};

GSS.Getter.prototype['readAST:text/gss'] = function(node) {
  var ast, source;
  source = node.textContent.trim();
  if (source.length === 0) {
    return {};
  }
  ast = GSS.compile(source);
  return ast;
};

runRemotes = function(url) {
  var req;
  req = new XMLHttpRequest;
  req.onreadystatechange = function() {
    var engine;
    if (req.readyState !== 4) {
      return;
    }
    if (req.status !== 200) {
      return;
    }
    engine = GSS(document);
    return engine.compile(req.responseText);
  };
  req.open('GET', url, true);
  return req.send(null);
};

remoteGSS = document.querySelectorAll('link[rel="stylesheet"][type="text/gss"]');

if (remoteGSS) {
  for (_i = 0, _len = remoteGSS.length; _i < _len; _i++) {
    link = remoteGSS[_i];
    runRemotes(link.getAttribute('href'));
  }
}

});





require.alias("the-gss-compiler/lib/gss-compiler.js", "gss/deps/gss-compiler/lib/gss-compiler.js");
require.alias("the-gss-compiler/lib/gss-compiler.js", "gss/deps/gss-compiler/index.js");
require.alias("the-gss-compiler/lib/gss-compiler.js", "gss-compiler/index.js");
require.alias("the-gss-preparser/lib/gss-preparser.js", "the-gss-compiler/deps/gss-preparser/lib/gss-preparser.js");
require.alias("the-gss-preparser/lib/gss-preparser.js", "the-gss-compiler/deps/gss-preparser/index.js");
require.alias("the-gss-preparser/lib/gss-preparser.js", "the-gss-preparser/index.js");
require.alias("the-gss-ccss-compiler/lib/ccss-compiler.js", "the-gss-compiler/deps/ccss-compiler/lib/ccss-compiler.js");
require.alias("the-gss-ccss-compiler/lib/ccss-compiler.js", "the-gss-compiler/deps/ccss-compiler/index.js");
require.alias("the-gss-ccss-compiler/lib/ccss-compiler.js", "the-gss-ccss-compiler/index.js");
require.alias("the-gss-vfl-compiler/lib/vfl-compiler.js", "the-gss-compiler/deps/vfl-compiler/lib/vfl-compiler.js");
require.alias("the-gss-vfl-compiler/lib/compiler.js", "the-gss-compiler/deps/vfl-compiler/lib/compiler.js");
require.alias("the-gss-vfl-compiler/lib/compiler.js", "the-gss-compiler/deps/vfl-compiler/index.js");
require.alias("the-gss-ccss-compiler/lib/ccss-compiler.js", "the-gss-vfl-compiler/deps/ccss-compiler/lib/ccss-compiler.js");
require.alias("the-gss-ccss-compiler/lib/ccss-compiler.js", "the-gss-vfl-compiler/deps/ccss-compiler/index.js");
require.alias("the-gss-ccss-compiler/lib/ccss-compiler.js", "the-gss-ccss-compiler/index.js");
require.alias("the-gss-vfl-compiler/lib/compiler.js", "the-gss-vfl-compiler/index.js");
require.alias("the-gss-compiler/lib/gss-compiler.js", "the-gss-compiler/index.js");
require.alias("the-gss-engine/lib/GSS.js", "gss/deps/gss-engine/lib/GSS.js");
require.alias("the-gss-engine/lib/_.js", "gss/deps/gss-engine/lib/_.js");
require.alias("the-gss-engine/lib/EventTrigger.js", "gss/deps/gss-engine/lib/EventTrigger.js");
require.alias("the-gss-engine/lib/dom/Query.js", "gss/deps/gss-engine/lib/dom/Query.js");
require.alias("the-gss-engine/lib/dom/View.js", "gss/deps/gss-engine/lib/dom/View.js");
require.alias("the-gss-engine/lib/dom/Observer.js", "gss/deps/gss-engine/lib/dom/Observer.js");
require.alias("the-gss-engine/lib/Engine.js", "gss/deps/gss-engine/lib/Engine.js");
require.alias("the-gss-engine/lib/Commander.js", "gss/deps/gss-engine/lib/Commander.js");
require.alias("the-gss-engine/lib/Thread.js", "gss/deps/gss-engine/lib/Thread.js");
require.alias("the-gss-engine/lib/dom/Getter.js", "gss/deps/gss-engine/lib/dom/Getter.js");
require.alias("the-gss-engine/lib/dom/IdMixin.js", "gss/deps/gss-engine/lib/dom/IdMixin.js");
require.alias("the-gss-engine/lib/GSS.js", "gss/deps/gss-engine/index.js");
require.alias("the-gss-engine/lib/GSS.js", "gss-engine/index.js");
require.alias("d4tocchini-customevent-polyfill/CustomEvent.js", "the-gss-engine/deps/customevent-polyfill/CustomEvent.js");
require.alias("d4tocchini-customevent-polyfill/CustomEvent.js", "the-gss-engine/deps/customevent-polyfill/index.js");
require.alias("d4tocchini-customevent-polyfill/CustomEvent.js", "d4tocchini-customevent-polyfill/index.js");
require.alias("slightlyoff-cassowary.js/index.js", "the-gss-engine/deps/cassowary/index.js");
require.alias("slightlyoff-cassowary.js/src/c.js", "the-gss-engine/deps/cassowary/src/c.js");
require.alias("slightlyoff-cassowary.js/src/HashTable.js", "the-gss-engine/deps/cassowary/src/HashTable.js");
require.alias("slightlyoff-cassowary.js/src/HashSet.js", "the-gss-engine/deps/cassowary/src/HashSet.js");
require.alias("slightlyoff-cassowary.js/src/Error.js", "the-gss-engine/deps/cassowary/src/Error.js");
require.alias("slightlyoff-cassowary.js/src/SymbolicWeight.js", "the-gss-engine/deps/cassowary/src/SymbolicWeight.js");
require.alias("slightlyoff-cassowary.js/src/Strength.js", "the-gss-engine/deps/cassowary/src/Strength.js");
require.alias("slightlyoff-cassowary.js/src/Variable.js", "the-gss-engine/deps/cassowary/src/Variable.js");
require.alias("slightlyoff-cassowary.js/src/Point.js", "the-gss-engine/deps/cassowary/src/Point.js");
require.alias("slightlyoff-cassowary.js/src/Expression.js", "the-gss-engine/deps/cassowary/src/Expression.js");
require.alias("slightlyoff-cassowary.js/src/Constraint.js", "the-gss-engine/deps/cassowary/src/Constraint.js");
require.alias("slightlyoff-cassowary.js/src/EditInfo.js", "the-gss-engine/deps/cassowary/src/EditInfo.js");
require.alias("slightlyoff-cassowary.js/src/Tableau.js", "the-gss-engine/deps/cassowary/src/Tableau.js");
require.alias("slightlyoff-cassowary.js/src/SimplexSolver.js", "the-gss-engine/deps/cassowary/src/SimplexSolver.js");
require.alias("slightlyoff-cassowary.js/src/Timer.js", "the-gss-engine/deps/cassowary/src/Timer.js");
require.alias("slightlyoff-cassowary.js/src/parser/parser.js", "the-gss-engine/deps/cassowary/src/parser/parser.js");
require.alias("slightlyoff-cassowary.js/src/parser/api.js", "the-gss-engine/deps/cassowary/src/parser/api.js");

require.alias("the-gss-engine/lib/GSS.js", "the-gss-engine/index.js");
require.alias("gss/lib/gss.js", "gss/index.js");if (typeof exports == "object") {
  module.exports = require("gss");
} else if (typeof define == "function" && define.amd) {
  define(function(){ return require("gss"); });
} else {
  this["gss"] = require("gss");
}})();