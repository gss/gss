
/**
 * Require the given path.
 *
 * @param {String} path
 * @return {Object} exports
 * @api public
 */

function require(path, parent, orig) {
  var resolved = require.resolve(path);

  // lookup failed
  if (null == resolved) {
    orig = orig || path;
    parent = parent || 'root';
    var err = new Error('Failed to require "' + orig + '" from "' + parent + '"');
    err.path = orig;
    err.parent = parent;
    err.require = true;
    throw err;
  }

  var module = require.modules[resolved];

  // perform real require()
  // by invoking the module's
  // registered function
  if (!module.exports) {
    module.exports = {};
    module.client = module.component = true;
    module.call(this, module.exports, require.relative(resolved), module);
  }

  return module.exports;
}

/**
 * Registered modules.
 */

require.modules = {};

/**
 * Registered aliases.
 */

require.aliases = {};

/**
 * Resolve `path`.
 *
 * Lookup:
 *
 *   - PATH/index.js
 *   - PATH.js
 *   - PATH
 *
 * @param {String} path
 * @return {String} path or null
 * @api private
 */

require.resolve = function(path) {
  if (path.charAt(0) === '/') path = path.slice(1);

  var paths = [
    path,
    path + '.js',
    path + '.json',
    path + '/index.js',
    path + '/index.json'
  ];

  for (var i = 0; i < paths.length; i++) {
    var path = paths[i];
    if (require.modules.hasOwnProperty(path)) return path;
    if (require.aliases.hasOwnProperty(path)) return require.aliases[path];
  }
};

/**
 * Normalize `path` relative to the current path.
 *
 * @param {String} curr
 * @param {String} path
 * @return {String}
 * @api private
 */

require.normalize = function(curr, path) {
  var segs = [];

  if ('.' != path.charAt(0)) return path;

  curr = curr.split('/');
  path = path.split('/');

  for (var i = 0; i < path.length; ++i) {
    if ('..' == path[i]) {
      curr.pop();
    } else if ('.' != path[i] && '' != path[i]) {
      segs.push(path[i]);
    }
  }

  return curr.concat(segs).join('/');
};

/**
 * Register module at `path` with callback `definition`.
 *
 * @param {String} path
 * @param {Function} definition
 * @api private
 */

require.register = function(path, definition) {
  require.modules[path] = definition;
};

/**
 * Alias a module definition.
 *
 * @param {String} from
 * @param {String} to
 * @api private
 */

require.alias = function(from, to) {
  if (!require.modules.hasOwnProperty(from)) {
    throw new Error('Failed to alias "' + from + '", it does not exist');
  }
  require.aliases[to] = from;
};

/**
 * Return a require function relative to the `parent` path.
 *
 * @param {String} parent
 * @return {Function}
 * @api private
 */

require.relative = function(parent) {
  var p = require.normalize(parent, '..');

  /**
   * lastIndexOf helper.
   */

  function lastIndexOf(arr, obj) {
    var i = arr.length;
    while (i--) {
      if (arr[i] === obj) return i;
    }
    return -1;
  }

  /**
   * The relative require() itself.
   */

  function localRequire(path) {
    var resolved = localRequire.resolve(path);
    return require(resolved, parent, path);
  }

  /**
   * Resolve relative to the parent.
   */

  localRequire.resolve = function(path) {
    var c = path.charAt(0);
    if ('/' == c) return path.slice(1);
    if ('.' == c) return require.normalize(p, path);

    // resolve deps by returning
    // the dep in the nearest "deps"
    // directory
    var segs = parent.split('/');
    var i = lastIndexOf(segs, 'deps') + 1;
    if (!i) i = 0;
    path = segs.slice(0, i + 1).join('/') + '/deps/' + path;
    return path;
  };

  /**
   * Check if module is defined at `path`.
   */

  localRequire.exists = function(path) {
    return require.modules.hasOwnProperty(localRequire.resolve(path));
  };

  return localRequire;
};
require.register("the-gss-preparser/lib/gss-preparser.js", function(exports, require, module){
module.exports = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "start": parse_start,
        "statement": parse_statement,
        "gssBlob": parse_gssBlob,
        "ccss": parse_ccss,
        "ccssOp": parse_ccssOp,
        "vfl": parse_vfl,
        "gtl": parse_gtl,
        "cssBlock": parse_cssBlock,
        "cssLine": parse_cssLine,
        "comment": parse_comment,
        "_": parse__,
        "__": parse___,
        "char": parse_char,
        "anychar": parse_anychar,
        "multitoend": parse_multitoend,
        "anytoend": parse_anytoend,
        "LineTerminator": parse_LineTerminator
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "start";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_start() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = [];
        result1 = parse_LineTerminator();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_LineTerminator();
        }
        if (result0 !== null) {
          result2 = parse_statement();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_statement();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, s) {return s})(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_statement() {
        var result0;
        
        result0 = parse_gssBlob();
        if (result0 === null) {
          result0 = parse_cssBlock();
          if (result0 === null) {
            result0 = parse_cssLine();
          }
        }
        return result0;
      }
      
      function parse_gssBlob() {
        var result0;
        
        result0 = parse_ccss();
        if (result0 === null) {
          result0 = parse_vfl();
          if (result0 === null) {
            result0 = parse_gtl();
          }
        }
        return result0;
      }
      
      function parse_ccss() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse__();
        if (result0 !== null) {
          result2 = parse_char();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_char();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse__();
            if (result2 !== null) {
              result3 = parse_ccssOp();
              if (result3 !== null) {
                result4 = parse_anytoend();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, ccss) { return ['ccss', parser.stringify(ccss)]; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse__();
          if (result0 !== null) {
            if (input.charCodeAt(pos) === 64) {
              result1 = "@";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"@\"");
              }
            }
            if (result1 !== null) {
              if (input.substr(pos, 9) === "-gss-stay") {
                result2 = "-gss-stay";
                pos += 9;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-gss-stay\"");
                }
              }
              if (result2 === null) {
                if (input.substr(pos, 4) === "stay") {
                  result2 = "stay";
                  pos += 4;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"stay\"");
                  }
                }
              }
              if (result2 !== null) {
                result3 = parse_anytoend();
                if (result3 !== null) {
                  result0 = [result0, result1, result2, result3];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, stay) { return ['ccss', parser.stringify(stay)]; })(pos0, result0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_ccssOp() {
        var result0;
        
        if (input.substr(pos, 2) === ">=") {
          result0 = ">=";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\">=\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 2) === "==") {
            result0 = "==";
            pos += 2;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"==\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 2) === "<=") {
              result0 = "<=";
              pos += 2;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"<=\"");
              }
            }
          }
        }
        return result0;
      }
      
      function parse_vfl() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse__();
        if (result0 !== null) {
          if (input.substr(pos, 6) === "@-gss-") {
            result1 = "@-gss-";
            pos += 6;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"@-gss-\"");
            }
          }
          if (result1 === null) {
            if (input.charCodeAt(pos) === 64) {
              result1 = "@";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"@\"");
              }
            }
          }
          if (result1 !== null) {
            if (input.substr(pos, 10) === "horizontal") {
              result2 = "horizontal";
              pos += 10;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"horizontal\"");
              }
            }
            if (result2 === null) {
              if (input.substr(pos, 8) === "vertical") {
                result2 = "vertical";
                pos += 8;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"vertical\"");
                }
              }
              if (result2 === null) {
                if (input.charCodeAt(pos) === 104) {
                  result2 = "h";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"h\"");
                  }
                }
                if (result2 === null) {
                  if (input.charCodeAt(pos) === 118) {
                    result2 = "v";
                    pos++;
                  } else {
                    result2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"v\"");
                    }
                  }
                }
              }
            }
            if (result2 !== null) {
              result3 = parse_anytoend();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, vfl) { return ['vfl', parser.stringify(vfl)]; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_gtl() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse__();
        if (result0 !== null) {
          if (input.substr(pos, 6) === "@-gss-") {
            result1 = "@-gss-";
            pos += 6;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"@-gss-\"");
            }
          }
          if (result1 !== null) {
            if (input.substr(pos, 6) === "layout") {
              result2 = "layout";
              pos += 6;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"layout\"");
              }
            }
            if (result2 === null) {
              if (input.substr(pos, 8) === "template") {
                result2 = "template";
                pos += 8;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"template\"");
                }
              }
            }
            if (result2 !== null) {
              result3 = parse_multitoend();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, gtl) { return ['gtl', parser.stringify(gtl)]; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_cssBlock() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result1 = parse_anychar();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_anychar();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = parse_multitoend();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, block) { return ['css', parser.stringify(block)]; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_cssLine() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result1 = parse_anychar();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_anychar();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = parse_anytoend();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, line) { return ['css', parser.stringify(line)]; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_comment() {
        var result0, result1, result2, result3, result4, result5, result6, result7, result8;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse__();
        if (result0 !== null) {
          if (input.substr(pos, 2) === "/*") {
            result1 = "/*";
            pos += 2;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"/*\"");
            }
          }
          if (result1 !== null) {
            result2 = [];
            if (/^[^*]/.test(input.charAt(pos))) {
              result3 = input.charAt(pos);
              pos++;
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("[^*]");
              }
            }
            while (result3 !== null) {
              result2.push(result3);
              if (/^[^*]/.test(input.charAt(pos))) {
                result3 = input.charAt(pos);
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("[^*]");
                }
              }
            }
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 42) {
                result4 = "*";
                pos++;
              } else {
                result4 = null;
                if (reportFailures === 0) {
                  matchFailed("\"*\"");
                }
              }
              if (result4 !== null) {
                result3 = [];
                while (result4 !== null) {
                  result3.push(result4);
                  if (input.charCodeAt(pos) === 42) {
                    result4 = "*";
                    pos++;
                  } else {
                    result4 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"*\"");
                    }
                  }
                }
              } else {
                result3 = null;
              }
              if (result3 !== null) {
                result4 = [];
                pos2 = pos;
                if (/^[^\/*]/.test(input.charAt(pos))) {
                  result5 = input.charAt(pos);
                  pos++;
                } else {
                  result5 = null;
                  if (reportFailures === 0) {
                    matchFailed("[^\\/*]");
                  }
                }
                if (result5 !== null) {
                  result6 = [];
                  if (/^[^*]/.test(input.charAt(pos))) {
                    result7 = input.charAt(pos);
                    pos++;
                  } else {
                    result7 = null;
                    if (reportFailures === 0) {
                      matchFailed("[^*]");
                    }
                  }
                  while (result7 !== null) {
                    result6.push(result7);
                    if (/^[^*]/.test(input.charAt(pos))) {
                      result7 = input.charAt(pos);
                      pos++;
                    } else {
                      result7 = null;
                      if (reportFailures === 0) {
                        matchFailed("[^*]");
                      }
                    }
                  }
                  if (result6 !== null) {
                    if (input.charCodeAt(pos) === 42) {
                      result8 = "*";
                      pos++;
                    } else {
                      result8 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"*\"");
                      }
                    }
                    if (result8 !== null) {
                      result7 = [];
                      while (result8 !== null) {
                        result7.push(result8);
                        if (input.charCodeAt(pos) === 42) {
                          result8 = "*";
                          pos++;
                        } else {
                          result8 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"*\"");
                          }
                        }
                      }
                    } else {
                      result7 = null;
                    }
                    if (result7 !== null) {
                      result5 = [result5, result6, result7];
                    } else {
                      result5 = null;
                      pos = pos2;
                    }
                  } else {
                    result5 = null;
                    pos = pos2;
                  }
                } else {
                  result5 = null;
                  pos = pos2;
                }
                while (result5 !== null) {
                  result4.push(result5);
                  pos2 = pos;
                  if (/^[^\/*]/.test(input.charAt(pos))) {
                    result5 = input.charAt(pos);
                    pos++;
                  } else {
                    result5 = null;
                    if (reportFailures === 0) {
                      matchFailed("[^\\/*]");
                    }
                  }
                  if (result5 !== null) {
                    result6 = [];
                    if (/^[^*]/.test(input.charAt(pos))) {
                      result7 = input.charAt(pos);
                      pos++;
                    } else {
                      result7 = null;
                      if (reportFailures === 0) {
                        matchFailed("[^*]");
                      }
                    }
                    while (result7 !== null) {
                      result6.push(result7);
                      if (/^[^*]/.test(input.charAt(pos))) {
                        result7 = input.charAt(pos);
                        pos++;
                      } else {
                        result7 = null;
                        if (reportFailures === 0) {
                          matchFailed("[^*]");
                        }
                      }
                    }
                    if (result6 !== null) {
                      if (input.charCodeAt(pos) === 42) {
                        result8 = "*";
                        pos++;
                      } else {
                        result8 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"*\"");
                        }
                      }
                      if (result8 !== null) {
                        result7 = [];
                        while (result8 !== null) {
                          result7.push(result8);
                          if (input.charCodeAt(pos) === 42) {
                            result8 = "*";
                            pos++;
                          } else {
                            result8 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"*\"");
                            }
                          }
                        }
                      } else {
                        result7 = null;
                      }
                      if (result7 !== null) {
                        result5 = [result5, result6, result7];
                      } else {
                        result5 = null;
                        pos = pos2;
                      }
                    } else {
                      result5 = null;
                      pos = pos2;
                    }
                  } else {
                    result5 = null;
                    pos = pos2;
                  }
                }
                if (result4 !== null) {
                  if (input.charCodeAt(pos) === 47) {
                    result5 = "/";
                    pos++;
                  } else {
                    result5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"/\"");
                    }
                  }
                  if (result5 !== null) {
                    result6 = parse__();
                    if (result6 !== null) {
                      result7 = [];
                      result8 = parse_LineTerminator();
                      while (result8 !== null) {
                        result7.push(result8);
                        result8 = parse_LineTerminator();
                      }
                      if (result7 !== null) {
                        result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ""})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse__() {
        var result0, result1;
        
        result0 = [];
        if (input.charCodeAt(pos) === 32) {
          result1 = " ";
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("\" \"");
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          if (input.charCodeAt(pos) === 32) {
            result1 = " ";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\" \"");
            }
          }
        }
        return result0;
      }
      
      function parse___() {
        var result0, result1;
        
        if (input.charCodeAt(pos) === 32) {
          result1 = " ";
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("\" \"");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (input.charCodeAt(pos) === 32) {
              result1 = " ";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\" \"");
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_char() {
        var result0;
        
        if (/^[a-zA-Z0-9_#.[\]\-]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9_#.[\\]\\-]");
          }
        }
        return result0;
      }
      
      function parse_anychar() {
        var result0;
        
        if (/^[a-zA-Z0-9 .,#:{}@+?!^=()_\-$*\/\\]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9 .,#:{}@+?!^=()_\\-$*\\/\\\\]");
          }
        }
        return result0;
      }
      
      function parse_multitoend() {
        var result0, result1, result2, result3, result4;
        var pos0;
        
        pos0 = pos;
        result0 = [];
        if (/^[^}]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[^}]");
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          if (/^[^}]/.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("[^}]");
            }
          }
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 125) {
            result1 = "}";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"}\"");
            }
          }
          if (result1 !== null) {
            result2 = parse__();
            if (result2 !== null) {
              result3 = [];
              result4 = parse_LineTerminator();
              while (result4 !== null) {
                result3.push(result4);
                result4 = parse_LineTerminator();
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_anytoend() {
        var result0, result1, result2, result3, result4;
        var pos0;
        
        pos0 = pos;
        result0 = [];
        if (/^[^;]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[^;]");
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          if (/^[^;]/.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("[^;]");
            }
          }
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 59) {
            result1 = ";";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\";\"");
            }
          }
          if (result1 !== null) {
            result2 = parse__();
            if (result2 !== null) {
              result3 = [];
              result4 = parse_LineTerminator();
              while (result4 !== null) {
                result3.push(result4);
                result4 = parse_LineTerminator();
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_LineTerminator() {
        var result0;
        
        if (/^[\n\r\u2028\u2029]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\n\\r\\u2028\\u2029]");
          }
        }
        if (result0 === null) {
          result0 = parse_comment();
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
        var parser, flatten; 
      
        parser = this;
      
        String.prototype.trim = String.prototype.trim || function trim() { return this.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); };
      
        flatten = parser.flatten = function (array, isShallow) {
          var index = -1,
            length = array ? array.length : 0,
            result = [];
      
          while (++index < length) {
            var value = array[index];
      
            if (value instanceof Array) {
              Array.prototype.push.apply(result, isShallow ? value : flatten(value));
            }
            else {
              result.push(value);
            }
          }
          return result;
        }
        parser.results = []
        parser.stringify = function (array) {
          return flatten(array).join("").trim()
        }
      
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();
});
require.register("the-gss-ccss-compiler/lib/ccss-compiler.js", function(exports, require, module){
module.exports = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "start": parse_start,
        "Statement": parse_Statement,
        "Stay": parse_Stay,
        "StayVars": parse_StayVars,
        "StayStart": parse_StayStart,
        "LinearExpression": parse_LinearExpression,
        "StrengthAndWeight": parse_StrengthAndWeight,
        "Weight": parse_Weight,
        "Strength": parse_Strength,
        "EqOperator": parse_EqOperator,
        "AdditiveExpression": parse_AdditiveExpression,
        "AdditiveOperator": parse_AdditiveOperator,
        "MultiplicativeExpression": parse_MultiplicativeExpression,
        "MultiplicativeOperator": parse_MultiplicativeOperator,
        "UnaryExpression": parse_UnaryExpression,
        "UnaryOperator": parse_UnaryOperator,
        "PrimaryExpression": parse_PrimaryExpression,
        "Measure": parse_Measure,
        "Var": parse_Var,
        "VarNames": parse_VarNames,
        "Selector": parse_Selector,
        "ReservedPseudos": parse_ReservedPseudos,
        "NameChars": parse_NameChars,
        "NameCharsWithSpace": parse_NameCharsWithSpace,
        "Literal": parse_Literal,
        "Integer": parse_Integer,
        "Real": parse_Real,
        "SignedInteger": parse_SignedInteger,
        "SourceCharacter": parse_SourceCharacter,
        "WhiteSpace": parse_WhiteSpace,
        "LineTerminator": parse_LineTerminator,
        "LineTerminatorSequence": parse_LineTerminatorSequence,
        "EOS": parse_EOS,
        "EOF": parse_EOF,
        "Comment": parse_Comment,
        "MultiLineComment": parse_MultiLineComment,
        "MultiLineCommentNoLineTerminator": parse_MultiLineCommentNoLineTerminator,
        "SingleLineComment": parse_SingleLineComment,
        "_": parse__,
        "__": parse___
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "start";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_start() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse___();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_Statement();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_Statement();
          }
          if (result1 !== null) {
            result2 = parse___();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, statements) { return (parser.getResults()); })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Statement() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_LinearExpression();
        if (result0 !== null) {
          result1 = parse_EOS();
          if (result1 !== null) {
            result2 = parse___();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, exp) { return exp; })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          result0 = parse_Stay();
          if (result0 !== null) {
            result0 = (function(offset, stay) { return stay; })(pos0, result0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_Stay() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_StayStart();
        if (result0 !== null) {
          result2 = parse_StayVars();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_StayVars();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_EOS();
            if (result2 !== null) {
              result3 = parse___();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, vars) {
              var stay = ["stay"].concat(vars)
              parser.addC(stay)
              return stay;
            })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_StayVars() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse___();
        if (result0 !== null) {
          result1 = parse_Var();
          if (result1 !== null) {
            result2 = parse___();
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 44) {
                result3 = ",";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\",\"");
                }
              }
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, v) {return v})(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_StayStart() {
        var result0;
        
        if (input.substr(pos, 10) === "@-gss-stay") {
          result0 = "@-gss-stay";
          pos += 10;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"@-gss-stay\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 5) === "@stay") {
            result0 = "@stay";
            pos += 5;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"@stay\"");
            }
          }
        }
        return result0;
      }
      
      function parse_LinearExpression() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_AdditiveExpression();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse___();
          if (result2 !== null) {
            result3 = parse_EqOperator();
            if (result3 !== null) {
              result4 = parse___();
              if (result4 !== null) {
                result5 = parse_AdditiveExpression();
                if (result5 !== null) {
                  result2 = [result2, result3, result4, result5];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse___();
            if (result2 !== null) {
              result3 = parse_EqOperator();
              if (result3 !== null) {
                result4 = parse___();
                if (result4 !== null) {
                  result5 = parse_AdditiveExpression();
                  if (result5 !== null) {
                    result2 = [result2, result3, result4, result5];
                  } else {
                    result2 = null;
                    pos = pos2;
                  }
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result2 = parse___();
            if (result2 !== null) {
              result3 = parse_StrengthAndWeight();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, e1, tail, s) {
              var eq, e2;
              if (s.length === 0) {s = [];}
              for (var i = 0; i < tail.length; i++) {
                eq = tail[i][1];
                e2 = tail[i][3];
                parser.addC([
                  eq,
                  e1,
                  e2
                ].concat(s));
                e1 = e2;
              }
              return "LineaerExpression";
            })(pos0, result0[0], result0[1], result0[3]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_StrengthAndWeight() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 33) {
          result0 = "!";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"!\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_Strength();
          if (result1 !== null) {
            result2 = parse_Weight();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, s, w) {
              if (w.length === 0) {return [s];}
              return [s,w];
            })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 33) {
            result0 = "!";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"!\"");
            }
          }
          if (result0 !== null) {
            if (input.length > pos) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("any character");
              }
            }
            result1 = result1 !== null ? result1 : "";
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset) {return parser.error("Invalid Strength or Weight",line,column)})(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_Weight() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (/^[0-9]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[0-9]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, w) {return Number(w.join(""))})(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Strength() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 7) === "require") {
          result0 = "require";
          pos += 7;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"require\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 7) === "REQUIRE") {
            result0 = "REQUIRE";
            pos += 7;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"REQUIRE\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 7) === "Require") {
              result0 = "Require";
              pos += 7;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"Require\"");
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "require"})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.substr(pos, 6) === "strong") {
            result0 = "strong";
            pos += 6;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"strong\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 6) === "STRONG") {
              result0 = "STRONG";
              pos += 6;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"STRONG\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 6) === "Strong") {
                result0 = "Strong";
                pos += 6;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"Strong\"");
                }
              }
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) {return "strong"})(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            if (input.substr(pos, 6) === "medium") {
              result0 = "medium";
              pos += 6;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"medium\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 6) === "MEDIUM") {
                result0 = "MEDIUM";
                pos += 6;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"MEDIUM\"");
                }
              }
              if (result0 === null) {
                if (input.substr(pos, 6) === "Medium") {
                  result0 = "Medium";
                  pos += 6;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"Medium\"");
                  }
                }
              }
            }
            if (result0 !== null) {
              result0 = (function(offset) {return "medium"})(pos0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              if (input.substr(pos, 4) === "weak") {
                result0 = "weak";
                pos += 4;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"weak\"");
                }
              }
              if (result0 === null) {
                if (input.substr(pos, 4) === "WEAK") {
                  result0 = "WEAK";
                  pos += 4;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"WEAK\"");
                  }
                }
                if (result0 === null) {
                  if (input.substr(pos, 4) === "Weak") {
                    result0 = "Weak";
                    pos += 4;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"Weak\"");
                    }
                  }
                }
              }
              if (result0 !== null) {
                result0 = (function(offset) {return "weak"})(pos0);
              }
              if (result0 === null) {
                pos = pos0;
              }
              if (result0 === null) {
                pos0 = pos;
                if (input.substr(pos, 8) === "required") {
                  result0 = "required";
                  pos += 8;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"required\"");
                  }
                }
                if (result0 === null) {
                  if (input.substr(pos, 8) === "REQUIRED") {
                    result0 = "REQUIRED";
                    pos += 8;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"REQUIRED\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.substr(pos, 8) === "Required") {
                      result0 = "Required";
                      pos += 8;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"Required\"");
                      }
                    }
                  }
                }
                if (result0 !== null) {
                  result0 = (function(offset) {return "require"})(pos0);
                }
                if (result0 === null) {
                  pos = pos0;
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_EqOperator() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "==") {
          result0 = "==";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"==\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "eq" })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.substr(pos, 2) === "<=") {
            result0 = "<=";
            pos += 2;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"<=\"");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) { return "lte" })(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            if (input.substr(pos, 2) === ">=") {
              result0 = ">=";
              pos += 2;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\">=\"");
              }
            }
            if (result0 !== null) {
              result0 = (function(offset) { return "gte" })(pos0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              if (input.charCodeAt(pos) === 60) {
                result0 = "<";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"<\"");
                }
              }
              if (result0 !== null) {
                result0 = (function(offset) { return "lt"  })(pos0);
              }
              if (result0 === null) {
                pos = pos0;
              }
              if (result0 === null) {
                pos0 = pos;
                if (input.charCodeAt(pos) === 62) {
                  result0 = ">";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\">\"");
                  }
                }
                if (result0 !== null) {
                  result0 = (function(offset) { return "gt"  })(pos0);
                }
                if (result0 === null) {
                  pos = pos0;
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_AdditiveExpression() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_MultiplicativeExpression();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse___();
          if (result2 !== null) {
            result3 = parse_AdditiveOperator();
            if (result3 !== null) {
              result4 = parse___();
              if (result4 !== null) {
                result5 = parse_MultiplicativeExpression();
                if (result5 !== null) {
                  result2 = [result2, result3, result4, result5];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse___();
            if (result2 !== null) {
              result3 = parse_AdditiveOperator();
              if (result3 !== null) {
                result4 = parse___();
                if (result4 !== null) {
                  result5 = parse_MultiplicativeExpression();
                  if (result5 !== null) {
                    result2 = [result2, result3, result4, result5];
                  } else {
                    result2 = null;
                    pos = pos2;
                  }
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, head, tail) {
              var result = head;
              for (var i = 0; i < tail.length; i++) {
                result = [
                  tail[i][1],
                  result,
                  tail[i][3]
                ];
              }
              return result;
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_AdditiveOperator() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 43) {
          result0 = "+";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"+\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "plus" })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.charCodeAt(pos) === 45) {
            result0 = "-";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) { return "minus" })(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_MultiplicativeExpression() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_UnaryExpression();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse___();
          if (result2 !== null) {
            result3 = parse_MultiplicativeOperator();
            if (result3 !== null) {
              result4 = parse___();
              if (result4 !== null) {
                result5 = parse_UnaryExpression();
                if (result5 !== null) {
                  result2 = [result2, result3, result4, result5];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse___();
            if (result2 !== null) {
              result3 = parse_MultiplicativeOperator();
              if (result3 !== null) {
                result4 = parse___();
                if (result4 !== null) {
                  result5 = parse_UnaryExpression();
                  if (result5 !== null) {
                    result2 = [result2, result3, result4, result5];
                  } else {
                    result2 = null;
                    pos = pos2;
                  }
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, head, tail) {
              var result = head;
              for (var i = 0; i < tail.length; i++) {
                result = [
                  tail[i][1],
                  result,
                  tail[i][3]
                ];
              }
              return result;
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_MultiplicativeOperator() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 42) {
          result0 = "*";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"*\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "multiply"})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.charCodeAt(pos) === 47) {
            result0 = "/";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"/\"");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) {return "divide"})(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_UnaryExpression() {
        var result0, result1, result2;
        var pos0, pos1;
        
        result0 = parse_PrimaryExpression();
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_UnaryOperator();
          if (result0 !== null) {
            result1 = parse___();
            if (result1 !== null) {
              result2 = parse_UnaryExpression();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, operator, expression) {
                return {
                  type:       "UnaryExpression",
                  operator:   operator,
                  expression: expression
                };
              })(pos0, result0[0], result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_UnaryOperator() {
        var result0;
        
        if (input.charCodeAt(pos) === 43) {
          result0 = "+";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"+\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 45) {
            result0 = "-";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 33) {
              result0 = "!";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"!\"");
              }
            }
          }
        }
        return result0;
      }
      
      function parse_PrimaryExpression() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        result0 = parse_Measure();
        if (result0 === null) {
          result0 = parse_Var();
          if (result0 === null) {
            result0 = parse_Literal();
            if (result0 === null) {
              pos0 = pos;
              pos1 = pos;
              if (input.charCodeAt(pos) === 40) {
                result0 = "(";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"(\"");
                }
              }
              if (result0 !== null) {
                result1 = parse___();
                if (result1 !== null) {
                  result2 = parse_LinearExpression();
                  if (result2 !== null) {
                    result3 = parse___();
                    if (result3 !== null) {
                      if (input.charCodeAt(pos) === 41) {
                        result4 = ")";
                        pos++;
                      } else {
                        result4 = null;
                        if (reportFailures === 0) {
                          matchFailed("\")\"");
                        }
                      }
                      if (result4 !== null) {
                        result0 = [result0, result1, result2, result3, result4];
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 !== null) {
                result0 = (function(offset, expression) { return expression; })(pos0, result0[2]);
              }
              if (result0 === null) {
                pos = pos0;
              }
            }
          }
        }
        return result0;
      }
      
      function parse_Measure() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 8) === "measure(") {
          result0 = "measure(";
          pos += 8;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"measure(\"");
          }
        }
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result2 = parse_Var();
            if (result2 !== null) {
              result3 = parse___();
              if (result3 !== null) {
                if (input.charCodeAt(pos) === 41) {
                  result4 = ")";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\")\"");
                  }
                }
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, v) { return p.processMeasure(["measure",v]);})(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("measure");
        }
        return result0;
      }
      
      function parse_Var() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        result0 = parse_Selector();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 91) {
            result1 = "[";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"[\"");
            }
          }
          if (result1 !== null) {
            result3 = parse_NameChars();
            if (result3 !== null) {
              result2 = [];
              while (result3 !== null) {
                result2.push(result3);
                result3 = parse_NameChars();
              }
            } else {
              result2 = null;
            }
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 93) {
                result3 = "]";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"]\"");
                }
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, $, v) {       
              var result, id, _id1, _id2;
              v = v.join("");
              id = "["+v+"]";
              if ($.length !== 0) {
                parser.add$($.selector);        
                id = $.selector + id;
                switch (v) {
                  case 'right':
                    _id1 = $.selector + "[" + "x" + "]";
                    _id2 = $.selector + "[" + "width" + "]";
                    parser.addVar(['var', _id1, "x", $.ast], _id1);
                    parser.addVar(['var', _id2, "width", $.ast], _id2);
                    parser.addVar(['varexp',id,['plus',['get',_id1],['get',_id2]], $.ast], id);
                    break;
                  case 'bottom':
                    _id1 = $.selector + "[" + "y" + "]";
                    _id2 = $.selector + "[" + "height" + "]";
                    parser.addVar(['var', _id1, "y", $.ast], _id1);
                    parser.addVar(['var', _id2, "height", $.ast], _id2);
                    parser.addVar(['varexp',id,['plus',['get',_id1],['get',_id2]], $.ast], id);
                    break;
                  case 'center-x':          
                  case 'centerX':
                    _id1 = $.selector + "[" + "x" + "]";
                    _id2 = $.selector + "[" + "width" + "]";
                    parser.addVar(['var', _id1, "x", $.ast], _id1);
                    parser.addVar(['var', _id2, "width", $.ast], _id2);
                    parser.addVar(['varexp',id,['plus',['get',_id1],['divide',['get',_id2],2]], $.ast], id);                       break;
                  case 'center-y':
                  case 'centerY':
                    _id1 = $.selector + "[" + "y" + "]";
                    _id2 = $.selector + "[" + "height" + "]";
                    parser.addVar(['var', _id1, "y", $.ast], _id1);
                    parser.addVar(['var', _id2, "height", $.ast], _id2);
                    parser.addVar(['varexp',id,['plus',['get',_id1],['divide',['get',_id2],2]], $.ast], id);                       break;
                  default:
                    parser.addVar(['var',id,v,$.ast],id);
                }                        
              }
              else {
                parser.addVar(['var',id,v],id);
                // ['_dimensionize',['get','width'],['get','height']]
              }
              return ['get',id];      
            })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("variable");
        }
        return result0;
      }
      
      function parse_VarNames() {
        var result0;
        
        result0 = "";
        return result0;
      }
      
      function parse_Selector() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 35) {
          result0 = "#";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"#\"");
          }
        }
        if (result0 !== null) {
          result2 = parse_NameChars();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_NameChars();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, $) { $=p.toString($); return {selector:"#"+$,ast:["$id",$]} })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 46) {
            result0 = ".";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result0 !== null) {
            result2 = parse_NameChars();
            if (result2 !== null) {
              result1 = [];
              while (result2 !== null) {
                result1.push(result2);
                result2 = parse_NameChars();
              }
            } else {
              result1 = null;
            }
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, $) { $=p.toString($); return {selector:"."+$,ast:["$class",$]} })(pos0, result0[1]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            if (input.charCodeAt(pos) === 36) {
              result0 = "$";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"$\"");
              }
            }
            if (result0 !== null) {
              result2 = parse_NameChars();
              if (result2 !== null) {
                result1 = [];
                while (result2 !== null) {
                  result1.push(result2);
                  result2 = parse_NameChars();
                }
              } else {
                result1 = null;
              }
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, $) { $=p.toString($); return {selector:$,ast:["$all",$]} })(pos0, result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              result1 = parse_NameChars();
              if (result1 !== null) {
                result0 = [];
                while (result1 !== null) {
                  result0.push(result1);
                  result1 = parse_NameChars();
                }
              } else {
                result0 = null;
              }
              if (result0 !== null) {
                result0 = (function(offset, $) { $=p.toString($); return {selector:$,ast:["$tag",$]} })(pos0, result0);
              }
              if (result0 === null) {
                pos = pos0;
              }
              if (result0 === null) {
                pos0 = pos;
                pos1 = pos;
                if (input.substr(pos, 2) === "::") {
                  result0 = "::";
                  pos += 2;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"::\"");
                  }
                }
                if (result0 !== null) {
                  result1 = parse_ReservedPseudos();
                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
                if (result0 !== null) {
                  result0 = (function(offset, $) {return {selector:"::"+$,ast:["$reserved", $]}})(pos0, result0[1]);
                }
                if (result0 === null) {
                  pos = pos0;
                }
              }
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("selector");
        }
        return result0;
      }
      
      function parse_ReservedPseudos() {
        var result0;
        
        if (input.substr(pos, 4) === "this") {
          result0 = "this";
          pos += 4;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"this\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 8) === "viewport") {
            result0 = "viewport";
            pos += 8;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"viewport\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 8) === "document") {
              result0 = "document";
              pos += 8;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"document\"");
              }
            }
          }
        }
        return result0;
      }
      
      function parse_NameChars() {
        var result0;
        
        if (/^[a-zA-Z0-9#.\-_$]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9#.\\-_$]");
          }
        }
        return result0;
      }
      
      function parse_NameCharsWithSpace() {
        var result0;
        
        result0 = parse_NameChars();
        if (result0 === null) {
          if (input.charCodeAt(pos) === 32) {
            result0 = " ";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\" \"");
            }
          }
        }
        return result0;
      }
      
      function parse_Literal() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_Real();
        if (result0 === null) {
          result0 = parse_Integer();
        }
        if (result0 !== null) {
          result0 = (function(offset, val) {
            return [ "number",
              val
            ]
          })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Integer() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (/^[0-9]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[0-9]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, digits) {
            return parseInt(digits.join(""));
          })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Real() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_Integer();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 46) {
            result1 = ".";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_Integer();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, digits) {
            return parseFloat(digits.join(""));
          })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SignedInteger() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (/^[\-+]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\-+]");
          }
        }
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          if (/^[0-9]/.test(input.charAt(pos))) {
            result2 = input.charAt(pos);
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[0-9]");
            }
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              if (/^[0-9]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SourceCharacter() {
        var result0;
        
        if (input.length > pos) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("any character");
          }
        }
        return result0;
      }
      
      function parse_WhiteSpace() {
        var result0;
        
        reportFailures++;
        if (/^[\t\x0B\f \xA0\uFEFF]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\t\\x0B\\f \\xA0\\uFEFF]");
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("whitespace");
        }
        return result0;
      }
      
      function parse_LineTerminator() {
        var result0;
        
        if (/^[\n\r\u2028\u2029]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\n\\r\\u2028\\u2029]");
          }
        }
        return result0;
      }
      
      function parse_LineTerminatorSequence() {
        var result0;
        
        reportFailures++;
        if (input.charCodeAt(pos) === 10) {
          result0 = "\n";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\n\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 2) === "\r\n") {
            result0 = "\r\n";
            pos += 2;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\r\\n\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 13) {
              result0 = "\r";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\r\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 8232) {
                result0 = "\u2028";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\u2028\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 8233) {
                  result0 = "\u2029";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\u2029\"");
                  }
                }
              }
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("end of line");
        }
        return result0;
      }
      
      function parse_EOS() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = parse___();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 59) {
            result1 = ";";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\";\"");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          result0 = parse__();
          if (result0 !== null) {
            result1 = parse_LineTerminatorSequence();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            result0 = parse___();
            if (result0 !== null) {
              result1 = parse_EOF();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          }
        }
        return result0;
      }
      
      function parse_EOF() {
        var result0;
        var pos0;
        
        pos0 = pos;
        reportFailures++;
        if (input.length > pos) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("any character");
          }
        }
        reportFailures--;
        if (result0 === null) {
          result0 = "";
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Comment() {
        var result0;
        
        reportFailures++;
        result0 = parse_MultiLineComment();
        if (result0 === null) {
          result0 = parse_SingleLineComment();
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("comment");
        }
        return result0;
      }
      
      function parse_MultiLineComment() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "/*") {
          result0 = "/*";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/*\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          pos2 = pos;
          reportFailures++;
          if (input.substr(pos, 2) === "*/") {
            result2 = "*/";
            pos += 2;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\"*/\"");
            }
          }
          reportFailures--;
          if (result2 === null) {
            result2 = "";
          } else {
            result2 = null;
            pos = pos2;
          }
          if (result2 !== null) {
            result3 = parse_SourceCharacter();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            reportFailures--;
            if (result2 === null) {
              result2 = "";
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              result3 = parse_SourceCharacter();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_MultiLineCommentNoLineTerminator() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "/*") {
          result0 = "/*";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/*\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          pos2 = pos;
          reportFailures++;
          if (input.substr(pos, 2) === "*/") {
            result2 = "*/";
            pos += 2;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\"*/\"");
            }
          }
          if (result2 === null) {
            result2 = parse_LineTerminator();
          }
          reportFailures--;
          if (result2 === null) {
            result2 = "";
          } else {
            result2 = null;
            pos = pos2;
          }
          if (result2 !== null) {
            result3 = parse_SourceCharacter();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            if (result2 === null) {
              result2 = parse_LineTerminator();
            }
            reportFailures--;
            if (result2 === null) {
              result2 = "";
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              result3 = parse_SourceCharacter();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SingleLineComment() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "//") {
          result0 = "//";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"//\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          pos2 = pos;
          reportFailures++;
          result2 = parse_LineTerminator();
          reportFailures--;
          if (result2 === null) {
            result2 = "";
          } else {
            result2 = null;
            pos = pos2;
          }
          if (result2 !== null) {
            result3 = parse_SourceCharacter();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            result2 = parse_LineTerminator();
            reportFailures--;
            if (result2 === null) {
              result2 = "";
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              result3 = parse_SourceCharacter();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result2 = parse_LineTerminator();
            if (result2 === null) {
              result2 = parse_EOF();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse__() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_WhiteSpace();
        if (result1 === null) {
          result1 = parse_MultiLineCommentNoLineTerminator();
          if (result1 === null) {
            result1 = parse_SingleLineComment();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_WhiteSpace();
          if (result1 === null) {
            result1 = parse_MultiLineCommentNoLineTerminator();
            if (result1 === null) {
              result1 = parse_SingleLineComment();
            }
          }
        }
        return result0;
      }
      
      function parse___() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_WhiteSpace();
        if (result1 === null) {
          result1 = parse_LineTerminatorSequence();
          if (result1 === null) {
            result1 = parse_Comment();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_WhiteSpace();
          if (result1 === null) {
            result1 = parse_LineTerminatorSequence();
            if (result1 === null) {
              result1 = parse_Comment();
            }
          }
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
        var p, parser, flatten, _varsCache, _measuresCache; 
      
        p = parser = this;
      
        p.commands = [];  
      
        p.cs = [];
        p.addC = function (c) {
          p.commands.push(c);
        };
        
        p.$s = [];
        p.add$ = function ($) {
          if (p.$s.indexOf($) === -1) {p.$s.push($);}
          return $;
        }
      
        _varsCache = [];
        p.vars = [];
        p.addVar = function (ast,id) {
          if (_varsCache.indexOf(id) === -1) {
            _varsCache.push(id);
            p.commands.push(ast);
          }
          return ast;
        }
        
        _measuresCache = [];
        p.measures = [];
        p.processMeasure = function (ast) {
          var _id;
          _id = ast.toString(); // assuming stringified ast arrays CAN be used for cache lookup
          if (_measuresCache.indexOf(_id) === -1) {
            _measuresCache.push(_id);
            p.measures.push(ast);
          }
          return ast;
        }
      
        p.getResults = function () {
          return {
            "selectors": p.$s,
            "commands": p.commands
            //"measures": p.measures,
            //"vars": p.vars,
            //"constraints": p.cs      
          }
        }
        
        p.toString = function (x) {
          if (typeof x === "string") {return x}
          if (x instanceof Array) {return x.join("")}
          return ""
        }
      
        p.error = function (m,l,c) {
          if (!!l && !!c) {m = m+ " {line:" + l + ", col:" + c + "}"} 
          console.error(m);
          return m;
        }
      
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();
});
require.register("the-gss-vfl-compiler/lib/vfl-compiler.js", function(exports, require, module){
module.exports = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "start": parse_start,
        "debug": parse_debug,
        "Statement": parse_Statement,
        "VFLStatement": parse_VFLStatement,
        "Dimension": parse_Dimension,
        "Options": parse_Options,
        "Option": parse_Option,
        "Chain": parse_Chain,
        "ChainPredicate": parse_ChainPredicate,
        "ChainPredicateItems": parse_ChainPredicateItems,
        "ChainPredicateItem": parse_ChainPredicateItem,
        "ChainPredVal": parse_ChainPredVal,
        "View": parse_View,
        "Predicate": parse_Predicate,
        "PredExpression": parse_PredExpression,
        "PredEq": parse_PredEq,
        "PredOp": parse_PredOp,
        "PredView": parse_PredView,
        "PredLiteral": parse_PredLiteral,
        "PredVariable": parse_PredVariable,
        "PredViewVariable": parse_PredViewVariable,
        "PredSeperator": parse_PredSeperator,
        "Connection": parse_Connection,
        "GapChars": parse_GapChars,
        "StrengthAndWeight": parse_StrengthAndWeight,
        "Strength": parse_Strength,
        "NameChars": parse_NameChars,
        "NameCharsWithSpace": parse_NameCharsWithSpace,
        "Literal": parse_Literal,
        "Number": parse_Number,
        "Integer": parse_Integer,
        "Real": parse_Real,
        "SignedInteger": parse_SignedInteger,
        "SourceCharacter": parse_SourceCharacter,
        "WhiteSpace": parse_WhiteSpace,
        "LineTerminator": parse_LineTerminator,
        "LineTerminatorSequence": parse_LineTerminatorSequence,
        "EOS": parse_EOS,
        "EOF": parse_EOF,
        "Comment": parse_Comment,
        "MultiLineComment": parse_MultiLineComment,
        "MultiLineCommentNoLineTerminator": parse_MultiLineCommentNoLineTerminator,
        "SingleLineComment": parse_SingleLineComment,
        "_": parse__,
        "__": parse___
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "start";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_start() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse___();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_Statement();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_Statement();
          }
          if (result1 !== null) {
            result2 = parse___();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) { return parser.getResults(); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_debug() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse___();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_Statement();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_Statement();
          }
          if (result1 !== null) {
            result2 = parse___();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, vfl) { return parser.getResults().concat(vfl); })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Statement() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_VFLStatement();
        if (result0 !== null) {
          result1 = parse_EOS();
          if (result1 !== null) {
            result2 = parse___();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, exp) { return exp; })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_VFLStatement() {
        var result0, result1, result2, result3, result4, result5, result6, result7;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_Dimension();
        if (result0 !== null) {
          result1 = parse___();
          if (result1 !== null) {
            result2 = parse_View();
            if (result2 !== null) {
              result3 = [];
              pos2 = pos;
              result4 = parse___();
              if (result4 !== null) {
                result5 = parse_Connection();
                result5 = result5 !== null ? result5 : "";
                if (result5 !== null) {
                  result6 = parse___();
                  if (result6 !== null) {
                    result7 = parse_View();
                    if (result7 !== null) {
                      result4 = [result4, result5, result6, result7];
                    } else {
                      result4 = null;
                      pos = pos2;
                    }
                  } else {
                    result4 = null;
                    pos = pos2;
                  }
                } else {
                  result4 = null;
                  pos = pos2;
                }
              } else {
                result4 = null;
                pos = pos2;
              }
              while (result4 !== null) {
                result3.push(result4);
                pos2 = pos;
                result4 = parse___();
                if (result4 !== null) {
                  result5 = parse_Connection();
                  result5 = result5 !== null ? result5 : "";
                  if (result5 !== null) {
                    result6 = parse___();
                    if (result6 !== null) {
                      result7 = parse_View();
                      if (result7 !== null) {
                        result4 = [result4, result5, result6, result7];
                      } else {
                        result4 = null;
                        pos = pos2;
                      }
                    } else {
                      result4 = null;
                      pos = pos2;
                    }
                  } else {
                    result4 = null;
                    pos = pos2;
                  }
                } else {
                  result4 = null;
                  pos = pos2;
                }
              }
              if (result3 !== null) {
                result4 = parse___();
                if (result4 !== null) {
                  result5 = parse_Options();
                  result5 = result5 !== null ? result5 : "";
                  if (result5 !== null) {
                    result6 = parse___();
                    if (result6 !== null) {
                      result7 = parse_StrengthAndWeight();
                      result7 = result7 !== null ? result7 : "";
                      if (result7 !== null) {
                        result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, d, head, tail, o, s) {
              var connection, view2, result, ccss, headView, chainedViews;      
              result = head;      
              headView = head.view;
              chainedViews = [];      
              if (headView !== "|") {chainedViews.push(headView);}
              parser.addPreds(headView,head.preds,d);      
              for (var i = 0; i < tail.length; i++) {        
                connection = tail[i][1];
                view2 = tail[i][3].view;
                if (view2 !== "|") {chainedViews.push(view2);}
                parser.addPreds(view2,tail[i][3].preds,d);
                result = [
                  //"c",
                  connection,
                  result,
                  view2
                ];
                ccss = parser.getLeftVar(headView, d, o) + " " + parser.getConnectionString(connection, d) + " " + parser.getRightVar(view2, d, o) + " " + s;
                parser.addC(
                  ccss.trim()
                );
                headView = view2;
              }
              parser.addChains(chainedViews,o);
              return {'vfl':d, o:o};
            })(pos0, result0[0], result0[2], result0[3], result0[5], result0[7]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Dimension() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 11) === "@horizontal") {
          result0 = "@horizontal";
          pos += 11;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"@horizontal\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 16) === "@-gss-horizontal") {
            result0 = "@-gss-horizontal";
            pos += 16;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"@-gss-horizontal\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 7) === "@-gss-h") {
              result0 = "@-gss-h";
              pos += 7;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"@-gss-h\"");
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {return 0;})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.substr(pos, 9) === "@vertical") {
            result0 = "@vertical";
            pos += 9;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"@vertical\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 14) === "@-gss-vertical") {
              result0 = "@-gss-vertical";
              pos += 14;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"@-gss-vertical\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 7) === "@-gss-v") {
                result0 = "@-gss-v";
                pos += 7;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"@-gss-v\"");
                }
              }
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) {return 1;})(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_Options() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_Option();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_Option();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, os) {
            var obj = {};
            obj.chains = [];
            for (var i = 0; i < os.length; i++) {    
              obj[os[i].key] = os[i].value;
              // proccess chains
              if (!!os[i].chain) {obj.chains.push(os[i].chain);}
            }
            return obj;
          })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Option() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse___();
        if (result0 !== null) {
          result1 = parse_Chain();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, chain) { return chain; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse___();
          if (result0 !== null) {
            result2 = parse_NameChars();
            if (result2 !== null) {
              result1 = [];
              while (result2 !== null) {
                result1.push(result2);
                result2 = parse_NameChars();
              }
            } else {
              result1 = null;
            }
            if (result1 !== null) {
              if (input.charCodeAt(pos) === 40) {
                result2 = "(";
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"(\"");
                }
              }
              if (result2 !== null) {
                result4 = parse_NameChars();
                if (result4 !== null) {
                  result3 = [];
                  while (result4 !== null) {
                    result3.push(result4);
                    result4 = parse_NameChars();
                  }
                } else {
                  result3 = null;
                }
                if (result3 !== null) {
                  if (input.charCodeAt(pos) === 41) {
                    result4 = ")";
                    pos++;
                  } else {
                    result4 = null;
                    if (reportFailures === 0) {
                      matchFailed("\")\"");
                    }
                  }
                  if (result4 !== null) {
                    result0 = [result0, result1, result2, result3, result4];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, key, value) {return {key:key.join(''), value:value.join('')};})(pos0, result0[1], result0[3]);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_Chain() {
        var result0, result1, result2;
        var pos0, pos1;
        
        reportFailures++;
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 6) === "chain-") {
          result0 = "chain-";
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"chain-\"");
          }
        }
        if (result0 !== null) {
          result2 = parse_NameChars();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_NameChars();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_ChainPredicate();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, prop, preds) { return {'chain':[prop.join(""),preds]};})(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("Chain");
        }
        return result0;
      }
      
      function parse_ChainPredicate() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 40) {
          result0 = "(";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"(\"");
          }
        }
        if (result0 !== null) {
          result2 = parse_ChainPredicateItems();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_ChainPredicateItems();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 41) {
              result2 = ")";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\")\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, items) {return items;})(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ChainPredicateItems() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_ChainPredicateItem();
        if (result0 !== null) {
          result1 = parse__();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 44) {
              result2 = ",";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\",\"");
              }
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, item) {return item;})(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ChainPredicateItem() {
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_PredEq();
        if (result0 !== null) {
          result1 = parse__();
          if (result1 !== null) {
            result2 = parse_ChainPredVal();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse__();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result4 = parse_PredEq();
                result4 = result4 !== null ? result4 : "";
                if (result4 !== null) {
                  result5 = parse__();
                  result5 = result5 !== null ? result5 : "";
                  if (result5 !== null) {
                    result6 = parse_StrengthAndWeight();
                    result6 = result6 !== null ? result6 : "";
                    if (result6 !== null) {
                      result0 = [result0, result1, result2, result3, result4, result5, result6];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, headEq, value, tailEq, s) {
              return {headEq:p.join(headEq),value:p.join(value),tailEq:p.join(tailEq),s:s};})(pos0, result0[0], result0[2], result0[4], result0[6]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          result0 = parse_PredEq();
          result0 = result0 !== null ? result0 : "";
          if (result0 !== null) {
            result1 = parse__();
            result1 = result1 !== null ? result1 : "";
            if (result1 !== null) {
              result2 = parse_ChainPredVal();
              if (result2 !== null) {
                result3 = parse__();
                result3 = result3 !== null ? result3 : "";
                if (result3 !== null) {
                  result4 = parse_PredEq();
                  result4 = result4 !== null ? result4 : "";
                  if (result4 !== null) {
                    result5 = parse__();
                    result5 = result5 !== null ? result5 : "";
                    if (result5 !== null) {
                      result6 = parse_StrengthAndWeight();
                      result6 = result6 !== null ? result6 : "";
                      if (result6 !== null) {
                        result0 = [result0, result1, result2, result3, result4, result5, result6];
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, headEq, value, tailEq, s) {
                return {headEq:p.join(headEq),value:p.join(value),tailEq:p.join(tailEq),s:s};})(pos0, result0[0], result0[2], result0[4], result0[6]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            result0 = parse_PredEq();
            result0 = result0 !== null ? result0 : "";
            if (result0 !== null) {
              result1 = parse__();
              result1 = result1 !== null ? result1 : "";
              if (result1 !== null) {
                result2 = parse_ChainPredVal();
                result2 = result2 !== null ? result2 : "";
                if (result2 !== null) {
                  result3 = parse__();
                  result3 = result3 !== null ? result3 : "";
                  if (result3 !== null) {
                    result4 = parse_PredEq();
                    result4 = result4 !== null ? result4 : "";
                    if (result4 !== null) {
                      result5 = parse__();
                      result5 = result5 !== null ? result5 : "";
                      if (result5 !== null) {
                        result6 = parse_StrengthAndWeight();
                        if (result6 !== null) {
                          result0 = [result0, result1, result2, result3, result4, result5, result6];
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, headEq, value, tailEq, s) {
                  return {headEq:p.join(headEq),value:p.join(value),tailEq:p.join(tailEq),s:s};})(pos0, result0[0], result0[2], result0[4], result0[6]);
            }
            if (result0 === null) {
              pos = pos0;
            }
          }
        }
        return result0;
      }
      
      function parse_ChainPredVal() {
        var result0, result1;
        
        if (/^[^>=<!) ]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[^>=<!) ]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[^>=<!) ]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[^>=<!) ]");
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_View() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 !== null) {
          result2 = parse_NameChars();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_NameChars();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result2 = parse_Predicate();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 93) {
                result3 = "]";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"]\"");
                }
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, name, p) {return {view:name.join(""),preds:p};})(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.charCodeAt(pos) === 124) {
            result0 = "|";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"|\"");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) {return {view:"|"};})(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_Predicate() {
        var result0, result1, result2, result3, result4, result5, result6, result7;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 40) {
          result0 = "(";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"(\"");
          }
        }
        if (result0 !== null) {
          pos2 = pos;
          result2 = parse_PredEq();
          if (result2 !== null) {
            result3 = parse_PredExpression();
            if (result3 !== null) {
              result4 = parse_StrengthAndWeight();
              result4 = result4 !== null ? result4 : "";
              if (result4 !== null) {
                result5 = parse__();
                result5 = result5 !== null ? result5 : "";
                if (result5 !== null) {
                  result6 = parse_PredSeperator();
                  if (result6 !== null) {
                    result7 = parse__();
                    result7 = result7 !== null ? result7 : "";
                    if (result7 !== null) {
                      result2 = [result2, result3, result4, result5, result6, result7];
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  } else {
                    result2 = null;
                    pos = pos2;
                  }
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              pos2 = pos;
              result2 = parse_PredEq();
              if (result2 !== null) {
                result3 = parse_PredExpression();
                if (result3 !== null) {
                  result4 = parse_StrengthAndWeight();
                  result4 = result4 !== null ? result4 : "";
                  if (result4 !== null) {
                    result5 = parse__();
                    result5 = result5 !== null ? result5 : "";
                    if (result5 !== null) {
                      result6 = parse_PredSeperator();
                      if (result6 !== null) {
                        result7 = parse__();
                        result7 = result7 !== null ? result7 : "";
                        if (result7 !== null) {
                          result2 = [result2, result3, result4, result5, result6, result7];
                        } else {
                          result2 = null;
                          pos = pos2;
                        }
                      } else {
                        result2 = null;
                        pos = pos2;
                      }
                    } else {
                      result2 = null;
                      pos = pos2;
                    }
                  } else {
                    result2 = null;
                    pos = pos2;
                  }
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 41) {
              result2 = ")";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\")\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, preds) {return preds;})(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_PredExpression() {
        var result0, result1;
        
        result1 = parse_PredOp();
        if (result1 === null) {
          result1 = parse_PredLiteral();
          if (result1 === null) {
            result1 = parse_PredVariable();
            if (result1 === null) {
              result1 = parse_PredViewVariable();
              if (result1 === null) {
                result1 = parse_PredView();
              }
            }
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_PredOp();
            if (result1 === null) {
              result1 = parse_PredLiteral();
              if (result1 === null) {
                result1 = parse_PredVariable();
                if (result1 === null) {
                  result1 = parse_PredViewVariable();
                  if (result1 === null) {
                    result1 = parse_PredView();
                  }
                }
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_PredEq() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse__();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          if (input.substr(pos, 2) === "==") {
            result1 = "==";
            pos += 2;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"==\"");
            }
          }
          if (result1 === null) {
            if (input.substr(pos, 2) === "<=") {
              result1 = "<=";
              pos += 2;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"<=\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 60) {
                result1 = "<";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"<\"");
                }
              }
              if (result1 === null) {
                if (input.substr(pos, 2) === ">=") {
                  result1 = ">=";
                  pos += 2;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\">=\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 62) {
                    result1 = ">";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\">\"");
                    }
                  }
                  if (result1 === null) {
                    pos2 = pos;
                    if (input.substr(pos, 2) === "=<") {
                      result1 = "=<";
                      pos += 2;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"=<\"");
                      }
                    }
                    if (result1 !== null) {
                      result1 = (function(offset) {return "<=";})(pos2);
                    }
                    if (result1 === null) {
                      pos = pos2;
                    }
                    if (result1 === null) {
                      pos2 = pos;
                      if (input.substr(pos, 2) === "=>") {
                        result1 = "=>";
                        pos += 2;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"=>\"");
                        }
                      }
                      if (result1 !== null) {
                        result1 = (function(offset) {return ">=";})(pos2);
                      }
                      if (result1 === null) {
                        pos = pos2;
                      }
                    }
                  }
                }
              }
            }
          }
          if (result1 !== null) {
            result2 = parse__();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, eq) {return eq;})(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_PredOp() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (/^[+\-\/*]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[+\\-\\/*]");
          }
        }
        if (result0 !== null) {
          result1 = parse__();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, op) {return op;})(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_PredView() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result1 = parse_NameChars();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_NameChars();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = parse__();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, name) {return ["view",name.join("")];})(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_PredLiteral() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result1 = parse_Number();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_Number();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = parse__();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, n) {return n.join("");})(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_PredVariable() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 !== null) {
          result2 = parse_NameChars();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_NameChars();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 93) {
              result2 = "]";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"]\"");
              }
            }
            if (result2 !== null) {
              result3 = parse__();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, name) {return "[" + name.join("") + "]";})(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_PredViewVariable() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result1 = parse_NameChars();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_NameChars();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 91) {
            result1 = "[";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"[\"");
            }
          }
          if (result1 !== null) {
            result3 = parse_NameChars();
            if (result3 !== null) {
              result2 = [];
              while (result3 !== null) {
                result2.push(result3);
                result3 = parse_NameChars();
              }
            } else {
              result2 = null;
            }
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 93) {
                result3 = "]";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"]\"");
                }
              }
              if (result3 !== null) {
                result4 = parse__();
                result4 = result4 !== null ? result4 : "";
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, view, prop) {return view.join("") + "[" + prop.join("") + "]";})(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_PredSeperator() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 44) {
          result0 = ",";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\",\"");
          }
        }
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result0 = (function(offset) {return "";})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Connection() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 45) {
          result0 = "-";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"-\"");
          }
        }
        if (result0 !== null) {
          result2 = parse_GapChars();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_GapChars();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 45) {
              result2 = "-";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"-\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, gap) {return {op:"==",gap:gap.join("")};})(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.charCodeAt(pos) === 45) {
            result0 = "-";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) {return {op:"==",gap:"__STANDARD__"};})(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            if (input.charCodeAt(pos) === 126) {
              result0 = "~";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"~\"");
              }
            }
            if (result0 !== null) {
              result2 = parse_GapChars();
              if (result2 !== null) {
                result1 = [];
                while (result2 !== null) {
                  result1.push(result2);
                  result2 = parse_GapChars();
                }
              } else {
                result1 = null;
              }
              if (result1 !== null) {
                if (input.charCodeAt(pos) === 126) {
                  result2 = "~";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"~\"");
                  }
                }
                if (result2 !== null) {
                  result0 = [result0, result1, result2];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, gap) {return {op:"<=",gap:gap.join("")};})(pos0, result0[1]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              pos1 = pos;
              if (input.charCodeAt(pos) === 126) {
                result0 = "~";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"~\"");
                }
              }
              if (result0 !== null) {
                if (input.charCodeAt(pos) === 45) {
                  result1 = "-";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"-\"");
                  }
                }
                if (result1 !== null) {
                  if (input.charCodeAt(pos) === 126) {
                    result2 = "~";
                    pos++;
                  } else {
                    result2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"~\"");
                    }
                  }
                  if (result2 !== null) {
                    result0 = [result0, result1, result2];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 !== null) {
                result0 = (function(offset) {return {op:"<=",gap:"__STANDARD__"};})(pos0);
              }
              if (result0 === null) {
                pos = pos0;
              }
              if (result0 === null) {
                pos0 = pos;
                if (input.charCodeAt(pos) === 126) {
                  result0 = "~";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"~\"");
                  }
                }
                if (result0 !== null) {
                  result0 = (function(offset) {return {op:"<="};})(pos0);
                }
                if (result0 === null) {
                  pos = pos0;
                }
                if (result0 === null) {
                  pos0 = pos;
                  result0 = "";
                  if (result0 !== null) {
                    result0 = (function(offset) {return {op:"=="};})(pos0);
                  }
                  if (result0 === null) {
                    pos = pos0;
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_GapChars() {
        var result0;
        
        if (/^[a-zA-Z0-9#._$]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9#._$]");
          }
        }
        return result0;
      }
      
      function parse_StrengthAndWeight() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 33) {
          result0 = "!";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"!\"");
          }
        }
        if (result0 !== null) {
          if (/^[a-zA-Z]/.test(input.charAt(pos))) {
            result2 = input.charAt(pos);
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[a-zA-Z]");
            }
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              if (/^[a-zA-Z]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[a-zA-Z]");
                }
              }
            }
          } else {
            result1 = null;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            if (/^[0-9]/.test(input.charAt(pos))) {
              result3 = input.charAt(pos);
              pos++;
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
            if (result3 !== null) {
              result2 = [];
              while (result3 !== null) {
                result2.push(result3);
                if (/^[0-9]/.test(input.charAt(pos))) {
                  result3 = input.charAt(pos);
                  pos++;
                } else {
                  result3 = null;
                  if (reportFailures === 0) {
                    matchFailed("[0-9]");
                  }
                }
              }
            } else {
              result2 = null;
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, s, w) {  return "!" + p.join(s) + p.join(w);})(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.charCodeAt(pos) === 33) {
            result0 = "!";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"!\"");
            }
          }
          if (result0 !== null) {
            if (input.length > pos) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("any character");
              }
            }
            result1 = result1 !== null ? result1 : "";
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset) {return parser.error("Invalid Strength or Weight",line,column);})(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_Strength() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 7) === "require") {
          result0 = "require";
          pos += 7;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"require\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 7) === "REQUIRE") {
            result0 = "REQUIRE";
            pos += 7;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"REQUIRE\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 7) === "Require") {
              result0 = "Require";
              pos += 7;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"Require\"");
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "require";})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.substr(pos, 6) === "strong") {
            result0 = "strong";
            pos += 6;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"strong\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 6) === "STRONG") {
              result0 = "STRONG";
              pos += 6;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"STRONG\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 6) === "Strong") {
                result0 = "Strong";
                pos += 6;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"Strong\"");
                }
              }
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) {return "strong";})(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            if (input.substr(pos, 6) === "medium") {
              result0 = "medium";
              pos += 6;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"medium\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 6) === "MEDIUM") {
                result0 = "MEDIUM";
                pos += 6;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"MEDIUM\"");
                }
              }
              if (result0 === null) {
                if (input.substr(pos, 6) === "Medium") {
                  result0 = "Medium";
                  pos += 6;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"Medium\"");
                  }
                }
              }
            }
            if (result0 !== null) {
              result0 = (function(offset) {return "medium";})(pos0);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              if (input.substr(pos, 4) === "weak") {
                result0 = "weak";
                pos += 4;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"weak\"");
                }
              }
              if (result0 === null) {
                if (input.substr(pos, 4) === "WEAK") {
                  result0 = "WEAK";
                  pos += 4;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"WEAK\"");
                  }
                }
                if (result0 === null) {
                  if (input.substr(pos, 4) === "Weak") {
                    result0 = "Weak";
                    pos += 4;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"Weak\"");
                    }
                  }
                }
              }
              if (result0 !== null) {
                result0 = (function(offset) {return "weak";})(pos0);
              }
              if (result0 === null) {
                pos = pos0;
              }
              if (result0 === null) {
                pos0 = pos;
                if (input.substr(pos, 8) === "required") {
                  result0 = "required";
                  pos += 8;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"required\"");
                  }
                }
                if (result0 === null) {
                  if (input.substr(pos, 8) === "REQUIRED") {
                    result0 = "REQUIRED";
                    pos += 8;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"REQUIRED\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.substr(pos, 8) === "Required") {
                      result0 = "Required";
                      pos += 8;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"Required\"");
                      }
                    }
                  }
                }
                if (result0 !== null) {
                  result0 = (function(offset) {return "require";})(pos0);
                }
                if (result0 === null) {
                  pos = pos0;
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_NameChars() {
        var result0;
        
        if (/^[a-zA-Z0-9#.\-_$]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9#.\\-_$]");
          }
        }
        return result0;
      }
      
      function parse_NameCharsWithSpace() {
        var result0;
        
        result0 = parse_NameChars();
        if (result0 === null) {
          if (input.charCodeAt(pos) === 32) {
            result0 = " ";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\" \"");
            }
          }
        }
        return result0;
      }
      
      function parse_Literal() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_Number();
        if (result0 !== null) {
          result0 = (function(offset, val) {
            return [ "number",
              val
            ];
          })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Number() {
        var result0;
        
        result0 = parse_Real();
        if (result0 === null) {
          result0 = parse_Integer();
        }
        return result0;
      }
      
      function parse_Integer() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (/^[0-9]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[0-9]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, digits) {
            return parseInt(digits.join(""), 10);
          })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Real() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_Integer();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 46) {
            result1 = ".";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_Integer();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, digits) {
            return parseFloat(digits.join(""));
          })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SignedInteger() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (/^[\-+]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\-+]");
          }
        }
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          if (/^[0-9]/.test(input.charAt(pos))) {
            result2 = input.charAt(pos);
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[0-9]");
            }
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              if (/^[0-9]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SourceCharacter() {
        var result0;
        
        if (input.length > pos) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("any character");
          }
        }
        return result0;
      }
      
      function parse_WhiteSpace() {
        var result0;
        
        reportFailures++;
        if (/^[\t\x0B\f \xA0\uFEFF]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\t\\x0B\\f \\xA0\\uFEFF]");
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("whitespace");
        }
        return result0;
      }
      
      function parse_LineTerminator() {
        var result0;
        
        if (/^[\n\r\u2028\u2029]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\n\\r\\u2028\\u2029]");
          }
        }
        return result0;
      }
      
      function parse_LineTerminatorSequence() {
        var result0;
        
        reportFailures++;
        if (input.charCodeAt(pos) === 10) {
          result0 = "\n";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\n\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 2) === "\r\n") {
            result0 = "\r\n";
            pos += 2;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\r\\n\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 13) {
              result0 = "\r";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\r\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 8232) {
                result0 = "\u2028";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\u2028\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 8233) {
                  result0 = "\u2029";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\u2029\"");
                  }
                }
              }
            }
          }
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("end of line");
        }
        return result0;
      }
      
      function parse_EOS() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = parse___();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 59) {
            result1 = ";";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\";\"");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          result0 = parse__();
          if (result0 !== null) {
            result1 = parse_LineTerminatorSequence();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            result0 = parse___();
            if (result0 !== null) {
              result1 = parse_EOF();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          }
        }
        return result0;
      }
      
      function parse_EOF() {
        var result0;
        var pos0;
        
        pos0 = pos;
        reportFailures++;
        if (input.length > pos) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("any character");
          }
        }
        reportFailures--;
        if (result0 === null) {
          result0 = "";
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Comment() {
        var result0;
        
        reportFailures++;
        result0 = parse_MultiLineComment();
        if (result0 === null) {
          result0 = parse_SingleLineComment();
        }
        reportFailures--;
        if (reportFailures === 0 && result0 === null) {
          matchFailed("comment");
        }
        return result0;
      }
      
      function parse_MultiLineComment() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "/*") {
          result0 = "/*";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/*\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          pos2 = pos;
          reportFailures++;
          if (input.substr(pos, 2) === "*/") {
            result2 = "*/";
            pos += 2;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\"*/\"");
            }
          }
          reportFailures--;
          if (result2 === null) {
            result2 = "";
          } else {
            result2 = null;
            pos = pos2;
          }
          if (result2 !== null) {
            result3 = parse_SourceCharacter();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            reportFailures--;
            if (result2 === null) {
              result2 = "";
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              result3 = parse_SourceCharacter();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_MultiLineCommentNoLineTerminator() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "/*") {
          result0 = "/*";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/*\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          pos2 = pos;
          reportFailures++;
          if (input.substr(pos, 2) === "*/") {
            result2 = "*/";
            pos += 2;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\"*/\"");
            }
          }
          if (result2 === null) {
            result2 = parse_LineTerminator();
          }
          reportFailures--;
          if (result2 === null) {
            result2 = "";
          } else {
            result2 = null;
            pos = pos2;
          }
          if (result2 !== null) {
            result3 = parse_SourceCharacter();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            if (result2 === null) {
              result2 = parse_LineTerminator();
            }
            reportFailures--;
            if (result2 === null) {
              result2 = "";
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              result3 = parse_SourceCharacter();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            if (input.substr(pos, 2) === "*/") {
              result2 = "*/";
              pos += 2;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"*/\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SingleLineComment() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "//") {
          result0 = "//";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"//\"");
          }
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          pos2 = pos;
          reportFailures++;
          result2 = parse_LineTerminator();
          reportFailures--;
          if (result2 === null) {
            result2 = "";
          } else {
            result2 = null;
            pos = pos2;
          }
          if (result2 !== null) {
            result3 = parse_SourceCharacter();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            pos2 = pos;
            reportFailures++;
            result2 = parse_LineTerminator();
            reportFailures--;
            if (result2 === null) {
              result2 = "";
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              result3 = parse_SourceCharacter();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result2 = parse_LineTerminator();
            if (result2 === null) {
              result2 = parse_EOF();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse__() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_WhiteSpace();
        if (result1 === null) {
          result1 = parse_MultiLineCommentNoLineTerminator();
          if (result1 === null) {
            result1 = parse_SingleLineComment();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_WhiteSpace();
          if (result1 === null) {
            result1 = parse_MultiLineCommentNoLineTerminator();
            if (result1 === null) {
              result1 = parse_SingleLineComment();
            }
          }
        }
        return result0;
      }
      
      function parse___() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_WhiteSpace();
        if (result1 === null) {
          result1 = parse_LineTerminatorSequence();
          if (result1 === null) {
            result1 = parse_Comment();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_WhiteSpace();
          if (result1 === null) {
            result1 = parse_LineTerminatorSequence();
            if (result1 === null) {
              result1 = parse_Comment();
            }
          }
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
        var p, parser, cs, leftVarNames, superLeftVarNames, rightVarNames, superRightVarNames, standardGapNames, getSuperViewName, getGapString, sizeVarNames; 
      
        p = parser = this;
      
        sizeVarNames = ["width", "height"];
        leftVarNames = ["right", "bottom"];
        superLeftVarNames = ["left", "top"];
        rightVarNames = ["left", "top"];
        superRightVarNames = ["right", "bottom"];
      
        cs = parser.cs = [];
      
        parser.addC = function (c) {
          cs.push(c);
        };
      
        parser.addPreds = function (view,preds,d) {
          var pred, ccss, eq, exps, exp;
          if (preds) {      
            for (var i = 0; i < preds.length; i++) {
              pred = preds[i];
              eq = pred[0];
              ccss = view + "[" + sizeVarNames[d] + "] " + eq + " ";
              exps = pred[1];
              for (var j = 0; j < exps.length; j++) {       
                exp = exps[j];
                if (exp[0] === "view") {
                  exp = exp[1] + "[" + sizeVarNames[d] + "]";
                }
                ccss += exp + " ";
              }
              ccss += pred[2]; // strength & weight
              cs.push(ccss.trim());
            }
          }
        };
      
        parser.defaultChainObject = {
          headEq: "==",
          value: "",
          tailEq: "",
          s: ""
        };
      
        parser.chainTailEqMap = {
          "<=": ">=",
          ">=": "<=",
          "==": "==",
          "<" : ">",
          ">" : "<" 
        };
      
        parser.addChains = function (views,o) {
          var chains, chain, prop, preds, connector, ccss, view, pred;
          chains = o.chains;
          if (chains) {            
            for (var i = 0; i < chains.length; i++) {
              chain = chains[i];
              prop = chain[0];
              preds = chain[1];
              if (preds === "") {
                preds = [parser.defaultChainObject];
              } // load default chain predicate
              for (var j = 0; j < preds.length; j++) {
                pred = preds[j];
                ccss = "";
                for (var k = 0; k < views.length - 1; k++) {
                  view = views[k];  
                  if (pred.headEq === "") {
                    pred.headEq = parser.defaultChainObject.headEq;
                  }
                  ccss += " " + view + "[" + prop + "] " + pred.headEq;
                  if (pred.value !== "") {
                    ccss += " " + pred.value;
                    if (views.length > 1) {
                      if (pred.tailEq === "") {
                        pred.tailEq = parser.chainTailEqMap[pred.headEq];
                      }
                      ccss += " " + pred.tailEq;
                    }
                    else {
                      ccss += " " + pred.s;
                      cs.push(ccss.trim());
                    }
                  }
                }
                if (views.length > 1) {
                   ccss += " " + views[views.length-1] + "[" + prop + "]" + " " + pred.s;
                   cs.push(ccss.trim());
                }
              }
            }
          } 
        };
      
        getSuperViewName = function (o) {
          if (o.in === undefined) {
            return "::this";
          }
          return o.in;
        };
      
        parser.getLeftVar = function (view, dimension, o) {
          var varName;
          if (view === "|") {
            view = getSuperViewName(o);
            varName = superLeftVarNames[dimension];
          }
          else {
            varName = leftVarNames[dimension];
          }
          return view + "[" + varName + "]";
        };
        
        parser.getRightVar = function (view, dimension, o) {
          var varName;
          
          if (view === "|") {
            view = getSuperViewName(o);
            varName = superRightVarNames[dimension];
          }
          else {
            varName = rightVarNames[dimension];
            
          }
          return view + "[" + varName + "]";
        };
        
        standardGapNames = ["[hgap]", "[vgap]"];
        
        getGapString = function (g,d) {
          if (g === undefined) {return "";}
          if (g === "__STANDARD__") {g = standardGapNames[d];}
          return "+ " + g;
        };
      
        parser.getConnectionString = function (c,d) {
          return (getGapString(c.gap,d) + " " + c.op).trim();
        };
      
        parser.getResults = function () {
          return [
            ["ccss"].concat(this.cs)
          ];
        };
      
        parser.error = function (m,l,c) {
          if (!!l && !!c) {
            m = m + " {line:" + l + ", col:" + c + "}";
          }
          console.error(m);
          return m;
        };
      
        parser.join = function (a) {
          if (a.join){return a.join("");}
          return a;
        };
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();
});
require.register("the-gss-vfl-compiler/lib/compiler.js", function(exports, require, module){
var ccss = require('ccss-compiler');
var vfl = require('./vfl-compiler');

exports.parse = function (rules) {
  var results = {
    selectors: [],
    commands: []
  };
  var parsed = vfl.parse(rules);
  parsed.forEach(function (rule) {
    if (rule.shift() !== 'ccss') {
      throw new Error('CCSS rules expected');
    }
    var ccssRule = ccss.parse(rule.join(";\n"));
    results.selectors = results.selectors.concat(ccssRule.selectors);
    results.commands = results.commands.concat(ccssRule.commands);
    //results.constraints = results.constraints.concat(ccssRule.constraints);
  });
  return results;
};

});
require.register("the-gss-compiler/lib/gss-compiler.js", function(exports, require, module){
var preparser = require('gss-preparser');
var ccss = require('ccss-compiler');
var vfl = require('vfl-compiler');

var runCompiler = function (chunk) {
  switch (chunk[0]) {
    case 'ccss':
      return ccss.parse(chunk[1]);
    case 'vfl':
      return vfl.parse(chunk[1]);
    case 'gtl':
      return gtl.parse(chunk[1]);
  }
};

exports.compile = function (gss) {
  var chunks = preparser.parse(gss);
  var results = {
    css: ''
  };
  chunks.forEach(function (chunk) {
    if (chunk[0] === 'css') {
      results.css += chunk[1];
      return;
    }
    var rules = runCompiler(chunk);
    for (var part in rules) {
      if (!results[part]) {
        results[part] = [];
      }
      results[part] = results[part].concat(rules[part]);
    }
  });
  return results;
};

});
require.register("the-gss-engine/lib/Engine.js", function(exports, require, module){
var Command, Engine, Get, Set,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __slice = [].slice;

Get = require("./dom/Getter.js");

Set = require("./dom/Setter.js");

Command = require("./Command.js");

Engine = (function() {
  function Engine(workerPath, container) {
    this.workerPath = workerPath;
    this.container = container;
    this._execute = __bind(this._execute, this);
    this.execute = __bind(this.execute, this);
    this.process = __bind(this.process, this);
    this.measure = __bind(this.measure, this);
    if (!this.container) {
      this.container = document;
    }
    this.commands = new Command(this);
    this.elements = {};
    this.variables = {};
    this.dimensions = {};
    this.worker = null;
    this.getter = new Get(this.container);
    this.setter = new Set(this.container);
    this.onSolved = null;
    this.commandsForWorker = [];
    this.queryCache = {};
    this.elsByGssId = {};
  }

  Engine.prototype.run = function(ast) {
    var astForWorker;
    this.execute(ast.commands);
    astForWorker = {
      commands: this.commandsForWorker
    };
    return this.solve(astForWorker);
  };

  Engine.prototype.measure = function(el, prop) {
    return this.getter.measure(el, prop);
  };

  Engine.prototype.measureByGssId = function(id, prop) {
    var el;
    el = this.elsByGssId[id];
    return this.measure(el, prop);
  };

  Engine.prototype.process = function(message) {
    var dimension, element, gid, key, values;
    values = message.data.values;
    for (key in values) {
      if (key[0] === "$") {
        gid = key.substring(1, key.indexOf("["));
        dimension = key.substring(key.indexOf("[") + 1, key.indexOf("]"));
        element = this.elsByGssId[gid];
        if (element) {
          this.setter.set(element, dimension, values[key]);
        } else {
          console.log("Element wasn't found");
        }
      }
    }
    if (this.onSolved) {
      return this.onSolved(values);
    }
  };

  Engine.prototype.handleError = function(error) {
    if (this.onError) {
      return this.onError(error);
    }
    throw new Error("" + event.message + " (" + event.filename + ":" + event.lineno + ")");
  };

  Engine.prototype.solve = function(ast) {
    if (!this.worker) {
      this.worker = new Worker(this.workerPath);
      this.worker.addEventListener("message", this.process, false);
      this.worker.addEventListener("error", this.handleError, false);
    }
    return this.worker.postMessage({
      ast: ast
    });
  };

  Engine.prototype.stop = function() {
    if (!this.worker) {
      return;
    }
    return this.worker.terminate();
  };

  Engine.prototype._current_gid = 1;

  Engine.prototype.gssId = function(el) {
    var gid;
    gid = el.getAttribute('data-gss-id');
    if (gid == null) {
      gid = this._current_gid++;
      el.setAttribute('data-gss-id', gid);
    }
    this.elsByGssId[gid] = el;
    return gid;
  };

  Engine.prototype.execute = function(commands) {
    var command, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = commands.length; _i < _len; _i++) {
      command = commands[_i];
      _results.push(this._execute(command, command));
    }
    return _results;
  };

  Engine.prototype._execute = function(command, root) {
    var func, i, node, sub, _i, _len, _ref;
    node = command;
    func = this.commands[node[0]];
    if (func == null) {
      throw new Error("Engine Commands broke, couldn't find method: " + node[0]);
    }
    _ref = node.slice(1, +node.length + 1 || 9e9);
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      sub = _ref[i];
      if (sub instanceof Array) {
        node.splice(i + 1, 1, this._execute(sub, root));
      }
    }
    return func.call.apply(func, [this, root].concat(__slice.call(node.slice(1, node.length))));
  };

  Engine.prototype._addVarCommandsForElements = function(elements) {
    return this.commandsForWorker.push("var", el.id + prop);
  };

  Engine.prototype.registerCommand = function(command) {
    return this.commandsForWorker.push(command);
  };

  Engine.prototype.registerDomQuery = function(selector, isMulti, isLive, createNodeList) {
    var el, id, nodeList, query, _i, _len;
    if (this.queryCache[selector] != null) {
      return this.queryCache[selector];
    } else {
      query = {};
      query.selector = selector;
      query.isQuery = true;
      query.isMulti = isMulti;
      query.isLive = isLive;
      nodeList = createNodeList();
      query.nodeList = nodeList;
      query.ids = [];
      for (_i = 0, _len = nodeList.length; _i < _len; _i++) {
        el = nodeList[_i];
        id = this.gssId(el);
        if (query.ids.indexOf(id) === -1) {
          query.ids.push(id);
        }
      }
      query.observer = new PathObserver(nodeList, 'length', function(newval, oldval) {
        return alert('handle nodelist change');
      });
      this.queryCache[selector] = query;
      return query;
    }
  };

  Engine.prototype.onElementsAdded = function(nodelist, callback) {
    var newEls;
    newEls = ['TBD...'];
    return callback.apply(this, newEls);
  };

  Engine.prototype.getVarsFromVarId = function(id) {};

  return Engine;

})();

module.exports = Engine;

});
require.register("the-gss-engine/lib/Command.js", function(exports, require, module){
/*

Root commands, if bound to a dom query, will spawn commands
to match live results of query.
*/

var Command, bindCache, bindRoot, checkCache, checkIntrinsics, getSuggestValueCommand, makeTemplateFromVarId, spawnCommands,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

bindCache = {};

checkCache = function(root, cacheKey) {
  var bind, binds, _i, _len, _results;
  binds = bindCache[cacheKey];
  if (binds != null) {
    _results = [];
    for (_i = 0, _len = binds.length; _i < _len; _i++) {
      bind = binds[_i];
      _results.push(bindRoot(root, bind));
    }
    return _results;
  }
};

bindRoot = function(root, query) {
  root._is_bound = true;
  if (root._binds == null) {
    root._binds = [];
  }
  if (root._binds.indexOf(query) === -1) {
    root._binds.push(query);
    if (query.isMulti) {
      if (root._binds.multi) {
        throw new Error("Multi el queries only allowed once per statement");
      }
      return root._binds.multi = query;
    }
  }
};

spawnCommands = function(root, engine, cacheKey) {
  var command, id, joiner, multiSplit, q, queries, ready, replaces, splitter, srcString, _i, _j, _len, _len1, _ref, _results;
  if (!root._is_bound) {
    return engine.registerCommand(root);
  } else {
    if (cacheKey) {
      bindCache[cacheKey] = root._binds;
    }
    queries = root._binds;
    srcString = JSON.stringify(root);
    replaces = {};
    ready = true;
    for (_i = 0, _len = queries.length; _i < _len; _i++) {
      q = queries[_i];
      if (q.ids.length < 0) {
        ready = false;
        break;
      }
      if (q !== queries.multi) {
        replaces[q.selector] = q.ids[0];
      }
    }
    if (ready) {
      if (queries.multi) {
        multiSplit = queries.multi.selector;
        _ref = queries.multi.ids;
        _results = [];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          id = _ref[_j];
          command = srcString.split("%%" + multiSplit + "%%");
          command = command.join("$" + id);
          for (splitter in replaces) {
            joiner = replaces[splitter];
            command = command.split("%%" + splitter + "%%");
            command = command.join("$" + joiner);
          }
          _results.push(engine.registerCommand(eval(command)));
        }
        return _results;
      } else {
        command = srcString;
        for (splitter in replaces) {
          joiner = replaces[splitter];
          command = command.split("%%" + splitter + "%%");
          command = command.join("$" + joiner);
        }
        return engine.registerCommand(eval(command));
      }
    }
  }
};

getSuggestValueCommand = function(gssId, prop, val) {
  return ['suggest', ['get', "$" + gssId + "[" + prop + "]"], ['number', val]];
};

checkIntrinsics = function(root, engine, varId, prop, query) {
  var id, val, _i, _len, _ref, _results;
  if (query != null) {
    if (prop.indexOf("intrinsic-") === 0) {
      _ref = query.ids;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        id = _ref[_i];
        val = engine.measureByGssId(id, prop.split("intrinsic-")[1]);
        _results.push(engine.registerCommand(getSuggestValueCommand(id, prop, val)));
      }
      return _results;
    }
  }
};

makeTemplateFromVarId = function(varId) {
  var templ, y;
  templ = varId;
  y = varId.split("[");
  if (y[0].length > 1) {
    y[y.length - 2] += "%%";
    templ = "%%" + y.join("[");
  }
  return templ;
};

Command = (function() {
  function Command(engine) {
    this['$id'] = __bind(this['$id'], this);
    this['$reserved'] = __bind(this['$reserved'], this);
    this['$tag'] = __bind(this['$tag'], this);
    this['$class'] = __bind(this['$class'], this);
    this['strength'] = __bind(this['strength'], this);
    this['stay'] = __bind(this['stay'], this);
    this['gt'] = __bind(this['gt'], this);
    this['lt'] = __bind(this['lt'], this);
    this['gte'] = __bind(this['gte'], this);
    this['lte'] = __bind(this['lte'], this);
    this['eq'] = __bind(this['eq'], this);
    this['get'] = __bind(this['get'], this);
    this['varexp'] = __bind(this['varexp'], this);
    this['var'] = __bind(this['var'], this);
    this.engine = engine;
  }

  Command.prototype['var'] = function(self, varId, prop, query) {
    self.splice(2, 10);
    self[1] = makeTemplateFromVarId(varId);
    if (self._is_bound) {
      self.push("%%" + query.selector + "%%");
    }
    spawnCommands(self, this.engine, varId);
    return checkIntrinsics(self, this.engine, varId, prop, query);
  };

  Command.prototype['varexp'] = function(self, varId, expression, zzz) {
    self.splice(3, 10);
    self[1] = makeTemplateFromVarId(varId);
    return spawnCommands(self, this.engine, varId);
  };

  Command.prototype['get'] = function(root, varId) {
    checkCache(root, varId);
    return ['get', makeTemplateFromVarId(varId)];
  };

  Command.prototype['number'] = function(root, num) {
    return ['number', num];
  };

  Command.prototype['plus'] = function(root, e1, e2) {
    return ['plus', e1, e2];
  };

  Command.prototype['minus'] = function(root, e1, e2) {
    return ['minus', e1, e2];
  };

  Command.prototype['multiply'] = function(root, e1, e2) {
    return ['multiply', e1, e2];
  };

  Command.prototype['divide'] = function(root, e1, e2, s, w) {
    return ['divide', e1, e2];
  };

  Command.prototype['eq'] = function(self, e1, e2, s, w) {
    return spawnCommands(self, this.engine);
  };

  Command.prototype['lte'] = function(self, e1, e2, s, w) {
    return spawnCommands(self, this.engine);
  };

  Command.prototype['gte'] = function(self, e1, e2, s, w) {
    return spawnCommands(self, this.engine);
  };

  Command.prototype['lt'] = function(self, e1, e2, s, w) {
    return spawnCommands(self, this.engine);
  };

  Command.prototype['gt'] = function(self, e1, e2, s, w) {
    return spawnCommands(self, this.engine);
  };

  Command.prototype['stay'] = function(self) {
    return spawnCommands(self, this.engine);
  };

  Command.prototype['strength'] = function(root, s) {
    return ['strength', s];
  };

  Command.prototype['$class'] = function(root, sel) {
    var query,
      _this = this;
    query = this.engine.registerDomQuery("." + sel, true, true, function() {
      return _this.engine.container.getElementsByClassName(sel);
    });
    bindRoot(root, query);
    return query;
  };

  Command.prototype['$tag'] = function(root, sel) {
    var query,
      _this = this;
    query = this.engine.registerDomQuery(sel, true, true, function() {
      return _this.engine.container.getElementsByTagName(sel);
    });
    bindRoot(root, query);
    return query;
  };

  Command.prototype['$reserved'] = function(root, sel) {
    return query;
  };

  Command.prototype['$id'] = function(root, sel) {
    var query,
      _this = this;
    query = this.engine.registerDomQuery("#" + sel, false, false, function() {
      var el;
      el = document.getElementById(sel);
      return [el];
    });
    bindRoot(root, query);
    return query;
  };

  return Command;

})();

module.exports = Command;

});
require.register("the-gss-engine/lib/dom/Getter.js", function(exports, require, module){
var Getter;

Getter = (function() {
  function Getter(container) {
    this.container = container;
    if (!this.container) {
      this.container = document;
    }
  }

  Getter.prototype.get = function(selector) {
    var identifier, method;
    method = selector[0];
    identifier = selector[1];
    switch (method) {
      case "$reserved":
        if (identifier === 'this') {
          return container;
        }
        break;
      case "$id":
        if (identifier[0] === '#') {
          identifier = identifier.substr(1);
        }
        return document.getElementById(identifier);
      case "$class":
        if (identifier[0] === '.') {
          identifier = identifier.substr(1);
        }
        return this.container.getElementsByClassName(identifier);
      case "$tag":
        return this.container.getElementsByTagName(identifier);
    }
    return this.container.querySelectorAll(identifier);
  };

  Getter.prototype.measure = function(element, dimension) {
    var scroll;
    switch (dimension) {
      case 'width':
      case 'w':
        return element.getBoundingClientRect().width;
      case 'height':
      case 'h':
        return element.getBoundingClientRect().height;
      case 'left':
      case 'x':
        scroll = window.scrollX || window.scrollLeft || 0;
        return element.getBoundingClientRect().left + scroll;
      case 'top':
      case 'y':
        scroll = window.scrollY || window.scrollTop || 0;
        return element.getBoundingClientRect().top + scroll;
      case 'bottom':
        return this.measure(element, 'top') + this.measure(element, 'height');
      case 'right':
        return this.measure(element, 'left') + this.measure(element, 'width');
      case 'centerX':
        return this.measure(element, 'left') + this.measure(element, 'width') / 2;
      case 'centerY':
        return this.measure(element, 'top') + this.measure(element, 'height') / 2;
    }
  };

  return Getter;

})();

module.exports = Getter;

});
require.register("the-gss-engine/lib/dom/Setter.js", function(exports, require, module){
var Setter;

Setter = (function() {
  function Setter(container) {
    this.container = container;
    if (!this.container) {
      this.container = document;
    }
  }

  Setter.prototype.set = function(element, dimension, value) {
    switch (dimension) {
      case 'width':
      case 'w':
        return this.setWidth(element, value);
      case 'height':
      case 'h':
        return this.setHeight(element, value);
      case 'left':
      case 'x':
        return this.setLeft(element, value);
      case 'top':
      case 'y':
        return this.setTop(element, value);
    }
  };

  Setter.prototype.makePositioned = function(element) {
    element.style.position = 'absolute';
    return element.style.margin = '0px';
  };

  Setter.prototype.getOffsets = function(element) {
    var offsets;
    offsets = {
      x: 0,
      y: 0
    };
    if (!element.offsetParent) {
      return offsets;
    }
    element = element.offsetParent;
    while (true) {
      offsets.x += element.offsetLeft;
      offsets.y += element.offsetTop;
      if (!element.offsetParent) {
        break;
      }
      element = element.offsetParent;
    }
    return offsets;
  };

  Setter.prototype.setWidth = function(element, value) {
    return element.style.width = "" + value + "px";
  };

  Setter.prototype.setHeight = function(element, value) {
    return element.style.height = "" + value + "px";
  };

  Setter.prototype.setLeft = function(element, value) {
    var offsets;
    this.makePositioned(element);
    offsets = this.getOffsets(element);
    return element.style.left = "" + (value - offsets.x) + "px";
  };

  Setter.prototype.setTop = function(element, value) {
    var offsets;
    this.makePositioned(element);
    offsets = this.getOffsets(element);
    return element.style.top = "" + (value - offsets.y) + "px";
  };

  return Setter;

})();

module.exports = Setter;

});
require.register("gss/lib/gss.js", function(exports, require, module){
var Engine, Gss, compiler;

compiler = require("gss-compiler");

Engine = require("gss-engine");

Gss = function(workerPath, container) {
  this.container = (container ? container : document);
  this.engine = new Engine(workerPath, container);
  return this;
};

Gss.prototype.run = function(rules) {
  var ast;
  ast = void 0;
  if (typeof rules === "string") {
    ast = compiler.compile(rules);
  } else if (typeof rules === "object") {
    ast = rules;
  } else {
    throw new Error("Unrecognized GSS rule format. Should be string or AST");
  }
  this.engine.run(ast);
  return this;
};

Gss.prototype.stop = function() {
  this.engine.stop();
  return this;
};

module.exports = Gss;

});
require.alias("the-gss-compiler/lib/gss-compiler.js", "gss/deps/gss-compiler/lib/gss-compiler.js");
require.alias("the-gss-compiler/lib/gss-compiler.js", "gss/deps/gss-compiler/index.js");
require.alias("the-gss-compiler/lib/gss-compiler.js", "gss-compiler/index.js");
require.alias("the-gss-preparser/lib/gss-preparser.js", "the-gss-compiler/deps/gss-preparser/lib/gss-preparser.js");
require.alias("the-gss-preparser/lib/gss-preparser.js", "the-gss-compiler/deps/gss-preparser/index.js");
require.alias("the-gss-preparser/lib/gss-preparser.js", "the-gss-preparser/index.js");

require.alias("the-gss-ccss-compiler/lib/ccss-compiler.js", "the-gss-compiler/deps/ccss-compiler/lib/ccss-compiler.js");
require.alias("the-gss-ccss-compiler/lib/ccss-compiler.js", "the-gss-compiler/deps/ccss-compiler/index.js");
require.alias("the-gss-ccss-compiler/lib/ccss-compiler.js", "the-gss-ccss-compiler/index.js");

require.alias("the-gss-vfl-compiler/lib/vfl-compiler.js", "the-gss-compiler/deps/vfl-compiler/lib/vfl-compiler.js");
require.alias("the-gss-vfl-compiler/lib/compiler.js", "the-gss-compiler/deps/vfl-compiler/lib/compiler.js");
require.alias("the-gss-vfl-compiler/lib/compiler.js", "the-gss-compiler/deps/vfl-compiler/index.js");
require.alias("the-gss-ccss-compiler/lib/ccss-compiler.js", "the-gss-vfl-compiler/deps/ccss-compiler/lib/ccss-compiler.js");
require.alias("the-gss-ccss-compiler/lib/ccss-compiler.js", "the-gss-vfl-compiler/deps/ccss-compiler/index.js");
require.alias("the-gss-ccss-compiler/lib/ccss-compiler.js", "the-gss-ccss-compiler/index.js");

require.alias("the-gss-vfl-compiler/lib/compiler.js", "the-gss-vfl-compiler/index.js");

require.alias("the-gss-compiler/lib/gss-compiler.js", "the-gss-compiler/index.js");

require.alias("the-gss-engine/lib/Engine.js", "gss/deps/gss-engine/lib/Engine.js");
require.alias("the-gss-engine/lib/Command.js", "gss/deps/gss-engine/lib/Command.js");
require.alias("the-gss-engine/lib/dom/Getter.js", "gss/deps/gss-engine/lib/dom/Getter.js");
require.alias("the-gss-engine/lib/dom/Setter.js", "gss/deps/gss-engine/lib/dom/Setter.js");
require.alias("the-gss-engine/lib/Engine.js", "gss/deps/gss-engine/index.js");
require.alias("the-gss-engine/lib/Engine.js", "gss-engine/index.js");
require.alias("the-gss-engine/lib/Engine.js", "the-gss-engine/index.js");

require.alias("gss/lib/gss.js", "gss/index.js");

